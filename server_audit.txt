=== PROJECT EXPORT (files + scripts + scenes) ===
res://.gitattributes
res://.gitignore
res://addons/godot_mcp/commands/base_command_processor.gd

--- res://addons/godot_mcp/commands/base_command_processor.gd ---
@tool
class_name MCPBaseCommandProcessor
extends Node

# Signal emitted when a command has completed processing
signal command_completed(client_id, command_type, result, command_id)

# Reference to the server - passed by the command handler
var _websocket_server = null

# Must be implemented by subclasses
func process_command(client_id: int, command_type: String, params: Dictionary, command_id: String) -> bool:
	push_error("BaseCommandProcessor.process_command called directly")
	return false

# Helper functions common to all command processors
func _send_success(client_id: int, result: Dictionary, command_id: String) -> void:
	var response = {
		"status": "success",
		"result": result
	}
	
	if not command_id.is_empty():
		response["commandId"] = command_id
	
	# Emit the signal for local processing (useful for testing)
	command_completed.emit(client_id, "success", result, command_id)
	
	# Send to websocket if available
	if _websocket_server:
		_websocket_server.send_response(client_id, response)

func _send_error(client_id: int, message: String, command_id: String) -> void:
	var response = {
		"status": "error",
		"message": message
	}
	
	if not command_id.is_empty():
		response["commandId"] = command_id
	
	# Emit the signal for local processing (useful for testing)
	var error_result = {"error": message}
	command_completed.emit(client_id, "error", error_result, command_id)
	
	# Send to websocket if available
	if _websocket_server:
		_websocket_server.send_response(client_id, response)
	print("Error: %s" % message)

# Common utility methods
func _get_editor_node(path: String) -> Node:
	var plugin = Engine.get_meta("GodotMCPPlugin")
	if not plugin:
		print("GodotMCPPlugin not found in Engine metadata")
		return null
		
	var editor_interface = plugin.get_editor_interface()
	var edited_scene_root = editor_interface.get_edited_scene_root()
	
	if not edited_scene_root:
		print("No edited scene found")
		return null
		
	# Handle absolute paths
	if path == "/root" or path == "":
		return edited_scene_root
		
	if path.begins_with("/root/"):
		path = path.substr(6)  # Remove "/root/"
	elif path.begins_with("/"):
		path = path.substr(1)  # Remove leading "/"
	
	# Try to find node as child of edited scene root
	return edited_scene_root.get_node_or_null(path)

# Helper function to mark a scene as modified
func _mark_scene_modified() -> void:
	var plugin = Engine.get_meta("GodotMCPPlugin")
	if not plugin:
		print("GodotMCPPlugin not found in Engine metadata")
		return
	
	var editor_interface = plugin.get_editor_interface()
	var edited_scene_root = editor_interface.get_edited_scene_root()
	
	if edited_scene_root:
		# This internally marks the scene as modified in the editor
		editor_interface.mark_scene_as_unsaved()

# Helper function to access the EditorUndoRedoManager
func _get_undo_redo():
	var plugin = Engine.get_meta("GodotMCPPlugin")
	if not plugin or not plugin.has_method("get_undo_redo"):
		print("Cannot access UndoRedo from plugin")
		return null
		
	return plugin.get_undo_redo()

# Helper function to parse property values from string to proper Godot types
func _parse_property_value(value):
	# Only try to parse strings that look like they could be Godot types
	if typeof(value) == TYPE_STRING and (
		value.begins_with("Vector") or 
		value.begins_with("Transform") or 
		value.begins_with("Rect") or 
		value.begins_with("Color") or
		value.begins_with("Quat") or
		value.begins_with("Basis") or
		value.begins_with("Plane") or
		value.begins_with("AABB") or
		value.begins_with("Projection") or
		value.begins_with("Callable") or
		value.begins_with("Signal") or
		value.begins_with("PackedVector") or
		value.begins_with("PackedString") or
		value.begins_with("PackedFloat") or
		value.begins_with("PackedInt") or
		value.begins_with("PackedColor") or
		value.begins_with("PackedByteArray") or
		value.begins_with("Dictionary") or
		value.begins_with("Array")
	):
		var expression = Expression.new()
		var error = expression.parse(value, [])
		
		if error == OK:
			var result = expression.execute([], null, true)
			if not expression.has_execute_failed():
				print("Successfully parsed %s as %s" % [value, result])
				return result
			else:
				print("Failed to execute expression for: %s" % value)
		else:
			print("Failed to parse expression: %s (Error: %d)" % [value, error])
	
	# Otherwise, return value as is
	return value
res://addons/godot_mcp/commands/base_command_processor.gd.uid
res://addons/godot_mcp/commands/editor_commands.gd

--- res://addons/godot_mcp/commands/editor_commands.gd ---
@tool
class_name MCPEditorCommands
extends MCPBaseCommandProcessor

func process_command(client_id: int, command_type: String, params: Dictionary, command_id: String) -> bool:
	match command_type:
		"get_editor_state":
			_get_editor_state(client_id, params, command_id)
			return true
		"get_selected_node":
			_get_selected_node(client_id, params, command_id)
			return true
		"create_resource":
			_create_resource(client_id, params, command_id)
			return true
	return false  # Command not handled

func _get_editor_state(client_id: int, params: Dictionary, command_id: String) -> void:
	# Get editor plugin and interfaces
	var plugin = Engine.get_meta("GodotMCPPlugin")
	if not plugin:
		return _send_error(client_id, "GodotMCPPlugin not found in Engine metadata", command_id)
	
	var editor_interface = plugin.get_editor_interface()
	
	var state = {
		"current_scene": "",
		"current_script": "",
		"selected_nodes": [],
		"is_playing": editor_interface.is_playing_scene()
	}
	
	# Get current scene
	var edited_scene_root = editor_interface.get_edited_scene_root()
	if edited_scene_root:
		state["current_scene"] = edited_scene_root.scene_file_path
	
	# Get current script if any is being edited
	var script_editor = editor_interface.get_script_editor()
	var current_script = script_editor.get_current_script()
	if current_script:
		state["current_script"] = current_script.resource_path
	
	# Get selected nodes
	var selection = editor_interface.get_selection()
	var selected_nodes = selection.get_selected_nodes()
	
	for node in selected_nodes:
		state["selected_nodes"].append({
			"name": node.name,
			"path": str(node.get_path())
		})
	
	_send_success(client_id, state, command_id)

func _get_selected_node(client_id: int, params: Dictionary, command_id: String) -> void:
	# Get editor plugin and interfaces
	var plugin = Engine.get_meta("GodotMCPPlugin")
	if not plugin:
		return _send_error(client_id, "GodotMCPPlugin not found in Engine metadata", command_id)
	
	var editor_interface = plugin.get_editor_interface()
	var selection = editor_interface.get_selection()
	var selected_nodes = selection.get_selected_nodes()
	
	if selected_nodes.size() == 0:
		return _send_success(client_id, {
			"selected": false,
			"message": "No node is currently selected"
		}, command_id)
	
	var node = selected_nodes[0]  # Get the first selected node
	
	# Get node info
	var node_data = {
		"selected": true,
		"name": node.name,
		"type": node.get_class(),
		"path": str(node.get_path())
	}
	
	# Get script info if available
	var script = node.get_script()
	if script:
		node_data["script_path"] = script.resource_path
	
	# Get important properties
	var properties = {}
	var property_list = node.get_property_list()
	
	for prop in property_list:
		var name = prop["name"]
		if not name.begins_with("_"):  # Skip internal properties
			# Only include some common properties to avoid overwhelming data
			if name in ["position", "rotation", "scale", "visible", "modulate", "z_index"]:
				properties[name] = node.get(name)
	
	node_data["properties"] = properties
	
	_send_success(client_id, node_data, command_id)

func _create_resource(client_id: int, params: Dictionary, command_id: String) -> void:
	var resource_type = params.get("resource_type", "")
	var resource_path = params.get("resource_path", "")
	var properties = params.get("properties", {})
	
	# Validation
	if resource_type.is_empty():
		return _send_error(client_id, "Resource type cannot be empty", command_id)
	
	if resource_path.is_empty():
		return _send_error(client_id, "Resource path cannot be empty", command_id)
	
	# Make sure we have an absolute path
	if not resource_path.begins_with("res://"):
		resource_path = "res://" + resource_path
	
	# Get editor interface
	var plugin = Engine.get_meta("GodotMCPPlugin")
	if not plugin:
		return _send_error(client_id, "GodotMCPPlugin not found in Engine metadata", command_id)
	
	var editor_interface = plugin.get_editor_interface()
	
	# Create the resource
	var resource
	
	if ClassDB.class_exists(resource_type):
		if ClassDB.is_parent_class(resource_type, "Resource"):
			resource = ClassDB.instantiate(resource_type)
			if not resource:
				return _send_error(client_id, "Failed to instantiate resource: %s" % resource_type, command_id)
		else:
			return _send_error(client_id, "Type is not a Resource: %s" % resource_type, command_id)
	else:
		return _send_error(client_id, "Invalid resource type: %s" % resource_type, command_id)
	
	# Set properties
	for key in properties:
		resource.set(key, properties[key])
	
	# Create directory if needed
	var dir = resource_path.get_base_dir()
	if not DirAccess.dir_exists_absolute(dir):
		var err = DirAccess.make_dir_recursive_absolute(dir)
		if err != OK:
			return _send_error(client_id, "Failed to create directory: %s (Error code: %d)" % [dir, err], command_id)
	
	# Save the resource
	var result = ResourceSaver.save(resource, resource_path)
	if result != OK:
		return _send_error(client_id, "Failed to save resource: %d" % result, command_id)
	
	# Refresh the filesystem
	editor_interface.get_resource_filesystem().scan()
	
	_send_success(client_id, {
		"resource_path": resource_path,
		"resource_type": resource_type
	}, command_id)
res://addons/godot_mcp/commands/editor_commands.gd.uid
res://addons/godot_mcp/commands/editor_script_commands.gd

--- res://addons/godot_mcp/commands/editor_script_commands.gd ---
@tool
class_name MCPEditorScriptCommands
extends MCPBaseCommandProcessor

func process_command(client_id: int, command_type: String, params: Dictionary, command_id: String) -> bool:
	match command_type:
		"execute_editor_script":
			_execute_editor_script(client_id, params, command_id)
			return true
	return false  # Command not handled

func _execute_editor_script(client_id: int, params: Dictionary, command_id: String) -> void:
	var code = params.get("code", "")
	
	# Validation
	if code.is_empty():
		return _send_error(client_id, "Code cannot be empty", command_id)
	
	# Create a temporary script node to execute the code
	var script_node := Node.new()
	script_node.name = "EditorScriptExecutor"
	add_child(script_node)
	
	# Create a temporary script
	var script = GDScript.new()
	
	var output = []
	var error_message = ""
	var execution_result = null
	
	# Replace print() calls with custom_print() in the user code
	var modified_code = _replace_print_calls(code)
	
	# Use consistent tab indentation in the template
	var script_content = """@tool
extends Node

signal execution_completed

# Variable to store the result
var result = null
var _output_array = []
var _error_message = ""
var _parent

# Custom print function that stores output in the array
func custom_print(values):
	# Convert array of values to a single string
	var output_str = ""
	if values is Array:
		for i in range(values.size()):
			if i > 0:
				output_str += " "
			output_str += str(values[i])
	else:
		output_str = str(values)
		
	_output_array.append(output_str)
	print(output_str)  # Still print to the console for debugging

func run():
	print("Executing script... ready func")
	_parent = get_parent()
	var scene = get_tree().edited_scene_root
	
	# Execute the provided code
	var err = _execute_code()
	
	# If there was an error, store it
	if err != OK:
		_error_message = "Failed to execute script with error: " + str(err)
	
	# Signal that execution is complete
	execution_completed.emit()

func _execute_code():
	# USER CODE START
{user_code}
	# USER CODE END
	return OK
"""
	
	# Process the user code to ensure consistent indentation
	# This helps prevent "mixed tabs and spaces" errors
	var processed_lines = []
	var lines = modified_code.split("\n")
	for line in lines:
		# Replace any spaces at the beginning with tabs
		var processed_line = line
		
		# If line starts with spaces, replace with a tab
		var space_count = 0
		for i in range(line.length()):
			if line[i] == " ":
				space_count += 1
			else:
				break
		
		# If we found spaces at the beginning, replace with tabs
		if space_count > 0:
			# Create tabs based on space count (e.g., 4 spaces = 1 tab)
			var tabs = ""
			for _i in range(space_count / 4): # Integer division
				tabs += "\t"
			processed_line = tabs + line.substr(space_count)
			
		processed_lines.append(processed_line)
	
	var indented_code = ""
	for line in processed_lines:
		indented_code += "\t" + line + "\n"
	
	script_content = script_content.replace("{user_code}", indented_code)
	script.source_code = script_content
	
	# Check for script errors during parsing
	var error = script.reload()
	if error != OK:
		remove_child(script_node)
		script_node.queue_free()
		return _send_error(client_id, "Script parsing error: " + str(error), command_id)
	
	# Assign the script to the node
	script_node.set_script(script)
	
	# Connect to the execution_completed signal
	script_node.connect("execution_completed", _on_script_execution_completed.bind(script_node, client_id, command_id))

	script_node.run()


# Signal handler for when script execution completes
func _on_script_execution_completed(script_node: Node, client_id: int, command_id: String) -> void:
	# Collect results safely by checking if properties exist
	var execution_result = script_node.get("result")
	var output = script_node._output_array
	var error_message = script_node._error_message
	
	# Clean up
	remove_child(script_node)
	script_node.queue_free()
	
	# Build the response
	var result_data = {
		"success": error_message.is_empty(),
		"output": output
	}

	print("result_data: ", result_data)
	
	if not error_message.is_empty():
		result_data["error"] = error_message
	elif execution_result != null:
		result_data["result"] = execution_result
	
	_send_success(client_id, result_data, command_id)

# Replace print() calls with custom_print() in the user code
func _replace_print_calls(code: String) -> String:
	var regex = RegEx.new()
	# Match print statements with any content inside the parentheses
	regex.compile("print\\s*\\(([^\\)]+)\\)")
	
	var result = regex.search_all(code)
	var modified_code = code
	
	# Process matches in reverse order to avoid issues with changing string length
	for i in range(result.size() - 1, -1, -1):
		var match_obj = result[i]
		var full_match = match_obj.get_string()
		var arg_content = match_obj.get_string(1)
		
		# Create an array with all arguments
		var replacement = "custom_print([" + arg_content + "])"
		
		var start = match_obj.get_start()
		var end = match_obj.get_end()
		
		modified_code = modified_code.substr(0, start) + replacement + modified_code.substr(end)
	
	return modified_code
res://addons/godot_mcp/commands/editor_script_commands.gd.uid
res://addons/godot_mcp/commands/node_commands.gd

--- res://addons/godot_mcp/commands/node_commands.gd ---
@tool
class_name MCPNodeCommands
extends MCPBaseCommandProcessor

func process_command(client_id: int, command_type: String, params: Dictionary, command_id: String) -> bool:
	match command_type:
		"create_node":
			_create_node(client_id, params, command_id)
			return true
		"delete_node":
			_delete_node(client_id, params, command_id)
			return true
		"update_node_property":
			_update_node_property(client_id, params, command_id)
			return true
		"get_node_properties":
			_get_node_properties(client_id, params, command_id)
			return true
		"list_nodes":
			_list_nodes(client_id, params, command_id)
			return true
	return false  # Command not handled

func _create_node(client_id: int, params: Dictionary, command_id: String) -> void:
	var parent_path = params.get("parent_path", "/root")
	var node_type = params.get("node_type", "Node")
	var node_name = params.get("node_name", "NewNode")
	
	# Validation
	if not ClassDB.class_exists(node_type):
		return _send_error(client_id, "Invalid node type: %s" % node_type, command_id)
	
	# Get editor plugin and interfaces
	var plugin = Engine.get_meta("GodotMCPPlugin")
	if not plugin:
		return _send_error(client_id, "GodotMCPPlugin not found in Engine metadata", command_id)
	
	var editor_interface = plugin.get_editor_interface()
	var edited_scene_root = editor_interface.get_edited_scene_root()
	
	if not edited_scene_root:
		return _send_error(client_id, "No scene is currently being edited", command_id)
	
	# Get the parent node using the editor node helper
	var parent = _get_editor_node(parent_path)
	if not parent:
		return _send_error(client_id, "Parent node not found: %s" % parent_path, command_id)
	
	# Create the node
	var node
	if ClassDB.can_instantiate(node_type):
		node = ClassDB.instantiate(node_type)
	else:
		return _send_error(client_id, "Cannot instantiate node of type: %s" % node_type, command_id)
	
	if not node:
		return _send_error(client_id, "Failed to create node of type: %s" % node_type, command_id)
	
	# Set the node name
	node.name = node_name
	
	# Add the node to the parent
	parent.add_child(node)
	
	# Set owner for proper serialization
	node.owner = edited_scene_root
	
	# Mark the scene as modified
	_mark_scene_modified()
	
	_send_success(client_id, {
		"node_path": parent_path + "/" + node_name
	}, command_id)

func _delete_node(client_id: int, params: Dictionary, command_id: String) -> void:
	var node_path = params.get("node_path", "")
	
	# Validation
	if node_path.is_empty():
		return _send_error(client_id, "Node path cannot be empty", command_id)
	
	# Get editor plugin and interfaces
	var plugin = Engine.get_meta("GodotMCPPlugin")
	if not plugin:
		return _send_error(client_id, "GodotMCPPlugin not found in Engine metadata", command_id)
	
	var editor_interface = plugin.get_editor_interface()
	var edited_scene_root = editor_interface.get_edited_scene_root()
	
	if not edited_scene_root:
		return _send_error(client_id, "No scene is currently being edited", command_id)
	
	# Get the node using the editor node helper
	var node = _get_editor_node(node_path)
	if not node:
		return _send_error(client_id, "Node not found: %s" % node_path, command_id)
	
	# Cannot delete the root node
	if node == edited_scene_root:
		return _send_error(client_id, "Cannot delete the root node", command_id)
	
	# Get parent for operation
	var parent = node.get_parent()
	if not parent:
		return _send_error(client_id, "Node has no parent: %s" % node_path, command_id)
	
	# Remove the node
	parent.remove_child(node)
	node.queue_free()
	
	# Mark the scene as modified
	_mark_scene_modified()
	
	_send_success(client_id, {
		"deleted_node_path": node_path
	}, command_id)

func _update_node_property(client_id: int, params: Dictionary, command_id: String) -> void:
	var node_path = params.get("node_path", "")
	var property_name = params.get("property", "")
	var property_value = params.get("value")
	
	# Validation
	if node_path.is_empty():
		return _send_error(client_id, "Node path cannot be empty", command_id)
	
	if property_name.is_empty():
		return _send_error(client_id, "Property name cannot be empty", command_id)
	
	if property_value == null:
		return _send_error(client_id, "Property value cannot be null", command_id)
	
	# Get editor plugin and interfaces
	var plugin = Engine.get_meta("GodotMCPPlugin")
	if not plugin:
		return _send_error(client_id, "GodotMCPPlugin not found in Engine metadata", command_id)
	
	# Get the node using the editor node helper
	var node = _get_editor_node(node_path)
	if not node:
		return _send_error(client_id, "Node not found: %s" % node_path, command_id)
	
	# Check if the property exists
	if not property_name in node:
		return _send_error(client_id, "Property %s does not exist on node %s" % [property_name, node_path], command_id)
	
	# Parse property value for Godot types
	var parsed_value = _parse_property_value(property_value)
	
	# Get current property value for undo
	var old_value = node.get(property_name)
	
	# Get undo/redo system
	var undo_redo = _get_undo_redo()
	if not undo_redo:
		# Fallback method if we can't get undo/redo
		node.set(property_name, parsed_value)
		_mark_scene_modified()
	else:
		# Use undo/redo for proper editor integration
		undo_redo.create_action("Update Property: " + property_name)
		undo_redo.add_do_property(node, property_name, parsed_value)
		undo_redo.add_undo_property(node, property_name, old_value)
		undo_redo.commit_action()
	
	# Mark the scene as modified
	_mark_scene_modified()
	
	_send_success(client_id, {
		"node_path": node_path,
		"property": property_name,
		"value": property_value,
		"parsed_value": str(parsed_value)
	}, command_id)

func _get_node_properties(client_id: int, params: Dictionary, command_id: String) -> void:
	var node_path = params.get("node_path", "")
	
	# Validation
	if node_path.is_empty():
		return _send_error(client_id, "Node path cannot be empty", command_id)
	
	# Get the node using the editor node helper
	var node = _get_editor_node(node_path)
	if not node:
		return _send_error(client_id, "Node not found: %s" % node_path, command_id)
	
	# Get all properties
	var properties = {}
	var property_list = node.get_property_list()
	
	for prop in property_list:
		var name = prop["name"]
		if not name.begins_with("_"):  # Skip internal properties
			properties[name] = node.get(name)
	
	_send_success(client_id, {
		"node_path": node_path,
		"properties": properties
	}, command_id)

func _list_nodes(client_id: int, params: Dictionary, command_id: String) -> void:
	var parent_path = params.get("parent_path", "/root")
	
	# Get the parent node using the editor node helper
	var parent = _get_editor_node(parent_path)
	if not parent:
		return _send_error(client_id, "Parent node not found: %s" % parent_path, command_id)
	
	# Get children
	var children = []
	for child in parent.get_children():
		children.append({
			"name": child.name,
			"type": child.get_class(),
			"path": str(child.get_path()).replace(str(parent.get_path()), parent_path)
		})
	
	_send_success(client_id, {
		"parent_path": parent_path,
		"children": children
	}, command_id)
res://addons/godot_mcp/commands/node_commands.gd.uid
res://addons/godot_mcp/commands/project_commands.gd

--- res://addons/godot_mcp/commands/project_commands.gd ---
@tool
class_name MCPProjectCommands
extends MCPBaseCommandProcessor

func process_command(client_id: int, command_type: String, params: Dictionary, command_id: String) -> bool:
	match command_type:
		"get_project_info":
			_get_project_info(client_id, params, command_id)
			return true
		"list_project_files":
			_list_project_files(client_id, params, command_id)
			return true
		"get_project_structure":
			_get_project_structure(client_id, params, command_id)
			return true
		"get_project_settings":
			_get_project_settings(client_id, params, command_id)
			return true
		"list_project_resources":
			_list_project_resources(client_id, params, command_id)
			return true
	return false  # Command not handled

func _get_project_info(client_id: int, _params: Dictionary, command_id: String) -> void:
	var project_name = ProjectSettings.get_setting("application/config/name", "Untitled Project")
	var project_version = ProjectSettings.get_setting("application/config/version", "1.0.0")
	var project_path = ProjectSettings.globalize_path("res://")
	
	# Get Godot version info and structure it as expected by the server
	var version_info = Engine.get_version_info()
	print("Raw Godot version info: ", version_info)
	
	# Create structured version object with the expected properties
	var structured_version = {
		"major": version_info.get("major", 0),
		"minor": version_info.get("minor", 0),
		"patch": version_info.get("patch", 0)
	}
	
	_send_success(client_id, {
		"project_name": project_name,
		"project_version": project_version,
		"project_path": project_path,
		"godot_version": structured_version,
		"current_scene": get_tree().edited_scene_root.scene_file_path if get_tree().edited_scene_root else ""
	}, command_id)

func _list_project_files(client_id: int, params: Dictionary, command_id: String) -> void:
	var extensions = params.get("extensions", [])
	var files = []
	
	# Get all files with the specified extensions
	var dir = DirAccess.open("res://")
	if dir:
		_scan_directory(dir, "", extensions, files)
	else:
		return _send_error(client_id, "Failed to open res:// directory", command_id)
	
	_send_success(client_id, {
		"files": files
	}, command_id)

func _scan_directory(dir: DirAccess, path: String, extensions: Array, files: Array) -> void:
	dir.list_dir_begin()
	var file_name = dir.get_next()
	
	while file_name != "":
		if dir.current_is_dir():
			var subdir = DirAccess.open("res://" + path + file_name)
			if subdir:
				_scan_directory(subdir, path + file_name + "/", extensions, files)
		else:
			var file_path = path + file_name
			var has_valid_extension = extensions.is_empty()
			
			for ext in extensions:
				if file_name.ends_with(ext):
					has_valid_extension = true
					break
			
			if has_valid_extension:
				files.append("res://" + file_path)
		
		file_name = dir.get_next()
	
	dir.list_dir_end()

func _get_project_structure(client_id: int, params: Dictionary, command_id: String) -> void:
	var structure = {
		"directories": [],
		"file_counts": {},
		"total_files": 0
	}
	
	var dir = DirAccess.open("res://")
	if dir:
		_analyze_project_structure(dir, "", structure)
	else:
		return _send_error(client_id, "Failed to open res:// directory", command_id)
	
	_send_success(client_id, structure, command_id)

func _analyze_project_structure(dir: DirAccess, path: String, structure: Dictionary) -> void:
	dir.list_dir_begin()
	var file_name = dir.get_next()
	
	while file_name != "":
		if dir.current_is_dir():
			var dir_path = path + file_name + "/"
			structure["directories"].append("res://" + dir_path)
			
			var subdir = DirAccess.open("res://" + dir_path)
			if subdir:
				_analyze_project_structure(subdir, dir_path, structure)
		else:
			structure["total_files"] += 1
			
			var extension = file_name.get_extension()
			if extension in structure["file_counts"]:
				structure["file_counts"][extension] += 1
			else:
				structure["file_counts"][extension] = 1
		
		file_name = dir.get_next()
	
	dir.list_dir_end()

func _get_project_settings(client_id: int, params: Dictionary, command_id: String) -> void:
	# Get relevant project settings
	var settings = {
		"project_name": ProjectSettings.get_setting("application/config/name", "Untitled Project"),
		"project_version": ProjectSettings.get_setting("application/config/version", "1.0.0"),
		"display": {
			"width": ProjectSettings.get_setting("display/window/size/viewport_width", 1024),
			"height": ProjectSettings.get_setting("display/window/size/viewport_height", 600),
			"mode": ProjectSettings.get_setting("display/window/size/mode", 0),
			"resizable": ProjectSettings.get_setting("display/window/size/resizable", true)
		},
		"physics": {
			"2d": {
				"default_gravity": ProjectSettings.get_setting("physics/2d/default_gravity", 980)
			},
			"3d": {
				"default_gravity": ProjectSettings.get_setting("physics/3d/default_gravity", 9.8)
			}
		},
		"rendering": {
			"quality": {
				"msaa": ProjectSettings.get_setting("rendering/anti_aliasing/quality/msaa_2d", 0)
			}
		},
		"input_map": {}
	}
	
	# Get input mappings
	var input_map = ProjectSettings.get_setting("input")
	if input_map:
		settings["input_map"] = input_map
	
	_send_success(client_id, settings, command_id)

func _list_project_resources(client_id: int, params: Dictionary, command_id: String) -> void:
	var resources = {
		"scenes": [],
		"scripts": [],
		"textures": [],
		"audio": [],
		"models": [],
		"resources": []
	}
	
	var dir = DirAccess.open("res://")
	if dir:
		_scan_resources(dir, "", resources)
	else:
		return _send_error(client_id, "Failed to open res:// directory", command_id)
	
	_send_success(client_id, resources, command_id)

func _scan_resources(dir: DirAccess, path: String, resources: Dictionary) -> void:
	dir.list_dir_begin()
	var file_name = dir.get_next()
	
	while file_name != "":
		if dir.current_is_dir():
			var subdir = DirAccess.open("res://" + path + file_name)
			if subdir:
				_scan_resources(subdir, path + file_name + "/", resources)
		else:
			var file_path = "res://" + path + file_name
			
			# Categorize by extension
			if file_name.ends_with(".tscn") or file_name.ends_with(".scn"):
				resources["scenes"].append(file_path)
			elif file_name.ends_with(".gd") or file_name.ends_with(".cs"):
				resources["scripts"].append(file_path)
			elif file_name.ends_with(".png") or file_name.ends_with(".jpg") or file_name.ends_with(".jpeg"):
				resources["textures"].append(file_path)
			elif file_name.ends_with(".wav") or file_name.ends_with(".ogg") or file_name.ends_with(".mp3"):
				resources["audio"].append(file_path)
			elif file_name.ends_with(".obj") or file_name.ends_with(".glb") or file_name.ends_with(".gltf"):
				resources["models"].append(file_path)
			elif file_name.ends_with(".tres") or file_name.ends_with(".res"):
				resources["resources"].append(file_path)
		
		file_name = dir.get_next()
	
	dir.list_dir_end()
res://addons/godot_mcp/commands/project_commands.gd.uid
res://addons/godot_mcp/commands/scene_commands.gd

--- res://addons/godot_mcp/commands/scene_commands.gd ---
@tool
class_name MCPSceneCommands
extends MCPBaseCommandProcessor

func process_command(client_id: int, command_type: String, params: Dictionary, command_id: String) -> bool:
	match command_type:
		"save_scene":
			_save_scene(client_id, params, command_id)
			return true
		"open_scene":
			_open_scene(client_id, params, command_id)
			return true
		"get_current_scene":
			_get_current_scene(client_id, params, command_id)
			return true
		"get_scene_structure":
			_get_scene_structure(client_id, params, command_id)
			return true
		"create_scene":
			_create_scene(client_id, params, command_id)
			return true
	return false  # Command not handled

func _save_scene(client_id: int, params: Dictionary, command_id: String) -> void:
	var path = params.get("path", "")
	
	# Get editor plugin and interfaces
	var plugin = Engine.get_meta("GodotMCPPlugin")
	if not plugin:
		return _send_error(client_id, "GodotMCPPlugin not found in Engine metadata", command_id)
	
	var editor_interface = plugin.get_editor_interface()
	var edited_scene_root = editor_interface.get_edited_scene_root()
	
	# If no path provided, use the current scene path
	if path.is_empty() and edited_scene_root:
		path = edited_scene_root.scene_file_path
	
	# Validation
	if path.is_empty():
		return _send_error(client_id, "Scene path cannot be empty", command_id)
	
	# Make sure we have an absolute path
	if not path.begins_with("res://"):
		path = "res://" + path
	
	if not path.ends_with(".tscn"):
		path += ".tscn"
	
	# Check if we have an edited scene
	if not edited_scene_root:
		return _send_error(client_id, "No scene is currently being edited", command_id)
	
	# Save the scene
	var packed_scene = PackedScene.new()
	var result = packed_scene.pack(edited_scene_root)
	if result != OK:
		return _send_error(client_id, "Failed to pack scene: %d" % result, command_id)
	
	result = ResourceSaver.save(packed_scene, path)
	if result != OK:
		return _send_error(client_id, "Failed to save scene: %d" % result, command_id)
	
	_send_success(client_id, {
		"scene_path": path
	}, command_id)

func _open_scene(client_id: int, params: Dictionary, command_id: String) -> void:
	var path = params.get("path", "")
	
	# Validation
	if path.is_empty():
		return _send_error(client_id, "Scene path cannot be empty", command_id)
	
	# Make sure we have an absolute path
	if not path.begins_with("res://"):
		path = "res://" + path
	
	# Check if the file exists
	if not FileAccess.file_exists(path):
		return _send_error(client_id, "Scene file not found: %s" % path, command_id)
	
	# Since we can't directly open scenes in tool scripts,
	# we need to defer to the plugin which has access to EditorInterface
	var plugin = Engine.get_meta("GodotMCPPlugin") if Engine.has_meta("GodotMCPPlugin") else null
	
	if plugin and plugin.has_method("get_editor_interface"):
		var editor_interface = plugin.get_editor_interface()
		editor_interface.open_scene_from_path(path)
		_send_success(client_id, {
			"scene_path": path
		}, command_id)
	else:
		_send_error(client_id, "Cannot access EditorInterface. Please open the scene manually: %s" % path, command_id)

func _get_current_scene(client_id: int, _params: Dictionary, command_id: String) -> void:
	# Get editor plugin and interfaces
	var plugin = Engine.get_meta("GodotMCPPlugin")
	if not plugin:
		return _send_error(client_id, "GodotMCPPlugin not found in Engine metadata", command_id)
	
	var editor_interface = plugin.get_editor_interface()
	var edited_scene_root = editor_interface.get_edited_scene_root()
	
	if not edited_scene_root:
		print("No scene is currently being edited")
		# Instead of returning an error, return a valid response with empty/default values
		_send_success(client_id, {
			"scene_path": "None",
			"root_node_type": "None",
			"root_node_name": "None"
		}, command_id)
		return
	
	var scene_path = edited_scene_root.scene_file_path
	if scene_path.is_empty():
		scene_path = "Untitled"
	
	print("Current scene path: ", scene_path)
	print("Root node type: ", edited_scene_root.get_class())
	print("Root node name: ", edited_scene_root.name)
	
	_send_success(client_id, {
		"scene_path": scene_path,
		"root_node_type": edited_scene_root.get_class(),
		"root_node_name": edited_scene_root.name
	}, command_id)

func _get_scene_structure(client_id: int, params: Dictionary, command_id: String) -> void:
	var path = params.get("path", "")
	
	# Validation
	if path.is_empty():
		return _send_error(client_id, "Scene path cannot be empty", command_id)
	
	if not path.begins_with("res://"):
		path = "res://" + path
	
	if not FileAccess.file_exists(path):
		return _send_error(client_id, "Scene file not found: " + path, command_id)
	
	# Load the scene to analyze its structure
	var packed_scene = load(path)
	if not packed_scene:
		return _send_error(client_id, "Failed to load scene: " + path, command_id)
	
	# Create a temporary instance to analyze
	var scene_instance = packed_scene.instantiate()
	if not scene_instance:
		return _send_error(client_id, "Failed to instantiate scene: " + path, command_id)
	
	# Get the scene structure
	var structure = _get_node_structure(scene_instance)
	
	# Clean up the temporary instance
	scene_instance.queue_free()
	
	# Return the structure
	_send_success(client_id, {
		"path": path,
		"structure": structure
	}, command_id)

func _get_node_structure(node: Node) -> Dictionary:
	var structure = {
		"name": node.name,
		"type": node.get_class(),
		"path": node.get_path()
	}
	
	# Get script information
	var script = node.get_script()
	if script:
		structure["script"] = script.resource_path
	
	# Get important properties
	var properties = {}
	var property_list = node.get_property_list()
	
	for prop in property_list:
		var name = prop["name"]
		# Filter to include only the most useful properties
		if not name.begins_with("_") and name not in ["script", "children", "position", "rotation", "scale"]:
			continue
		
		# Skip properties that are default values
		if name == "position" and node.position == Vector2():
			continue
		if name == "rotation" and node.rotation == 0:
			continue
		if name == "scale" and node.scale == Vector2(1, 1):
			continue
		
		properties[name] = node.get(name)
	
	structure["properties"] = properties
	
	# Get children
	var children = []
	for child in node.get_children():
		children.append(_get_node_structure(child))
	
	structure["children"] = children
	
	return structure

func _create_scene(client_id: int, params: Dictionary, command_id: String) -> void:
	var path = params.get("path", "")
	var root_node_type = params.get("root_node_type", "Node")
	
	# Validation
	if path.is_empty():
		return _send_error(client_id, "Scene path cannot be empty", command_id)
	
	# Make sure we have an absolute path
	if not path.begins_with("res://"):
		path = "res://" + path
	
	# Ensure path ends with .tscn
	if not path.ends_with(".tscn"):
		path += ".tscn"
	
	# Create directory structure if it doesn't exist
	var dir_path = path.get_base_dir()
	if not DirAccess.dir_exists_absolute(dir_path):
		var dir = DirAccess.open("res://")
		if dir:
			dir.make_dir_recursive(dir_path.trim_prefix("res://"))
	
	# Check if file already exists
	if FileAccess.file_exists(path):
		return _send_error(client_id, "Scene file already exists: %s" % path, command_id)
	
	# Create the root node of the specified type
	var root_node = null
	
	match root_node_type:
		"Node":
			root_node = Node.new()
		"Node2D":
			root_node = Node2D.new()
		"Node3D", "Spatial":
			root_node = Node3D.new()
		"Control":
			root_node = Control.new()
		"CanvasLayer":
			root_node = CanvasLayer.new()
		"Panel":
			root_node = Panel.new()
		_:
			# Attempt to create a custom class if built-in type not recognized
			if ClassDB.class_exists(root_node_type):
				root_node = ClassDB.instantiate(root_node_type)
			else:
				return _send_error(client_id, "Invalid root node type: %s" % root_node_type, command_id)
	
	# Give the root node a name based on the file name
	var file_name = path.get_file().get_basename()
	root_node.name = file_name
	
	# Create a packed scene
	var packed_scene = PackedScene.new()
	var result = packed_scene.pack(root_node)
	if result != OK:
		root_node.free()
		return _send_error(client_id, "Failed to pack scene: %d" % result, command_id)
	
	# Save the packed scene to disk
	result = ResourceSaver.save(packed_scene, path)
	if result != OK:
		root_node.free()
		return _send_error(client_id, "Failed to save scene: %d" % result, command_id)
	
	# Clean up
	root_node.free()
	
	# Try to open the scene in the editor
	var plugin = Engine.get_meta("GodotMCPPlugin") if Engine.has_meta("GodotMCPPlugin") else null
	if plugin and plugin.has_method("get_editor_interface"):
		var editor_interface = plugin.get_editor_interface()
		editor_interface.open_scene_from_path(path)
	
	_send_success(client_id, {
		"scene_path": path,
		"root_node_type": root_node_type
	}, command_id)
res://addons/godot_mcp/commands/scene_commands.gd.uid
res://addons/godot_mcp/commands/script_commands.gd

--- res://addons/godot_mcp/commands/script_commands.gd ---
@tool
class_name MCPScriptCommands
extends MCPBaseCommandProcessor

func process_command(client_id: int, command_type: String, params: Dictionary, command_id: String) -> bool:
	match command_type:
		"create_script":
			_create_script(client_id, params, command_id)
			return true
		"edit_script":
			_edit_script(client_id, params, command_id)
			return true
		"get_script":
			_get_script(client_id, params, command_id)
			return true
		"get_script_metadata":
			_get_script_metadata(client_id, params, command_id)
			return true
		"get_current_script":
			_get_current_script(client_id, params, command_id)
			return true
		"create_script_template":
			_create_script_template(client_id, params, command_id)
			return true
	return false  # Command not handled

func _create_script(client_id: int, params: Dictionary, command_id: String) -> void:
	var script_path = params.get("script_path", "")
	var content = params.get("content", "")
	var node_path = params.get("node_path", "")
	
	# Validation
	if script_path.is_empty():
		return _send_error(client_id, "Script path cannot be empty", command_id)
	
	# Make sure we have an absolute path
	if not script_path.begins_with("res://"):
		script_path = "res://" + script_path
	
	if not script_path.ends_with(".gd"):
		script_path += ".gd"
	
	# Get editor plugin and interfaces
	var plugin = Engine.get_meta("GodotMCPPlugin")
	if not plugin:
		return _send_error(client_id, "GodotMCPPlugin not found in Engine metadata", command_id)
	
	var editor_interface = plugin.get_editor_interface()
	var script_editor = editor_interface.get_script_editor()
	
	# Create the directory if it doesn't exist
	var dir = script_path.get_base_dir()
	if not DirAccess.dir_exists_absolute(dir):
		var err = DirAccess.make_dir_recursive_absolute(dir)
		if err != OK:
			return _send_error(client_id, "Failed to create directory: %s (Error code: %d)" % [dir, err], command_id)
	
	# Create the script file
	var file = FileAccess.open(script_path, FileAccess.WRITE)
	if file == null:
		return _send_error(client_id, "Failed to create script file: %s" % script_path, command_id)
	
	file.store_string(content)
	file = null  # Close the file
	
	# Refresh the filesystem
	editor_interface.get_resource_filesystem().scan()
	
	# Attach the script to a node if specified
	if not node_path.is_empty():
		var node = _get_editor_node(node_path)
		if not node:
			return _send_error(client_id, "Node not found: %s" % node_path, command_id)
		
		# Wait for script to be recognized in the filesystem
		await get_tree().create_timer(0.5).timeout
		
		var script = load(script_path)
		if not script:
			return _send_error(client_id, "Failed to load script: %s" % script_path, command_id)
		
		# Use undo/redo for script assignment
		var undo_redo = _get_undo_redo()
		if not undo_redo:
			# Fallback method if we can't get undo/redo
			node.set_script(script)
			_mark_scene_modified()
		else:
			# Use undo/redo for proper editor integration
			undo_redo.create_action("Assign Script")
			undo_redo.add_do_method(node, "set_script", script)
			undo_redo.add_undo_method(node, "set_script", node.get_script())
			undo_redo.commit_action()
		
		# Mark the scene as modified
		_mark_scene_modified()
	
	# Open the script in the editor
	var script_resource = load(script_path)
	if script_resource:
		editor_interface.edit_script(script_resource)
	
	_send_success(client_id, {
		"script_path": script_path,
		"node_path": node_path
	}, command_id)

func _edit_script(client_id: int, params: Dictionary, command_id: String) -> void:
	var script_path = params.get("script_path", "")
	var content = params.get("content", "")
	
	# Validation
	if script_path.is_empty():
		return _send_error(client_id, "Script path cannot be empty", command_id)
	
	if content.is_empty():
		return _send_error(client_id, "Content cannot be empty", command_id)
	
	# Make sure we have an absolute path
	if not script_path.begins_with("res://"):
		script_path = "res://" + script_path
	
	# Check if the file exists
	if not FileAccess.file_exists(script_path):
		return _send_error(client_id, "Script file not found: %s" % script_path, command_id)
	
	# Edit the script file
	var file = FileAccess.open(script_path, FileAccess.WRITE)
	if file == null:
		return _send_error(client_id, "Failed to open script file: %s" % script_path, command_id)
	
	file.store_string(content)
	file = null  # Close the file
	
	_send_success(client_id, {
		"script_path": script_path
	}, command_id)

func _get_script(client_id: int, params: Dictionary, command_id: String) -> void:
	var script_path = params.get("script_path", "")
	var node_path = params.get("node_path", "")
	
	# Validation - either script_path or node_path must be provided
	if script_path.is_empty() and node_path.is_empty():
		return _send_error(client_id, "Either script_path or node_path must be provided", command_id)
	
	# If node_path is provided, get the script from the node
	if not node_path.is_empty():
		var node = _get_editor_node(node_path)
		if not node:
			return _send_error(client_id, "Node not found: %s" % node_path, command_id)
		
		var script = node.get_script()
		if not script:
			return _send_error(client_id, "Node does not have a script: %s" % node_path, command_id)
		
		script_path = script.resource_path
	
	# Make sure we have an absolute path
	if not script_path.begins_with("res://"):
		script_path = "res://" + script_path
	
	# Check if the file exists
	if not FileAccess.file_exists(script_path):
		return _send_error(client_id, "Script file not found: %s" % script_path, command_id)
	
	# Read the script file
	var file = FileAccess.open(script_path, FileAccess.READ)
	if file == null:
		return _send_error(client_id, "Failed to open script file: %s" % script_path, command_id)
	
	var content = file.get_as_text()
	file = null  # Close the file
	
	_send_success(client_id, {
		"script_path": script_path,
		"content": content
	}, command_id)

func _get_script_metadata(client_id: int, params: Dictionary, command_id: String) -> void:
	var path = params.get("path", "")
	
	# Validation
	if path.is_empty():
		return _send_error(client_id, "Script path cannot be empty", command_id)
	
	if not path.begins_with("res://"):
		path = "res://" + path
	
	if not FileAccess.file_exists(path):
		return _send_error(client_id, "Script file not found: " + path, command_id)
	
	# Load the script
	var script = load(path)
	if not script:
		return _send_error(client_id, "Failed to load script: " + path, command_id)
	
	# Extract script metadata
	var metadata = {
		"path": path,
		"language": "gdscript" if path.ends_with(".gd") else "csharp" if path.ends_with(".cs") else "unknown"
	}
	
	# Attempt to get script class info
	var class_name_str = ""
	var extends_class = ""
	
	# Read the file to extract class_name and extends info
	var file = FileAccess.open(path, FileAccess.READ)
	if file:
		var content = file.get_as_text()
		
		# Extract class_name
		var class_regex = RegEx.new()
		class_regex.compile("class_name\\s+([a-zA-Z_][a-zA-Z0-9_]*)")
		var result = class_regex.search(content)
		if result:
			class_name_str = result.get_string(1)
		
		# Extract extends
		var extends_regex = RegEx.new()
		extends_regex.compile("extends\\s+([a-zA-Z_][a-zA-Z0-9_]*)")
		result = extends_regex.search(content)
		if result:
			extends_class = result.get_string(1)
		
		# Add to metadata
		metadata["class_name"] = class_name_str
		metadata["extends"] = extends_class
		
		# Try to extract methods and signals
		var methods = []
		var signals = []
		
		var method_regex = RegEx.new()
		method_regex.compile("func\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\(")
		var method_matches = method_regex.search_all(content)
		
		for match_result in method_matches:
			methods.append(match_result.get_string(1))
		
		var signal_regex = RegEx.new()
		signal_regex.compile("signal\\s+([a-zA-Z_][a-zA-Z0-9_]*)")
		var signal_matches = signal_regex.search_all(content)
		
		for match_result in signal_matches:
			signals.append(match_result.get_string(1))
		
		metadata["methods"] = methods
		metadata["signals"] = signals
	
	_send_success(client_id, metadata, command_id)

func _get_current_script(client_id: int, params: Dictionary, command_id: String) -> void:
	# Get editor plugin and interfaces
	var plugin = Engine.get_meta("GodotMCPPlugin")
	if not plugin:
		return _send_error(client_id, "GodotMCPPlugin not found in Engine metadata", command_id)
	
	var editor_interface = plugin.get_editor_interface()
	var script_editor = editor_interface.get_script_editor()
	var current_script = script_editor.get_current_script()
	
	if not current_script:
		return _send_success(client_id, {
			"script_found": false,
			"message": "No script is currently being edited"
		}, command_id)
	
	var script_path = current_script.resource_path
	
	# Read the script content
	var file = FileAccess.open(script_path, FileAccess.READ)
	if not file:
		return _send_error(client_id, "Failed to open script file: %s" % script_path, command_id)
	
	var content = file.get_as_text()
	file = null  # Close the file
	
	_send_success(client_id, {
		"script_found": true,
		"script_path": script_path,
		"content": content
	}, command_id)

func _create_script_template(client_id: int, params: Dictionary, command_id: String) -> void:
	var extends_type = params.get("extends_type", "Node")
	var class_name_str = params.get("class_name", "")
	var include_ready = params.get("include_ready", true)
	var include_process = params.get("include_process", false)
	var include_physics = params.get("include_physics", false)
	var include_input = params.get("include_input", false)
	
	# Generate script content
	var content = "extends " + extends_type + "\n\n"
	
	if not class_name_str.is_empty():
		content += "class_name " + class_name_str + "\n\n"
	
	# Add variables section placeholder
	content += "# Member variables here\n\n"
	
	# Add ready function
	if include_ready:
		content += "func _ready():\n\tpass\n\n"
	
	# Add process function
	if include_process:
		content += "func _process(delta):\n\tpass\n\n"
	
	# Add physics process function
	if include_physics:
		content += "func _physics_process(delta):\n\tpass\n\n"
	
	# Add input function
	if include_input:
		content += "func _input(event):\n\tpass\n\n"
	
	_send_success(client_id, {
		"content": content
	}, command_id)
res://addons/godot_mcp/commands/script_commands.gd.uid
res://addons/godot_mcp/command_handler.gd

--- res://addons/godot_mcp/command_handler.gd ---
@tool
class_name MCPCommandHandler
extends Node

var _websocket_server
var _command_processors = []

func _ready():
	print("Command handler initializing...")
	await get_tree().process_frame
	_websocket_server = get_parent()
	print("WebSocket server reference set: ", _websocket_server)
	
	# Initialize command processors
	_initialize_command_processors()
	
	print("Command handler initialized and ready to process commands")

func _initialize_command_processors():
	# Create and add all command processors
	var node_commands = MCPNodeCommands.new()
	var script_commands = MCPScriptCommands.new()
	var scene_commands = MCPSceneCommands.new() 
	var project_commands = MCPProjectCommands.new()
	var editor_commands = MCPEditorCommands.new()
	var editor_script_commands = MCPEditorScriptCommands.new()  # Add our new processor
	
	# Set server reference for all processors
	node_commands._websocket_server = _websocket_server
	script_commands._websocket_server = _websocket_server
	scene_commands._websocket_server = _websocket_server
	project_commands._websocket_server = _websocket_server
	editor_commands._websocket_server = _websocket_server
	editor_script_commands._websocket_server = _websocket_server  # Set server reference
	
	# Add them to our processor list
	_command_processors.append(node_commands)
	_command_processors.append(script_commands)
	_command_processors.append(scene_commands)
	_command_processors.append(project_commands)
	_command_processors.append(editor_commands)
	_command_processors.append(editor_script_commands)  # Add to processor list
	
	# Add them as children for proper lifecycle management
	add_child(node_commands)
	add_child(script_commands)
	add_child(scene_commands)
	add_child(project_commands)
	add_child(editor_commands)
	add_child(editor_script_commands)  # Add as child

func _handle_command(client_id: int, command: Dictionary) -> void:
	var command_type = command.get("type", "")
	var params = command.get("params", {})
	var command_id = command.get("commandId", "")
	
	print("Processing command: %s" % command_type)
	
	# Try each processor until one handles the command
	for processor in _command_processors:
		if processor.process_command(client_id, command_type, params, command_id):
			return
	
	# If no processor handled the command, send an error
	_send_error(client_id, "Unknown command: %s" % command_type, command_id)

func _send_error(client_id: int, message: String, command_id: String) -> void:
	var response = {
		"status": "error",
		"message": message
	}
	
	if not command_id.is_empty():
		response["commandId"] = command_id
	
	_websocket_server.send_response(client_id, response)
	print("Error: %s" % message)
res://addons/godot_mcp/command_handler.gd.uid
res://addons/godot_mcp/mcp_server.gd

--- res://addons/godot_mcp/mcp_server.gd ---
@tool
extends EditorPlugin

var tcp_server := TCPServer.new()
var port := 9080
var handshake_timeout := 3000 # ms
var debug_mode := true
var log_detailed := true  # Enable detailed logging
var command_handler = null  # Command handler reference

signal client_connected(id)
signal client_disconnected(id)
signal command_received(client_id, command)

class WebSocketClient:
	var tcp: StreamPeerTCP
	var id: int
	var ws: WebSocketPeer
	var state: int = -1 # -1: handshaking, 0: connected, 1: error/closed
	var handshake_time: int
	var last_poll_time: int
	
	func _init(p_tcp: StreamPeerTCP, p_id: int):
		tcp = p_tcp
		id = p_id
		handshake_time = Time.get_ticks_msec()
	
	func upgrade_to_websocket() -> bool:
		ws = WebSocketPeer.new()
		var err = ws.accept_stream(tcp)
		return err == OK

var clients := {}
var next_client_id := 1

func _enter_tree():
	# Store plugin instance for EditorInterface access
	Engine.set_meta("GodotMCPPlugin", self)
	
	print("\n=== MCP SERVER STARTING ===")
	
	# Initialize the command handler
	print("Creating command handler...")
	command_handler = preload("res://addons/godot_mcp/command_handler.gd").new()
	command_handler.name = "CommandHandler"
	add_child(command_handler)
	
	# Connect signals
	print("Connecting command handler signals...")
	self.connect("command_received", Callable(command_handler, "_handle_command"))
	
	# Start WebSocket server
	var err = tcp_server.listen(port)
	if err == OK:
		print("Listening on port", port)
		set_process(true)
	else:
		printerr("Failed to listen on port", port, "error:", err)
	
	print("=== MCP SERVER INITIALIZED ===\n")

func _exit_tree():
	# Remove plugin instance from Engine metadata
	if Engine.has_meta("GodotMCPPlugin"):
		Engine.remove_meta("GodotMCPPlugin")
	
	if tcp_server and tcp_server.is_listening():
		tcp_server.stop()
	
	clients.clear()
	
	print("=== MCP SERVER SHUTDOWN ===")

func _log(client_id, message):
	if log_detailed:
		print("[Client ", client_id, "] ", message)

func _process(_delta):
	if not tcp_server.is_listening():
		return
	
	# Poll for new connections
	if tcp_server.is_connection_available():
		var tcp = tcp_server.take_connection()
		var id = next_client_id
		next_client_id += 1
		
		var client = WebSocketClient.new(tcp, id)
		clients[id] = client
		
		print("[Client ", id, "] New TCP connection")
		
		# Try to upgrade immediately
		if client.upgrade_to_websocket():
			print("[Client ", id, "] WebSocket handshake started")
		else:
			print("[Client ", id, "] Failed to start WebSocket handshake")
			clients.erase(id)
	
	# Update clients
	var current_time = Time.get_ticks_msec()
	var ids_to_remove := []
	
	for id in clients:
		var client = clients[id]
		client.last_poll_time = current_time
		
		# Process client based on its state
		if client.state == -1: # Handshaking
			if client.ws != null:
				# Poll the WebSocket peer
				client.ws.poll()
				
				# Check WebSocket state
				var ws_state = client.ws.get_ready_state()
				if debug_mode:
					_log(id, "State: " + str(ws_state))
					
				if ws_state == WebSocketPeer.STATE_OPEN:
					print("[Client ", id, "] WebSocket handshake completed")
					client.state = 0
					
					# Emit connected signal
					emit_signal("client_connected", id)
					
					# Send welcome message
					var msg = JSON.stringify({
						"type": "welcome",
						"message": "Welcome to Godot MCP WebSocket Server"
					})
					client.ws.send_text(msg)
					
				elif ws_state != WebSocketPeer.STATE_CONNECTING:
					print("[Client ", id, "] WebSocket handshake failed, state: ", ws_state)
					ids_to_remove.append(id)
				
				# Check for handshake timeout
				elif current_time - client.handshake_time > handshake_timeout:
					print("[Client ", id, "] WebSocket handshake timed out")
					ids_to_remove.append(id)
			else:
				# If TCP is still connected, try upgrading
				if client.tcp.get_status() == StreamPeerTCP.STATUS_CONNECTED:
					if client.upgrade_to_websocket():
						print("[Client ", id, "] WebSocket handshake started")
					else:
						print("[Client ", id, "] Failed to start WebSocket handshake")
						ids_to_remove.append(id)
				else:
					print("[Client ", id, "] TCP disconnected during handshake")
					ids_to_remove.append(id)
		
		elif client.state == 0: # Connected
			# Poll the WebSocket
			client.ws.poll()
			
			# Check state
			var ws_state = client.ws.get_ready_state()
			if ws_state != WebSocketPeer.STATE_OPEN:
				print("[Client ", id, "] WebSocket connection closed, state: ", ws_state)
				emit_signal("client_disconnected", id)
				ids_to_remove.append(id)
				continue
			
			# Process messages
			while client.ws.get_available_packet_count() > 0:
				var packet = client.ws.get_packet()
				var text = packet.get_string_from_utf8()
				
				print("[Client ", id, "] RECEIVED RAW DATA: ", text)
				
				# Parse as JSON
				var json = JSON.new()
				var parse_result = json.parse(text)
				_log(id, "JSON parse result: " + str(parse_result))
				
				if parse_result == OK:
					var data = json.get_data()
					_log(id, "Parsed JSON: " + str(data))
					
					# Handle JSON-RPC protocol
					if data.has("jsonrpc") and data.get("jsonrpc") == "2.0":
						# Handle ping method
						if data.has("method") and data.get("method") == "ping":
							print("[Client ", id, "] Received PING with id: ", data.get("id"))
							var response = {
								"jsonrpc": "2.0",
								"id": data.get("id"),
								"result": null  # FastMCP expects null result for pings
							}
							var response_text = JSON.stringify(response)
							var send_result = client.ws.send_text(response_text)
							print("[Client ", id, "] SENDING PING RESPONSE: ", response_text, " (result: ", send_result, ")")
						
						# Handle other MCP commands
						elif data.has("method"):
							var method_name = data.get("method")
							var params = data.get("params", {})
							var req_id = data.get("id")
							
							print("[Client ", id, "] Processing JSON-RPC method: ", method_name)
							
							# For now, just send a generic success response
							# TODO: Route these to command handler as well
							var response = {
								"jsonrpc": "2.0",
								"id": req_id,
								"result": {
									"status": "success",
									"message": "Command processed"
								}
							}
							
							var response_text = JSON.stringify(response)
							var send_result = client.ws.send_text(response_text)
							print("[Client ", id, "] SENT RESPONSE: ", response_text, " (result: ", send_result, ")")
					
					# Handle legacy command format - This is what Claude Code uses
					elif data.has("type"):
						var cmd_type = data.get("type")
						var params = data.get("params", {})
						var cmd_id = data.get("commandId", "")
						
						print("[Client ", id, "] Processing command: ", cmd_type)
						
						# Route command to command handler via signal
						# The command handler will handle the response via send_response
						emit_signal("command_received", id, data)
				else:
					print("[Client ", id, "] Failed to parse JSON: ", json.get_error_message())
	
	# Remove clients that need to be removed
	for id in ids_to_remove:
		clients.erase(id)

# Function for command handler to send responses back to clients
func send_response(client_id: int, response: Dictionary) -> int:
	if not clients.has(client_id):
		print("Error: Client %d not found" % client_id)
		return ERR_DOES_NOT_EXIST
	
	var client = clients[client_id]
	var json_text = JSON.stringify(response)
	
	print("Sending response to client %d: %s" % [client_id, json_text])
	
	if client.ws.get_ready_state() != WebSocketPeer.STATE_OPEN:
		print("Error: Client %d connection not open" % client_id)
		return ERR_UNAVAILABLE
	
	var result = client.ws.send_text(json_text)
	if result != OK:
		print("Error sending response to client %d: %d" % [client_id, result])
	
	return result

func is_server_active() -> bool:
	return tcp_server.is_listening()

func stop_server() -> void:
	if is_server_active():
		tcp_server.stop()
		clients.clear()
		print("MCP WebSocket server stopped")
		
func get_port() -> int:
	return port
res://addons/godot_mcp/mcp_server.gd.uid
res://addons/godot_mcp/plugin.cfg
res://addons/godot_mcp/ui/mcp_panel.gd

--- res://addons/godot_mcp/ui/mcp_panel.gd ---
@tool
extends Control

var websocket_server: MCPWebSocketServer
var status_label: Label
var port_input: SpinBox
var start_button: Button
var stop_button: Button
var connection_count_label: Label
var log_text: TextEdit

func _ready():
	status_label = $VBoxContainer/StatusContainer/StatusLabel
	port_input = $VBoxContainer/PortContainer/PortSpinBox
	start_button = $VBoxContainer/ButtonsContainer/StartButton
	stop_button = $VBoxContainer/ButtonsContainer/StopButton
	connection_count_label = $VBoxContainer/ConnectionsContainer/CountLabel
	log_text = $VBoxContainer/LogContainer/LogText
	
	start_button.pressed.connect(_on_start_button_pressed)
	stop_button.pressed.connect(_on_stop_button_pressed)
	port_input.value_changed.connect(_on_port_changed)
	
	# Initial UI setup
	_update_ui()
	
	# Setup server signals once it's available
	await get_tree().process_frame
	if websocket_server:
		websocket_server.connect("client_connected", Callable(self, "_on_client_connected"))
		websocket_server.connect("client_disconnected", Callable(self, "_on_client_disconnected"))
		websocket_server.connect("command_received", Callable(self, "_on_command_received"))
		
		port_input.value = websocket_server.get_port()

func _update_ui():
	if not websocket_server:
		status_label.text = "Server: Not initialized"
		start_button.disabled = true
		stop_button.disabled = true
		port_input.editable = true
		connection_count_label.text = "0"
		return
	
	var is_active = websocket_server.is_server_active()
	
	status_label.text = "Server: " + ("Running" if is_active else "Stopped")
	start_button.disabled = is_active
	stop_button.disabled = not is_active
	port_input.editable = not is_active
	
	if is_active:
		connection_count_label.text = str(websocket_server.get_client_count())
	else:
		connection_count_label.text = "0"

func _on_start_button_pressed():
	if websocket_server:
		var result = websocket_server.start_server()
		if result == OK:
			_log_message("Server started on port " + str(websocket_server.get_port()))
		else:
			_log_message("Failed to start server: " + str(result))
		_update_ui()

func _on_stop_button_pressed():
	if websocket_server:
		websocket_server.stop_server()
		_log_message("Server stopped")
		_update_ui()

func _on_port_changed(new_port: float):
	if websocket_server:
		websocket_server.set_port(int(new_port))
		_log_message("Port changed to " + str(int(new_port)))

func _on_client_connected(client_id: int):
	_log_message("Client connected: " + str(client_id))
	_update_ui()

func _on_client_disconnected(client_id: int):
	_log_message("Client disconnected: " + str(client_id))
	_update_ui()

func _on_command_received(client_id: int, command: Dictionary):
	var command_type = command.get("type", "unknown")
	var command_id = command.get("commandId", "no-id")
	_log_message("Received command: " + command_type + " (ID: " + command_id + ") from client " + str(client_id))

func _log_message(message: String):
	var timestamp = Time.get_datetime_string_from_system()
	log_text.text += "[" + timestamp + "] " + message + "\n"
	# Auto-scroll to bottom
	log_text.scroll_vertical = log_text.get_line_count()res://addons/godot_mcp/ui/mcp_panel.gd.uid
res://addons/godot_mcp/ui/mcp_panel.tscn

--- res://addons/godot_mcp/ui/mcp_panel.tscn ---
[gd_scene load_steps=2 format=3 uid="uid://c2kuk5yuiage8"]

[ext_resource type="Script" path="res://addons/godot_mcp/ui/mcp_panel.gd" id="1_3cbiu"]

[node name="MCPPanel" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_3cbiu")

[node name="VBoxContainer" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="TitleLabel" type="Label" parent="VBoxContainer"]
layout_mode = 2
text = "Godot MCP Server"
horizontal_alignment = 1

[node name="HSeparator" type="HSeparator" parent="VBoxContainer"]
layout_mode = 2

[node name="StatusContainer" type="HBoxContainer" parent="VBoxContainer"]
layout_mode = 2

[node name="Label" type="Label" parent="VBoxContainer/StatusContainer"]
layout_mode = 2
text = "Status:"

[node name="StatusLabel" type="Label" parent="VBoxContainer/StatusContainer"]
layout_mode = 2
size_flags_horizontal = 3
text = "Server: Stopped"

[node name="PortContainer" type="HBoxContainer" parent="VBoxContainer"]
layout_mode = 2

[node name="Label" type="Label" parent="VBoxContainer/PortContainer"]
layout_mode = 2
text = "Port:"

[node name="PortSpinBox" type="SpinBox" parent="VBoxContainer/PortContainer"]
layout_mode = 2
size_flags_horizontal = 3
min_value = 1.0
max_value = 65535.0
value = 9080.0

[node name="ButtonsContainer" type="HBoxContainer" parent="VBoxContainer"]
layout_mode = 2

[node name="StartButton" type="Button" parent="VBoxContainer/ButtonsContainer"]
layout_mode = 2
size_flags_horizontal = 3
text = "Start Server"

[node name="StopButton" type="Button" parent="VBoxContainer/ButtonsContainer"]
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "Stop Server"

[node name="ConnectionsContainer" type="HBoxContainer" parent="VBoxContainer"]
layout_mode = 2

[node name="Label" type="Label" parent="VBoxContainer/ConnectionsContainer"]
layout_mode = 2
text = "Connected Clients:"

[node name="CountLabel" type="Label" parent="VBoxContainer/ConnectionsContainer"]
layout_mode = 2
text = "0"

[node name="HSeparator2" type="HSeparator" parent="VBoxContainer"]
layout_mode = 2

[node name="LogLabel" type="Label" parent="VBoxContainer"]
layout_mode = 2
text = "Server Log:"

[node name="LogContainer" type="VBoxContainer" parent="VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3

[node name="LogText" type="TextEdit" parent="VBoxContainer/LogContainer"]
layout_mode = 2
size_flags_vertical = 3
editable = false
wrap_mode = 1res://addons/godot_mcp/utils/node_utils.gd

--- res://addons/godot_mcp/utils/node_utils.gd ---
@tool
class_name NodeUtils
extends RefCounted

# Get all nodes of a certain type in the scene tree
static func get_nodes_by_type(root_node: Node, type_name: String) -> Array[Node]:
	var result: Array[Node] = []
	
	if root_node.get_class() == type_name:
		result.push_back(root_node)
	
	for child in root_node.get_children():
		result.append_array(get_nodes_by_type(child, type_name))
	
	return result

# Get a node by its path, or null if not found
static func find_node_by_path(root_node: Node, path: String) -> Node:
	if path.is_empty():
		return null
	
	if path.begins_with("/"):
		path = path.substr(1)
	
	var path_parts = path.split("/")
	var current_node = root_node
	
	for part in path_parts:
		var found = false
		for child in current_node.get_children():
			if child.name == part:
				current_node = child
				found = true
				break
		
		if not found:
			return null
	
	return current_node

# Convert a node to a JSON-compatible dictionary
static func node_to_dict(node: Node) -> Dictionary:
	var result = {
		"name": node.name,
		"type": node.get_class(),
		"path": str(node.get_path()),
		"properties": {}
	}
	
	# Get properties
	var properties = {}
	var property_list = node.get_property_list()
	
	for prop in property_list:
		var name = prop["name"]
		if not name.begins_with("_"): # Skip internal properties
			result["properties"][name] = node.get(name)
	
	# Get children
	var children = []
	for child in node.get_children():
		children.append({
			"name": child.name,
			"type": child.get_class(),
			"path": str(child.get_path())
		})
	
	result["children"] = children
	
	return result

# Create a screenshot of a node (only works for CanvasItem nodes)
static func take_node_screenshot(node: CanvasItem) -> Image:
	if not node is CanvasItem:
		push_error("Can only take screenshots of CanvasItem nodes")
		return null
	
	var viewport = node.get_viewport()
	if not viewport:
		return null
	
	return viewport.get_texture().get_image()
res://addons/godot_mcp/utils/node_utils.gd.uid
res://addons/godot_mcp/utils/resource_utils.gd

--- res://addons/godot_mcp/utils/resource_utils.gd ---
@tool
class_name ResourceUtils
extends RefCounted

# Load a resource safely, returning null if it fails
static func safe_load(path: String) -> Resource:
	if not ResourceLoader.exists(path):
		push_error("Resource does not exist: " + path)
		return null
	
	var res = ResourceLoader.load(path)
	if not res:
		push_error("Failed to load resource: " + path)
		return null
	
	return res

# Save a resource safely, returning true if successful
static func safe_save(resource: Resource, path: String) -> bool:
	if not resource:
		push_error("Cannot save null resource")
		return false
	
	# Make sure directory exists
	var dir_path = path.get_base_dir()
	if not DirAccess.dir_exists_absolute(dir_path):
		var err = DirAccess.make_dir_recursive_absolute(dir_path)
		if err != OK:
			push_error("Failed to create directory: " + dir_path)
			return false
	
	var result = ResourceSaver.save(resource, path)
	if result != OK:
		push_error("Failed to save resource: " + path)
		return false
	
	return true

# Create a new resource instance by type name
static func create_resource(type_name: String) -> Resource:
	if not ClassDB.class_exists(type_name):
		push_error("Class does not exist: " + type_name)
		return null
	
	if not ClassDB.is_parent_class(type_name, "Resource"):
		push_error("Class is not a Resource: " + type_name)
		return null
	
	if not ClassDB.can_instantiate(type_name):
		push_error("Cannot instantiate Resource class: " + type_name)
		return null
	
	return ClassDB.instantiate(type_name)

# Get a list of all resource types that inherit from a base class
static func get_resource_types(base_class: String = "Resource") -> Array[String]:
	var result: Array[String] = []
	
	for class_type in ClassDB.get_class_list():
		if ClassDB.is_parent_class(class_type, base_class) and ClassDB.can_instantiate(class_type):
			result.append(class_type)
	
	return result

# Convert a resource to a JSON-compatible dictionary
static func resource_to_dict(resource: Resource) -> Dictionary:
	var result = {
		"resource_path": resource.resource_path,
		"resource_name": resource.resource_name,
		"type": resource.get_class(),
		"properties": {}
	}
	
	# Get properties
	var property_list = resource.get_property_list()
	for prop in property_list:
		var prop_name = prop["name"]
		if not prop_name.begins_with("_") and prop_name != "resource_path" and prop_name != "resource_name":
			result["properties"][prop_name] = resource.get(prop_name)
	
	return result
res://addons/godot_mcp/utils/resource_utils.gd.uid
res://addons/godot_mcp/utils/script_utils.gd

--- res://addons/godot_mcp/utils/script_utils.gd ---
@tool
class_name ScriptUtils
extends RefCounted

# Create a new GDScript with basic template content
static func create_new_script(class_name_str: String = "", extends_type: String = "Node") -> GDScript:
	var script = GDScript.new()
	var content = ""
	
	if not class_name_str.is_empty():
		content += "class_name " + class_name_str + "\n"
	
	content += "extends " + extends_type + "\n\n"
	content += "func _ready():\n"
	content += "\tpass\n"
	
	script.source_code = content
	return script

# Create a new script file with basic template content
static func create_script_file(path: String, class_name_str: String = "", extends_type: String = "Node") -> bool:
	# Make sure directory exists
	var dir_path = path.get_base_dir()
	if not DirAccess.dir_exists_absolute(dir_path):
		var err = DirAccess.make_dir_recursive_absolute(dir_path)
		if err != OK:
			push_error("Failed to create directory: " + dir_path)
			return false
	
	var content = ""
	
	if not class_name_str.is_empty():
		content += "class_name " + class_name_str + "\n"
	
	content += "extends " + extends_type + "\n\n"
	content += "func _ready():\n"
	content += "\tpass\n"
	
	var file = FileAccess.open(path, FileAccess.WRITE)
	if file == null:
		push_error("Failed to open file for writing: " + path)
		return false
	
	file.store_string(content)
	file = null  # Close the file
	
	return true

# Parse a script file and extract its class name and base class
static func get_script_info(path: String) -> Dictionary:
	var result = {
		"class_name": "",
		"extends": "",
		"path": path
	}
	
	var file = FileAccess.open(path, FileAccess.READ)
	if file == null:
		push_error("Failed to open file for reading: " + path)
		return result
	
	var content = file.get_as_text()
	file = null  # Close the file
	
	# Find class_name
	var class_name_regex = RegEx.new()
	class_name_regex.compile("class_name\\s+([A-Za-z0-9_]+)")
	var matches = class_name_regex.search(content)
	if matches:
		result["class_name"] = matches.get_string(1)
	
	# Find extends
	var extends_regex = RegEx.new()
	extends_regex.compile("extends\\s+([A-Za-z0-9_]+)")
	matches = extends_regex.search(content)
	if matches:
		result["extends"] = matches.get_string(1)
	
	return result

# Extract all method names from a script
static func get_script_methods(path: String) -> Array:
	var methods = []
	
	var file = FileAccess.open(path, FileAccess.READ)
	if file == null:
		push_error("Failed to open file for reading: " + path)
		return methods
	
	var content = file.get_as_text()
	file = null  # Close the file
	
	var method_regex = RegEx.new()
	method_regex.compile("func\\s+([A-Za-z0-9_]+)\\s*\\(")
	
	var matches = method_regex.search_all(content)
	for match_idx in range(matches.size()):
		methods.append(matches[match_idx].get_string(1))
	
	return methods

# Apply a script to a node
static func apply_script_to_node(node: Node, script_path: String) -> bool:
	if not node:
		push_error("Node is null")
		return false
	
	var script = ResourceLoader.load(script_path)
	if not script:
		push_error("Failed to load script: " + script_path)
		return false
	
	node.set_script(script)
	return trueres://addons/godot_mcp/utils/script_utils.gd.uid
res://addons/godot_mcp/websocket_server.gd

--- res://addons/godot_mcp/websocket_server.gd ---
@tool
class_name MCPWebSocketServer
extends Node

signal client_connected(id)
signal client_disconnected(id)
signal command_received(client_id, command)

# Custom implementation of WebSocket server using TCP + WebSocketPeer
var tcp_server = TCPServer.new()
var peers = {}
var pending_peers = []
var _port = 9080
var refuse_new_connections = false
var handshake_timeout = 3000 # ms

class PendingPeer:
	var tcp: StreamPeerTCP
	var connection: StreamPeer
	var ws: WebSocketPeer = null
	var connect_time: int
	
	func _init(p_tcp: StreamPeerTCP):
		tcp = p_tcp
		connection = tcp
		connect_time = Time.get_ticks_msec()

func _ready():
	set_process(false)

func _process(_delta):
	poll()

func is_server_active() -> bool:
	return tcp_server.is_listening()

func start_server() -> int:
	if is_server_active():
		return ERR_ALREADY_IN_USE
	
	var err = tcp_server.listen(_port)
	if err == OK:
		set_process(true)
		print("MCP WebSocket server started on port %d" % _port)
	else:
		print("Failed to start MCP WebSocket server: %d" % err)
	
	return err

func stop_server() -> void:
	if is_server_active():
		tcp_server.stop()
		
		# Close all client connections
		for client_id in peers.keys():
			peers[client_id].close()
		peers.clear()
		pending_peers.clear()
		
		set_process(false)
		print("MCP WebSocket server stopped")

func poll() -> void:
	if not tcp_server.is_listening():
		return
		
	# Accept any incoming TCP connections
	while not refuse_new_connections and tcp_server.is_connection_available():
		var conn = tcp_server.take_connection()
		assert(conn != null)
		print("New TCP connection, starting WebSocket handshake...")
		pending_peers.append(PendingPeer.new(conn))
	
	# Process pending connections (handshake)
	var to_remove := []
	for p in pending_peers:
		if not _connect_pending(p):
			if p.connect_time + handshake_timeout < Time.get_ticks_msec():
				# Timeout
				print("WebSocket handshake timed out")
				to_remove.append(p)
			continue # Still pending
		to_remove.append(p)
	for r in to_remove:
		pending_peers.erase(r)
	to_remove.clear()
	
	# Process connected peers
	for id in peers:
		var p: WebSocketPeer = peers[id]
		p.poll()
		
		var state = p.get_ready_state()
		if state == WebSocketPeer.STATE_CLOSING or state == WebSocketPeer.STATE_CLOSED:
			print("Client %d disconnected (state: %d)" % [id, state])
			emit_signal("client_disconnected", id)
			to_remove.append(id)
			continue
		
		# Process incoming messages
		while p.get_available_packet_count() > 0:
			var packet = p.get_packet()
			var text = packet.get_string_from_utf8()
			
			# Parse the JSON command
			var json = JSON.new()
			var parse_result = json.parse(text)
			
			if parse_result == OK:
				var command = json.get_data()
				print("Received command from client %d: %s" % [id, command])
				emit_signal("command_received", id, command)
			else:
				print("Error parsing JSON from client %d: %s at line %d" % 
					[id, json.get_error_message(), json.get_error_line()])
	
	# Remove disconnected clients
	for r in to_remove:
		peers.erase(r)

func _connect_pending(p: PendingPeer) -> bool:
	if p.ws != null:
		# Poll websocket client if doing handshake
		p.ws.poll()
		var state = p.ws.get_ready_state()
		
		if state == WebSocketPeer.STATE_OPEN:
			var id = randi() % (1 << 30) + 1 # Generate a random ID
			peers[id] = p.ws
			print("Client %d WebSocket connection established" % id)
			emit_signal("client_connected", id)
			return true # Success.
		elif state != WebSocketPeer.STATE_CONNECTING:
			print("WebSocket handshake failed, state: %d" % state)
			return true # Failure.
		return false # Still connecting.
	else:
		if p.tcp.get_status() != StreamPeerTCP.STATUS_CONNECTED:
			print("TCP connection lost during handshake")
			return true # TCP disconnected.
		else:
			# TCP is ready, create WS peer
			print("TCP connected, upgrading to WebSocket...")
			p.ws = WebSocketPeer.new()
			p.ws.accept_stream(p.tcp)
			return false # WebSocketPeer connection is pending.

func send_response(client_id: int, response: Dictionary) -> int:
	if not peers.has(client_id):
		print("Error: Client %d not found" % client_id)
		return ERR_DOES_NOT_EXIST
	
	var peer = peers[client_id]
	var json_text = JSON.stringify(response)
	
	if peer.get_ready_state() != WebSocketPeer.STATE_OPEN:
		print("Error: Client %d connection not open" % client_id)
		return ERR_UNAVAILABLE
	
	var result = peer.send_text(json_text)
	if result != OK:
		print("Error sending response to client %d: %d" % [client_id, result])
	
	return result

func set_port(new_port: int) -> void:
	if is_server_active():
		push_error("Cannot change port while server is active")
		return
	_port = new_port

func get_port() -> int:
	return _port

func get_client_count() -> int:
	return peers.size()
res://addons/godot_mcp/websocket_server.gd.uid
res://addons/httpserver/http_router.gd

--- res://addons/httpserver/http_router.gd ---
extends RefCounted
#class_name HttpRouter

## Horizon:
## My implementation doesn't use class_name to not flow global project classes.
## Feel free to change this while waiting namespacing or else.

## Route name /v1/login then a map with its methods and handlers:
## [&"/v1/login/": {Method.GET: _get_login}]
var routes: Dictionary[StringName, Dictionary]


func register_route(
	method: HTTPClient.Method,
	path: StringName,
	handler: Callable
) -> void:
	if routes.has(path):
		routes[path][method] = handler
	else:
		routes[path] = {method: handler}


func find_route_handler(method: HTTPClient.Method, path: StringName) -> Callable:
	if routes.has(path):
		return routes[path].get(method, Callable())
	return Callable()


func dispatch(method: HTTPClient.Method, path: StringName, payload: Variant) -> bool:
	var handler: Callable = find_route_handler(method, path)
	if handler.is_valid():
		handler.call(payload)
		return true
	return false
res://addons/httpserver/http_router.gd.uid
res://addons/httpserver/http_server.gd

--- res://addons/httpserver/http_server.gd ---
extends Node
#class_name HTTPServer


const HttpRouter = preload("res://addons/httpserver/http_router.gd")

var server: TCPServer
var router: HttpRouter

var current_connections: Array[StreamPeerTCP]
var time: float
var to_wait: float = 2.0


func _ready() -> void:
	server = TCPServer.new()
	router = HttpRouter.new()
	server.listen(8088, "127.0.0.1")


func _physics_process(delta: float) -> void:
	if server.is_connection_available():
		var connection: StreamPeerTCP = server.take_connection()
		handle_connection(connection)
		current_connections.append(connection)
	time += delta
	if time >= to_wait:
		for connection: StreamPeerTCP in current_connections:
			handle_connection(connection)
		time = 0.0


func handle_connection(connection: StreamPeerTCP) -> void:
	# Update status
	connection.poll()
	# Get and Check status
	var status: StreamPeerTCP.Status = connection.get_status()
	if status == StreamPeerTCP.Status.STATUS_NONE or status == StreamPeerTCP.Status.STATUS_ERROR:
		current_connections.erase(connection)
		return
	if status == StreamPeerTCP.Status.STATUS_CONNECTING:
		return

	var available_bytes: int = connection.get_available_bytes()
	if not available_bytes:
		return
	
	var as_string: String = connection.get_string(available_bytes)
	if not as_string.contains("\r\n\r\n"):
		return
	
	var headers: String = as_string.get_slice("\r\n\r\n", 0)
	if headers.is_empty() or headers == as_string:
		return
	
	var header: PackedStringArray = headers.get_slice("\r\n", 0).split(" ")
	var method: String = header[0]
	var path: String = header[1]
	
	var payload: Dictionary = JSON.parse_string(
		as_string.get_slice("\r\n\r\n", 1)
	)
	
	var handler: Callable = router.find_route_handler(
		HTTPClient.Method.METHOD_POST,
		path
	)
	
	var result: Dictionary
	if handler.is_valid():
		result = await handler.call(payload)
	else:
		result = {"error":"not_found555"}
	
	http_send(
		connection,
		result,
		HTTPClient.ResponseCode.RESPONSE_OK
	)
	connection.disconnect_from_host()
	current_connections.erase(connection)
	


func http_send(
	connection: StreamPeerTCP,
	payload: Dictionary,
	code: HTTPClient.ResponseCode
) -> void:
	## to_utf8_buffer for more support
	var body_buffer: PackedByteArray = JSON.stringify(payload).to_ascii_buffer()
	var headers: Dictionary = {
		"Content-Type": "application/json",
		"Content-Length": body_buffer.size(),
		"Connection": "close"
	}
	var header_to_buffer: String = "HTTP/1.1 %d OK\r\n" % code
	
	for header: String in headers:
		header_to_buffer += "%s: %s\r\n" % [header, str(headers[header])]
	header_to_buffer += "\r\n"
	
	# Header block
	connection.put_data(header_to_buffer.to_ascii_buffer())
	# Content/Body block
	connection.put_data(body_buffer)
	
	current_connections.erase(connection)
	connection.disconnect_from_host()
res://addons/httpserver/http_server.gd.uid
res://assets/audio/music/ekonia-main-theme.wav
res://assets/audio/music/ekonia-main-theme.wav.import
res://assets/fonts/Atkinson_Hyperlegible/AtkinsonHyperlegible-Bold.ttf
res://assets/fonts/Atkinson_Hyperlegible/AtkinsonHyperlegible-Bold.ttf.import
res://assets/fonts/Atkinson_Hyperlegible/AtkinsonHyperlegible-BoldItalic.ttf
res://assets/fonts/Atkinson_Hyperlegible/AtkinsonHyperlegible-BoldItalic.ttf.import
res://assets/fonts/Atkinson_Hyperlegible/AtkinsonHyperlegible-Italic.ttf
res://assets/fonts/Atkinson_Hyperlegible/AtkinsonHyperlegible-Italic.ttf.import
res://assets/fonts/Atkinson_Hyperlegible/AtkinsonHyperlegible-Regular.ttf
res://assets/fonts/Atkinson_Hyperlegible/AtkinsonHyperlegible-Regular.ttf.import
res://assets/fonts/Atkinson_Hyperlegible/OFL.txt
res://assets/fonts/Cinzel/Cinzel-VariableFont_wght.ttf
res://assets/fonts/Cinzel/Cinzel-VariableFont_wght.ttf.import
res://assets/fonts/Cinzel/OFL.txt
res://assets/fonts/Cinzel/README.txt
res://assets/fonts/Cinzel/static/Cinzel-Black.ttf
res://assets/fonts/Cinzel/static/Cinzel-Black.ttf.import
res://assets/fonts/Cinzel/static/Cinzel-Bold.ttf
res://assets/fonts/Cinzel/static/Cinzel-Bold.ttf.import
res://assets/fonts/Cinzel/static/Cinzel-ExtraBold.ttf
res://assets/fonts/Cinzel/static/Cinzel-ExtraBold.ttf.import
res://assets/fonts/Cinzel/static/Cinzel-Medium.ttf
res://assets/fonts/Cinzel/static/Cinzel-Medium.ttf.import
res://assets/fonts/Cinzel/static/Cinzel-Regular.ttf
res://assets/fonts/Cinzel/static/Cinzel-Regular.ttf.import
res://assets/fonts/Cinzel/static/Cinzel-SemiBold.ttf
res://assets/fonts/Cinzel/static/Cinzel-SemiBold.ttf.import
res://assets/fonts/kenney_mini.ttf
res://assets/fonts/kenney_mini.ttf.import
res://assets/fonts/kenney_mini_square.ttf
res://assets/fonts/kenney_mini_square.ttf.import
res://assets/node_icons/blue/icon_area_damage.png
res://assets/node_icons/blue/icon_area_damage.png.import
res://assets/node_icons/blue/icon_area_meteo.png
res://assets/node_icons/blue/icon_area_meteo.png.import
res://assets/node_icons/blue/icon_audio.png
res://assets/node_icons/blue/icon_audio.png.import
res://assets/node_icons/blue/icon_bag.png
res://assets/node_icons/blue/icon_bag.png.import
res://assets/node_icons/blue/icon_beetle.png
res://assets/node_icons/blue/icon_beetle.png.import
res://assets/node_icons/blue/icon_bell.png
res://assets/node_icons/blue/icon_bell.png.import
res://assets/node_icons/blue/icon_bone.png
res://assets/node_icons/blue/icon_bone.png.import
res://assets/node_icons/blue/icon_brain.png
res://assets/node_icons/blue/icon_brain.png.import
res://assets/node_icons/blue/icon_brush.png
res://assets/node_icons/blue/icon_brush.png.import
res://assets/node_icons/blue/icon_brush_2.png
res://assets/node_icons/blue/icon_brush_2.png.import
res://assets/node_icons/blue/icon_bucket.png
res://assets/node_icons/blue/icon_bucket.png.import
res://assets/node_icons/blue/icon_bullet.png
res://assets/node_icons/blue/icon_bullet.png.import
res://assets/node_icons/blue/icon_camera_grid.png
res://assets/node_icons/blue/icon_camera_grid.png.import
res://assets/node_icons/blue/icon_card.png
res://assets/node_icons/blue/icon_card.png.import
res://assets/node_icons/blue/icon_case.png
res://assets/node_icons/blue/icon_case.png.import
res://assets/node_icons/blue/icon_cell.png
res://assets/node_icons/blue/icon_cell.png.import
res://assets/node_icons/blue/icon_character.png
res://assets/node_icons/blue/icon_character.png.import
res://assets/node_icons/blue/icon_chest.png
res://assets/node_icons/blue/icon_chest.png.import
res://assets/node_icons/blue/icon_clear.png
res://assets/node_icons/blue/icon_clear.png.import
res://assets/node_icons/blue/icon_coin.png
res://assets/node_icons/blue/icon_coin.png.import
res://assets/node_icons/blue/icon_color_correction.png
res://assets/node_icons/blue/icon_color_correction.png.import
res://assets/node_icons/blue/icon_crate.png
res://assets/node_icons/blue/icon_crate.png.import
res://assets/node_icons/blue/icon_dialog.png
res://assets/node_icons/blue/icon_dialog.png.import
res://assets/node_icons/blue/icon_dice.png
res://assets/node_icons/blue/icon_dice.png.import
res://assets/node_icons/blue/icon_door.png
res://assets/node_icons/blue/icon_door.png.import
res://assets/node_icons/blue/icon_event.png
res://assets/node_icons/blue/icon_event.png.import
res://assets/node_icons/blue/icon_file.png
res://assets/node_icons/blue/icon_file.png.import
res://assets/node_icons/blue/icon_flag.png
res://assets/node_icons/blue/icon_flag.png.import
res://assets/node_icons/blue/icon_folder.png
res://assets/node_icons/blue/icon_folder.png.import
res://assets/node_icons/blue/icon_follow.png
res://assets/node_icons/blue/icon_follow.png.import
res://assets/node_icons/blue/icon_gear.png
res://assets/node_icons/blue/icon_gear.png.import
res://assets/node_icons/blue/icon_gem.png
res://assets/node_icons/blue/icon_gem.png.import
res://assets/node_icons/blue/icon_grid.png
res://assets/node_icons/blue/icon_grid.png.import
res://assets/node_icons/blue/icon_hammer.png
res://assets/node_icons/blue/icon_hammer.png.import
res://assets/node_icons/blue/icon_hat.png
res://assets/node_icons/blue/icon_hat.png.import
res://assets/node_icons/blue/icon_heart.png
res://assets/node_icons/blue/icon_heart.png.import
res://assets/node_icons/blue/icon_hitbox.png
res://assets/node_icons/blue/icon_hitbox.png.import
res://assets/node_icons/blue/icon_interrogation.png
res://assets/node_icons/blue/icon_interrogation.png.import
res://assets/node_icons/blue/icon_key.png
res://assets/node_icons/blue/icon_key.png.import
res://assets/node_icons/blue/icon_lever.png
res://assets/node_icons/blue/icon_lever.png.import
res://assets/node_icons/blue/icon_light_bulb.png
res://assets/node_icons/blue/icon_light_bulb.png.import
res://assets/node_icons/blue/icon_liquid.png
res://assets/node_icons/blue/icon_liquid.png.import
res://assets/node_icons/blue/icon_lock.png
res://assets/node_icons/blue/icon_lock.png.import
res://assets/node_icons/blue/icon_magnifier.png
res://assets/node_icons/blue/icon_magnifier.png.import
res://assets/node_icons/blue/icon_map.png
res://assets/node_icons/blue/icon_map.png.import
res://assets/node_icons/blue/icon_meat.png
res://assets/node_icons/blue/icon_meat.png.import
res://assets/node_icons/blue/icon_mirror.png
res://assets/node_icons/blue/icon_mirror.png.import
res://assets/node_icons/blue/icon_money_bag.png
res://assets/node_icons/blue/icon_money_bag.png.import
res://assets/node_icons/blue/icon_parchment.png
res://assets/node_icons/blue/icon_parchment.png.import
res://assets/node_icons/blue/icon_particle.png
res://assets/node_icons/blue/icon_particle.png.import
res://assets/node_icons/blue/icon_path_follow.png
res://assets/node_icons/blue/icon_path_follow.png.import
res://assets/node_icons/blue/icon_pot.png
res://assets/node_icons/blue/icon_pot.png.import
res://assets/node_icons/blue/icon_potion.png
res://assets/node_icons/blue/icon_potion.png.import
res://assets/node_icons/blue/icon_projectile.png
res://assets/node_icons/blue/icon_projectile.png.import
res://assets/node_icons/blue/icon_propeller.png
res://assets/node_icons/blue/icon_propeller.png.import
res://assets/node_icons/blue/icon_puzzle.png
res://assets/node_icons/blue/icon_puzzle.png.import
res://assets/node_icons/blue/icon_ring.png
res://assets/node_icons/blue/icon_ring.png.import
res://assets/node_icons/blue/icon_save.png
res://assets/node_icons/blue/icon_save.png.import
res://assets/node_icons/blue/icon_scene.png
res://assets/node_icons/blue/icon_scene.png.import
res://assets/node_icons/blue/icon_search.png
res://assets/node_icons/blue/icon_search.png.import
res://assets/node_icons/blue/icon_shield.png
res://assets/node_icons/blue/icon_shield.png.import
res://assets/node_icons/blue/icon_ship.png
res://assets/node_icons/blue/icon_ship.png.import
res://assets/node_icons/blue/icon_shovel.png
res://assets/node_icons/blue/icon_shovel.png.import
res://assets/node_icons/blue/icon_signal.png
res://assets/node_icons/blue/icon_signal.png.import
res://assets/node_icons/blue/icon_skull.png
res://assets/node_icons/blue/icon_skull.png.import
res://assets/node_icons/blue/icon_star.png
res://assets/node_icons/blue/icon_star.png.import
res://assets/node_icons/blue/icon_stat.png
res://assets/node_icons/blue/icon_stat.png.import
res://assets/node_icons/blue/icon_sword.png
res://assets/node_icons/blue/icon_sword.png.import
res://assets/node_icons/blue/icon_target.png
res://assets/node_icons/blue/icon_target.png.import
res://assets/node_icons/blue/icon_target_2.png
res://assets/node_icons/blue/icon_target_2.png.import
res://assets/node_icons/blue/icon_text_panel.png
res://assets/node_icons/blue/icon_text_panel.png.import
res://assets/node_icons/blue/icon_time.png
res://assets/node_icons/blue/icon_time.png.import
res://assets/node_icons/blue/icon_transition.png
res://assets/node_icons/blue/icon_transition.png.import
res://assets/node_icons/blue/icon_trap.png
res://assets/node_icons/blue/icon_trap.png.import
res://assets/node_icons/blue/icon_tree.png
res://assets/node_icons/blue/icon_tree.png.import
res://assets/node_icons/blue/icon_trophy.png
res://assets/node_icons/blue/icon_trophy.png.import
res://assets/node_icons/blue/icon_unlock.png
res://assets/node_icons/blue/icon_unlock.png.import
res://assets/node_icons/color/icon_destroyable.png
res://assets/node_icons/color/icon_destroyable.png.import
res://assets/node_icons/color/icon_heart.png
res://assets/node_icons/color/icon_heart.png.import
res://assets/node_icons/color/icon_map_colored.png
res://assets/node_icons/color/icon_map_colored.png.import
res://assets/node_icons/color/icon_meteo.png
res://assets/node_icons/color/icon_meteo.png.import
res://assets/node_icons/color/icon_teleporter.png
res://assets/node_icons/color/icon_teleporter.png.import
res://assets/node_icons/color/icon_weapon.png
res://assets/node_icons/color/icon_weapon.png.import
res://assets/node_icons/green/icon_area_damage.png
res://assets/node_icons/green/icon_area_damage.png.import
res://assets/node_icons/green/icon_area_meteo.png
res://assets/node_icons/green/icon_area_meteo.png.import
res://assets/node_icons/green/icon_audio.png
res://assets/node_icons/green/icon_audio.png.import
res://assets/node_icons/green/icon_bag.png
res://assets/node_icons/green/icon_bag.png.import
res://assets/node_icons/green/icon_beetle.png
res://assets/node_icons/green/icon_beetle.png.import
res://assets/node_icons/green/icon_bell.png
res://assets/node_icons/green/icon_bell.png.import
res://assets/node_icons/green/icon_bone.png
res://assets/node_icons/green/icon_bone.png.import
res://assets/node_icons/green/icon_brain.png
res://assets/node_icons/green/icon_brain.png.import
res://assets/node_icons/green/icon_brush.png
res://assets/node_icons/green/icon_brush.png.import
res://assets/node_icons/green/icon_brush_2.png
res://assets/node_icons/green/icon_brush_2.png.import
res://assets/node_icons/green/icon_bucket.png
res://assets/node_icons/green/icon_bucket.png.import
res://assets/node_icons/green/icon_bullet.png
res://assets/node_icons/green/icon_bullet.png.import
res://assets/node_icons/green/icon_camera_grid.png
res://assets/node_icons/green/icon_camera_grid.png.import
res://assets/node_icons/green/icon_card.png
res://assets/node_icons/green/icon_card.png.import
res://assets/node_icons/green/icon_case.png
res://assets/node_icons/green/icon_case.png.import
res://assets/node_icons/green/icon_cell.png
res://assets/node_icons/green/icon_cell.png.import
res://assets/node_icons/green/icon_character.png
res://assets/node_icons/green/icon_character.png.import
res://assets/node_icons/green/icon_chest.png
res://assets/node_icons/green/icon_chest.png.import
res://assets/node_icons/green/icon_clear.png
res://assets/node_icons/green/icon_clear.png.import
res://assets/node_icons/green/icon_coin.png
res://assets/node_icons/green/icon_coin.png.import
res://assets/node_icons/green/icon_color_correction.png
res://assets/node_icons/green/icon_color_correction.png.import
res://assets/node_icons/green/icon_crate.png
res://assets/node_icons/green/icon_crate.png.import
res://assets/node_icons/green/icon_dialog.png
res://assets/node_icons/green/icon_dialog.png.import
res://assets/node_icons/green/icon_dice.png
res://assets/node_icons/green/icon_dice.png.import
res://assets/node_icons/green/icon_door.png
res://assets/node_icons/green/icon_door.png.import
res://assets/node_icons/green/icon_event.png
res://assets/node_icons/green/icon_event.png.import
res://assets/node_icons/green/icon_file.png
res://assets/node_icons/green/icon_file.png.import
res://assets/node_icons/green/icon_flag.png
res://assets/node_icons/green/icon_flag.png.import
res://assets/node_icons/green/icon_folder.png
res://assets/node_icons/green/icon_folder.png.import
res://assets/node_icons/green/icon_follow.png
res://assets/node_icons/green/icon_follow.png.import
res://assets/node_icons/green/icon_gear.png
res://assets/node_icons/green/icon_gear.png.import
res://assets/node_icons/green/icon_gem.png
res://assets/node_icons/green/icon_gem.png.import
res://assets/node_icons/green/icon_grid.png
res://assets/node_icons/green/icon_grid.png.import
res://assets/node_icons/green/icon_hammer.png
res://assets/node_icons/green/icon_hammer.png.import
res://assets/node_icons/green/icon_hat.png
res://assets/node_icons/green/icon_hat.png.import
res://assets/node_icons/green/icon_heart.png
res://assets/node_icons/green/icon_heart.png.import
res://assets/node_icons/green/icon_hitbox.png
res://assets/node_icons/green/icon_hitbox.png.import
res://assets/node_icons/green/icon_interrogation.png
res://assets/node_icons/green/icon_interrogation.png.import
res://assets/node_icons/green/icon_key.png
res://assets/node_icons/green/icon_key.png.import
res://assets/node_icons/green/icon_lever.png
res://assets/node_icons/green/icon_lever.png.import
res://assets/node_icons/green/icon_light_bulb.png
res://assets/node_icons/green/icon_light_bulb.png.import
res://assets/node_icons/green/icon_liquid.png
res://assets/node_icons/green/icon_liquid.png.import
res://assets/node_icons/green/icon_lock.png
res://assets/node_icons/green/icon_lock.png.import
res://assets/node_icons/green/icon_magnifier.png
res://assets/node_icons/green/icon_magnifier.png.import
res://assets/node_icons/green/icon_meat.png
res://assets/node_icons/green/icon_meat.png.import
res://assets/node_icons/green/icon_mirror.png
res://assets/node_icons/green/icon_mirror.png.import
res://assets/node_icons/green/icon_money_bag.png
res://assets/node_icons/green/icon_money_bag.png.import
res://assets/node_icons/green/icon_parchment.png
res://assets/node_icons/green/icon_parchment.png.import
res://assets/node_icons/green/icon_particle.png
res://assets/node_icons/green/icon_particle.png.import
res://assets/node_icons/green/icon_path_follow.png
res://assets/node_icons/green/icon_path_follow.png.import
res://assets/node_icons/green/icon_pot.png
res://assets/node_icons/green/icon_pot.png.import
res://assets/node_icons/green/icon_potion.png
res://assets/node_icons/green/icon_potion.png.import
res://assets/node_icons/green/icon_projectile.png
res://assets/node_icons/green/icon_projectile.png.import
res://assets/node_icons/green/icon_propeller.png
res://assets/node_icons/green/icon_propeller.png.import
res://assets/node_icons/green/icon_puzzle.png
res://assets/node_icons/green/icon_puzzle.png.import
res://assets/node_icons/green/icon_ring.png
res://assets/node_icons/green/icon_ring.png.import
res://assets/node_icons/green/icon_save.png
res://assets/node_icons/green/icon_save.png.import
res://assets/node_icons/green/icon_scene.png
res://assets/node_icons/green/icon_scene.png.import
res://assets/node_icons/green/icon_search.png
res://assets/node_icons/green/icon_search.png.import
res://assets/node_icons/green/icon_shield.png
res://assets/node_icons/green/icon_shield.png.import
res://assets/node_icons/green/icon_ship.png
res://assets/node_icons/green/icon_ship.png.import
res://assets/node_icons/green/icon_shovel.png
res://assets/node_icons/green/icon_shovel.png.import
res://assets/node_icons/green/icon_signal.png
res://assets/node_icons/green/icon_signal.png.import
res://assets/node_icons/green/icon_skull.png
res://assets/node_icons/green/icon_skull.png.import
res://assets/node_icons/green/icon_star.png
res://assets/node_icons/green/icon_star.png.import
res://assets/node_icons/green/icon_stat.png
res://assets/node_icons/green/icon_stat.png.import
res://assets/node_icons/green/icon_sword.png
res://assets/node_icons/green/icon_sword.png.import
res://assets/node_icons/green/icon_target.png
res://assets/node_icons/green/icon_target.png.import
res://assets/node_icons/green/icon_target_2.png
res://assets/node_icons/green/icon_target_2.png.import
res://assets/node_icons/green/icon_text_panel.png
res://assets/node_icons/green/icon_text_panel.png.import
res://assets/node_icons/green/icon_time.png
res://assets/node_icons/green/icon_time.png.import
res://assets/node_icons/green/icon_transition.png
res://assets/node_icons/green/icon_transition.png.import
res://assets/node_icons/green/icon_trap.png
res://assets/node_icons/green/icon_trap.png.import
res://assets/node_icons/green/icon_tree.png
res://assets/node_icons/green/icon_tree.png.import
res://assets/node_icons/green/icon_trophy.png
res://assets/node_icons/green/icon_trophy.png.import
res://assets/node_icons/green/icon_unlock.png
res://assets/node_icons/green/icon_unlock.png.import
res://assets/node_icons/info.txt
res://assets/project_icon/icon128x.png
res://assets/project_icon/icon128x.png.import
res://assets/project_icon/icon_svg.svg
res://assets/project_icon/icon_svg.svg.import
res://castle_blueprint_layout.png
res://castle_blueprint_layout.png.import
res://castle_blueprint_v1.png
res://castle_blueprint_v1.png.import
res://castle_blueprint_v2.png
res://castle_blueprint_v2.png.import
res://Cliffwald Online_Gdd.txt
res://complete_codebase_audit.txt
res://data/config/client_config.cfg
res://data/config/ekonia/client.cfg
res://data/config/ekonia/README.md
res://data/config/gateway_config.cfg
res://data/config/master_config.cfg
res://data/config/tls/certificate.crt
res://data/config/tls/key.key
res://data/config/world_config.cfg
res://dev_tools/connect_mcp.py
res://dev_tools/connect_mcp_v2.py
res://dev_tools/deep_audit.py
res://dev_tools/generate_blueprint.py
res://dev_tools/generate_blueprint_v1.py
res://dev_tools/generate_blueprint_v2.py
res://dev_tools/generate_full_audit.py
res://dev_tools/generate_projectiles.py
res://dev_tools/generate_static_castle.py
res://dev_tools/generate_static_castle_v3.py
res://dev_tools/inspect_mvp.py
res://dev_tools/inspect_scenes.py
res://dev_tools/list_files.py
res://dev_tools/read_key_scripts.py
res://dev_tools/test_mcp_access.py
res://dev_tools/unificar_entregas.py
res://dev_tools/verify_replication.py
res://godot_bin/Godot_v4.4-stable_linux.x86_64
res://Godot_v4.5.1-stable_win64.exe
res://Godot_v4.5.1-stable_win64_console.exe
res://icon.svg
res://icon.svg.import
res://LICENSE
res://log.txt
res://project.godot
res://README.md
res://run_mmo.ps1
res://run_mmo.sh
res://server_audit.txt
res://source/client/autoload/client_state.gd

--- res://source/client/autoload/client_state.gd ---
extends Node
## Events Autoload (only for the client side)
## Should be removed on non-client exports.


# CORRECCIN: Usamos CharacterBody3D para compatibilidad con InstanceClient y evitar ciclos
signal local_player_ready(local_player: CharacterBody3D)

# CORRECCIN: Tipo base genrico
var local_player: CharacterBody3D

var stats: DataDict = DataDict.new()
var settings: DataDict = DataDict.new()
var quick_slots: DataDict = DataDict.new()


func _ready() -> void:
	# Suscripcin a estadsticas (se mantiene igual, es agnstico a 2D/3D)
	InstanceClient.subscribe(&"stats.get", func(data: Dictionary):
		stats.data.merge(data, true)
	)


class DataDict:
	signal data_changed(property: Variant, value: Variant)
	
	var data: Dictionary
	
	func _set(property: StringName, value: Variant) -> bool:
		if property == &"data":
			return false
		data[property] = value
		data_changed.emit(property, value)
		return true
	
	func set_key(key: Variant, value: Variant) -> void:
		data.set(key, value)
		data_changed.emit(key, value)
	
	func get_key(property: Variant, default: Variant = null) -> Variant:
		return data.get(property, default)
res://source/client/autoload/client_state.gd.uid
res://source/client/client_main.gd

--- res://source/client/client_main.gd ---
extends Node

func _ready() -> void:
	pass
res://source/client/client_main.gd.uid
res://source/client/client_main.tscn

--- res://source/client/client_main.tscn ---
[gd_scene load_steps=5 format=3 uid="uid://bmbm8el3rcejb"]

[ext_resource type="Script" uid="uid://bfybdk1kgy125" path="res://source/client/client_main.gd" id="1_hoyng"]
[ext_resource type="Script" uid="uid://siq7b6qqrjyq" path="res://source/client/network/world_client.gd" id="2_ey548"]
[ext_resource type="Script" uid="uid://df8q30x0onbwg" path="res://source/client/network/instance_manager.gd" id="3_s85jl"]
[ext_resource type="PackedScene" path="res://source/client/gateway/gateway.tscn" id="4_s85jl"]

[node name="ClientMain" type="Node"]
script = ExtResource("1_hoyng")

[node name="WorldClient" type="Node" parent="."]
script = ExtResource("2_ey548")

[node name="InstanceManager" type="Node" parent="WorldClient"]
script = ExtResource("3_s85jl")

[node name="Gateway" parent="." node_paths=PackedStringArray("world_server") instance=ExtResource("4_s85jl")]
world_server = NodePath("../WorldClient")
res://source/client/gateway/gateway.gd

--- res://source/client/gateway/gateway.gd ---
extends Control

# Helper classes
const CredentialsUtils = preload("res://source/common/utils/credentials_utils.gd")
const GatewayApi = preload("res://source/common/network/gateway_api.gd")

@export var world_server: WorldClient

var account_id: int
var account_name: String
var token: int = randi()

var current_world_id: int
var selected_house: StringName = &"Ignis"
var worlds: Dictionary

# UI references (nueva escena simplificada)
@onready var tabs: TabContainer = $Center/Panel/VBox/Tabs
@onready var login_user: LineEdit = $Center/Panel/VBox/Tabs/Login/LoginVBox/UserEdit
@onready var login_pass: LineEdit = $Center/Panel/VBox/Tabs/Login/LoginVBox/PassEdit
@onready var login_button: Button = $Center/Panel/VBox/Tabs/Login/LoginVBox/LoginButton
@onready var guest_button: Button = $Center/Panel/VBox/Tabs/Login/LoginVBox/GuestButton
@onready var create_user: LineEdit = $Center/Panel/VBox/Tabs/CreateAccount/CreateVBox/NewUserEdit
@onready var create_pass: LineEdit = $Center/Panel/VBox/Tabs/CreateAccount/CreateVBox/NewPassEdit
@onready var create_pass_repeat: LineEdit = $Center/Panel/VBox/Tabs/CreateAccount/CreateVBox/RepeatEdit
@onready var create_account_button: Button = $Center/Panel/VBox/Tabs/CreateAccount/CreateVBox/CreateButton
@onready var char_name: LineEdit = $Center/Panel/VBox/Tabs/CharacterCreation/CharVBox/NameEdit
@onready var house_options: OptionButton = $Center/Panel/VBox/Tabs/CharacterCreation/CharVBox/HouseOptions
@onready var create_char_button: Button = $Center/Panel/VBox/Tabs/CharacterCreation/CharVBox/CreateCharButton
@onready var back_button: Button = $Center/Panel/VBox/BackButton

var http_request: HTTPRequest


func _ready() -> void:
	http_request = HTTPRequest.new()
	add_child(http_request)

	# Conexin de botones
	login_button.pressed.connect(_on_login_login_button_pressed)
	guest_button.pressed.connect(_on_guest_button_pressed)
	create_account_button.pressed.connect(_on_create_account_button_pressed)
	create_char_button.pressed.connect(_on_create_character_button_pressed)
	back_button.pressed.connect(func():
		tabs.current_tab = 0
		back_button.hide()
	)
	back_button.hide()

	# Seleccin de casa (doctrina)
	house_options.clear()
	house_options.add_item("Ignis")
	house_options.add_item("Axiom")
	house_options.add_item("Vesper")
	house_options.select(0)
	house_options.item_selected.connect(func(idx: int):
		selected_house = house_options.get_item_text(idx)
	)


func do_request(
	method: HTTPClient.Method,
	path: String,
	payload: Dictionary,
) -> Dictionary:
	# Si ya hay una peticin en curso, espera a que termine (con timeout).
	var start_ms: int = Time.get_ticks_msec()
	while http_request.get_http_client_status() != HTTPClient.Status.STATUS_DISCONNECTED:
		if Time.get_ticks_msec() - start_ms > 10000:
			http_request.cancel_request()
			return {ok=false, error="timeout_wait_previous"}
		await get_tree().process_frame
	
	var custom_headers: PackedStringArray
	custom_headers.append("Content-Type: application/json")
	
	var error: Error = http_request.request(
		path,
		custom_headers,
		HTTPClient.METHOD_POST,
		JSON.stringify(payload)
	)

	if error != OK:
		push_error("An error occurred in the HTTP request.")
		return {ok=false, error="request_error", code=error}
	
	var args: Array = await http_request.request_completed
	var result: int = args[0]
	if result != OK:
		return {"error": "request_failed", "code": result}
	
	var response_code: int = args[1]
	var headers: PackedStringArray = args[2]
	var body: PackedByteArray = args[3]
	
	var data = JSON.parse_string(body.get_string_from_ascii())
	if data is Dictionary:
		return data
	return {"error": 1}


func populate_worlds(world_info: Dictionary) -> void:
	worlds = world_info


func fill_connection_info(_account_name: String, _account_id: int) -> void:
	account_name = _account_name
	account_id = _account_id


func _start_world_flow() -> void:
	if worlds.is_empty():
		return
	var world_id: int = worlds.keys()[0].to_int()
	current_world_id = world_id
	_load_characters(world_id)


func _load_characters(world_id: int) -> void:
	var d: Dictionary = await do_request(
		HTTPClient.Method.METHOD_POST,
		GatewayApi.world_characters(),
		{
			GatewayApi.KEY_WORLD_ID: world_id,
			GatewayApi.KEY_ACCOUNT_ID: account_id,
			GatewayApi.KEY_ACCOUNT_USERNAME: account_name,
			GatewayApi.KEY_TOKEN_ID: token
		}
	)
	if d.has("error"):
		return
	
	var chars: Dictionary = d.get("data", {})
	if chars.size() == 0:
		tabs.current_tab = 2 # CharacterCreation
		back_button.show()
	else:
		var first_id: int = chars.keys()[0].to_int()
		_enter_world(world_id, first_id)


func _enter_world(world_id: int, character_id: int) -> void:
	var d: Dictionary = await do_request(
		HTTPClient.Method.METHOD_POST,
		GatewayApi.world_enter(),
		{
			GatewayApi.KEY_TOKEN_ID: token,
			GatewayApi.KEY_ACCOUNT_USERNAME: account_name,
			GatewayApi.KEY_WORLD_ID: world_id,
			GatewayApi.KEY_CHAR_ID: character_id
		}
	)
	if d.has("error"):
		return
	var address: String = d.get("address", "")
	var port_val: int = int(d.get("port", 0))
	var token_val: String = str(d.get("token", ""))
	if address == "" or port_val == 0 or token_val == "":
		# Fallback a config local por si la respuesta est incompleta.
		var cfg := ConfigFile.new()
		if cfg.load("res://data/config/world_config.cfg") == OK:
			address = cfg.get_value("world-server", "bind_address", "127.0.0.1")
			port_val = int(cfg.get_value("world-server", "port", 8087))
			if token_val == "":
				token_val = "dev-token"
	world_server.connect_to_server(address, int(port_val), str(token_val))
	queue_free.call_deferred()


func _on_login_login_button_pressed() -> void:
	var username: String = login_user.text
	var password: String = login_pass.text
	
	login_button.disabled = true
	if (
		CredentialsUtils.validate_username(username).code != CredentialsUtils.UsernameError.OK
		or CredentialsUtils.validate_password(password).code != CredentialsUtils.UsernameError.OK
	):
		login_button.disabled = false
		return

	var d: Dictionary = await do_request(
		HTTPClient.Method.METHOD_POST,
		GatewayApi.login(),
		{
			"u": username,
			"p": password,
			GatewayApi.KEY_TOKEN_ID: token
		}
	)
	if d.has("error"):
		login_button.disabled = false
		return
	
	populate_worlds(d.get("w", {}))
	fill_connection_info(d["a"]["name"], d["a"]["id"])
	login_button.disabled = false
	_start_world_flow()


func _on_guest_button_pressed() -> void:
	var d: Dictionary = await do_request(
		HTTPClient.Method.METHOD_POST,
		GatewayApi.guest(),
		{GatewayApi.KEY_TOKEN_ID: token}
	)
	if d.has("error"):
		return
	
	fill_connection_info(d["a"]["name"], d["a"]["id"])
	populate_worlds(d.get("w", {}))
	_start_world_flow()


func _on_create_account_button_pressed() -> void:
	if create_pass.text != create_pass_repeat.text:
		return
	var result: Dictionary
	result = CredentialsUtils.validate_username(create_user.text)
	if result.code != CredentialsUtils.UsernameError.OK:
		return
	result = CredentialsUtils.validate_password(create_pass.text)
	if result.code != CredentialsUtils.UsernameError.OK:
		return
	
	var d: Dictionary = await do_request(
		HTTPClient.Method.METHOD_POST,
		GatewayApi.account_create(),
		{
			"u": create_user.text,
			"p": create_pass.text,
			GatewayApi.KEY_TOKEN_ID: token
		}
	)
	if d.has("error"):
		return
	fill_connection_info(d["a"]["name"], d["a"]["id"])
	populate_worlds(d.get("w", {}))
	_start_world_flow()


func _on_create_character_button_pressed() -> void:
	create_char_button.disabled = true
	back_button.hide()
	
	var result: Dictionary = CredentialsUtils.validate_username(char_name.text)
	if result.code != CredentialsUtils.UsernameError.OK:
		create_char_button.disabled = false
		back_button.show()
		return

	var d: Dictionary = await do_request(
		HTTPClient.Method.METHOD_POST,
		GatewayApi.world_create_char(),
		{
			GatewayApi.KEY_TOKEN_ID: token,
			"data": {
				"name": char_name.text,
				"house": selected_house,
			},
			GatewayApi.KEY_ACCOUNT_USERNAME: account_name,
			GatewayApi.KEY_WORLD_ID: current_world_id
		}
	)
	if d.has("error"):
		create_char_button.disabled = false
		tabs.current_tab = 2
		return
	
	world_server.connect_to_server(
		d["data"]["address"],
		d["data"]["port"],
		d["data"]["auth-token"]
	)
	queue_free.call_deferred()
res://source/client/gateway/gateway.gd.uid
res://source/client/gateway/gateway.tscn

--- res://source/client/gateway/gateway.tscn ---
[gd_scene load_steps=6 format=3 uid="uid://gateway_v3"]

[ext_resource type="Script" path="res://source/client/gateway/gateway.gd" id="1_script"]
[ext_resource type="Theme" path="res://source/client/ui/themes/theme_navy.tres" id="2_theme"]
[ext_resource type="FontFile" path="res://assets/fonts/Atkinson_Hyperlegible/AtkinsonHyperlegible-Bold.ttf" id="3_font"]
[ext_resource type="FontFile" path="res://assets/fonts/kenney_mini.ttf" id="4_font"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_Panel"]
bg_color = Color(0.09, 0.1, 0.14, 0.94)
corner_radius_top_left = 6
corner_radius_top_right = 6
corner_radius_bottom_left = 6
corner_radius_bottom_right = 6

[node name="Gateway" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Center" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Panel" type="PanelContainer" parent="Center"]
layout_mode = 2
custom_minimum_size = Vector2(520, 520)
theme_override_styles/panel = SubResource("StyleBoxFlat_Panel")

[node name="VBox" type="VBoxContainer" parent="Center/Panel"]
layout_mode = 2
theme_override_constants/separation = 18
alignment = 1
custom_minimum_size = Vector2(480, 480)

[node name="Title" type="Label" parent="Center/Panel/VBox"]
layout_mode = 2
theme_override_fonts/font = ExtResource("3_font")
theme_override_font_sizes/font_size = 22
text = "Gateway - Student Login"
horizontal_alignment = 1

[node name="Tabs" type="TabContainer" parent="Center/Panel/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="Login" type="Control" parent="Center/Panel/VBox/Tabs"]
layout_mode = 2

[node name="LoginVBox" type="VBoxContainer" parent="Center/Panel/VBox/Tabs/Login"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="UserLabel" type="Label" parent="Center/Panel/VBox/Tabs/Login/LoginVBox"]
layout_mode = 2
theme_override_fonts/font = ExtResource("4_font")
text = "Username"

[node name="UserEdit" type="LineEdit" parent="Center/Panel/VBox/Tabs/Login/LoginVBox"]
layout_mode = 2

[node name="PassLabel" type="Label" parent="Center/Panel/VBox/Tabs/Login/LoginVBox"]
layout_mode = 2
theme_override_fonts/font = ExtResource("4_font")
text = "Password"

[node name="PassEdit" type="LineEdit" parent="Center/Panel/VBox/Tabs/Login/LoginVBox"]
layout_mode = 2
secret = true

[node name="LoginButton" type="Button" parent="Center/Panel/VBox/Tabs/Login/LoginVBox"]
layout_mode = 2
text = "Login"

[node name="GuestButton" type="Button" parent="Center/Panel/VBox/Tabs/Login/LoginVBox"]
layout_mode = 2
text = "Guest Access"

[node name="CreateAccount" type="Control" parent="Center/Panel/VBox/Tabs"]
layout_mode = 2

[node name="CreateVBox" type="VBoxContainer" parent="Center/Panel/VBox/Tabs/CreateAccount"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="NewUserLabel" type="Label" parent="Center/Panel/VBox/Tabs/CreateAccount/CreateVBox"]
layout_mode = 2
theme_override_fonts/font = ExtResource("4_font")
text = "New Username"

[node name="NewUserEdit" type="LineEdit" parent="Center/Panel/VBox/Tabs/CreateAccount/CreateVBox"]
layout_mode = 2

[node name="NewPassLabel" type="Label" parent="Center/Panel/VBox/Tabs/CreateAccount/CreateVBox"]
layout_mode = 2
theme_override_fonts/font = ExtResource("4_font")
text = "Password"

[node name="NewPassEdit" type="LineEdit" parent="Center/Panel/VBox/Tabs/CreateAccount/CreateVBox"]
layout_mode = 2
secret = true

[node name="RepeatLabel" type="Label" parent="Center/Panel/VBox/Tabs/CreateAccount/CreateVBox"]
layout_mode = 2
theme_override_fonts/font = ExtResource("4_font")
text = "Repeat Password"

[node name="RepeatEdit" type="LineEdit" parent="Center/Panel/VBox/Tabs/CreateAccount/CreateVBox"]
layout_mode = 2
secret = true

[node name="CreateButton" type="Button" parent="Center/Panel/VBox/Tabs/CreateAccount/CreateVBox"]
layout_mode = 2
text = "Create Account"

[node name="CharacterCreation" type="Control" parent="Center/Panel/VBox/Tabs"]
layout_mode = 2

[node name="CharVBox" type="VBoxContainer" parent="Center/Panel/VBox/Tabs/CharacterCreation"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="NameLabel" type="Label" parent="Center/Panel/VBox/Tabs/CharacterCreation/CharVBox"]
layout_mode = 2
theme_override_fonts/font = ExtResource("4_font")
text = "Character name"

[node name="NameEdit" type="LineEdit" parent="Center/Panel/VBox/Tabs/CharacterCreation/CharVBox"]
layout_mode = 2

[node name="HouseLabel" type="Label" parent="Center/Panel/VBox/Tabs/CharacterCreation/CharVBox"]
layout_mode = 2
theme_override_fonts/font = ExtResource("4_font")
text = "Select House"

[node name="HouseOptions" type="OptionButton" parent="Center/Panel/VBox/Tabs/CharacterCreation/CharVBox"]
layout_mode = 2

[node name="CreateCharButton" type="Button" parent="Center/Panel/VBox/Tabs/CharacterCreation/CharVBox"]
layout_mode = 2
text = "Create Character"

[node name="BackButton" type="Button" parent="Center/Panel/VBox"]
layout_mode = 2
text = "Back"
visible = false
res://source/client/gateway/popup_panel.gd

--- res://source/client/gateway/popup_panel.gd ---
extends PanelContainer


@onready var title_label: Label = $VBoxContainer/TitleLabel
@onready var rich_text_label: RichTextLabel = $VBoxContainer/VBoxContainer/RichTextLabel
@onready var confirm_button: Button = $VBoxContainer/VBoxContainer/ConfirmButton


func display_waiting_popup(text: String = "Waiting ...") -> void:
	title_label.text = "Waiting"
	confirm_button.hide()
	rich_text_label.text = text
	show()


func confirm_message(message: String) -> void:
	title_label.text = "Please Confirm"
	rich_text_label.text = message
	confirm_button.show()
	show()
	await confirm_button.pressed
	hide()
res://source/client/gateway/popup_panel.gd.uid
res://source/client/local_player/gesture_manager.gd

--- res://source/client/local_player/gesture_manager.gd ---
class_name GestureManager
extends Node

# --- CONFIGURACIN ---
signal spell_cast(gesture_id: StringName, direction: Vector3)

# 0.65 es muy tolerante. Permite lneas chuecas y crculos ovalados.
# Si sientes que confunde gestos, bjalo a 0.5.
const MATCH_THRESHOLD := 0.65 
const RESAMPLE_POINTS := 64
const SIZE_BOX := 250.0 

# --- VARIABLES INTERNAS ---
var recording: bool = false
var points: PackedVector2Array = []
var min_distance_sqr: float = 20.0 # Filtro de sensibilidad mnimo
var line: Line2D
var line_layer: CanvasLayer
var templates: Dictionary[StringName, PackedVector2Array] = {}

func _ready() -> void:
	_setup_visuals()
	_build_templates()

func _setup_visuals() -> void:
	line_layer = CanvasLayer.new()
	line_layer.name = "GestureLayer"
	add_child(line_layer)
	
	line = Line2D.new()
	line.width = 5.0
	line.default_color = Color(0.2, 0.8, 1.0, 0.8)
	line.begin_cap_mode = Line2D.LINE_CAP_ROUND
	line.end_cap_mode = Line2D.LINE_CAP_ROUND
	line.antialiased = true
	line_layer.add_child(line)
	line.hide()

func _input(event: InputEvent) -> void:
	if event.is_action_pressed("cast_spell"):
		recording = true
		points.clear()
		var mouse_pos = get_viewport().get_mouse_position()
		points.append(mouse_pos)
		_update_line()
		Input.set_mouse_mode(Input.MOUSE_MODE_CONFINED)
		
	elif event.is_action_released("cast_spell"):
		recording = false
		_update_line(true)
		Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
		
		# Filtro: Ignorar clics sin movimiento real
		if points.size() > 5 and _path_length(points) > 50.0:
			_process_gesture()
		
	elif recording and event is InputEventMouseMotion:
		var pos = event.position
		if points.is_empty() or pos.distance_squared_to(points[-1]) > min_distance_sqr:
			points.append(pos)
			_update_line()

func _update_line(clear_and_hide: bool = false) -> void:
	if not line: return
	if clear_and_hide:
		line.visible = false
		line.clear_points()
	else:
		line.visible = true
		line.points = points

func _process_gesture() -> void:
	# 1. Normalizar dibujo del jugador
	var candidate = _normalize_pipeline(points)
	
	# 2. Reconocer con tolerancia bidireccional
	var result = _recognize(candidate)
	
	# 3. Limpiar ID (quitar sufijos de permutacin como #0, #1)
	var final_id = result.id.split("#")[0]
	var score = result.score
	
	print("Input: %s (Raw: %s) | Error: %.3f" % [final_id, result.id, score])
	
	if final_id != "" and score < MATCH_THRESHOLD:
		var cam = get_viewport().get_camera_3d()
		var aim_dir = -cam.global_transform.basis.z if cam else Vector3.FORWARD
		spell_cast.emit(final_id, aim_dir)
		print(" HECHIZO: ", final_id)
	else:
		print(" Gesto no claro")

# ---------- LGICA DE RECONOCIMIENTO (CORE) ----------

func _recognize(candidate: PackedVector2Array) -> Dictionary:
	var best_dist = INF
	var best_id = &""
	
	# Crear versin invertida para que no importe si dibuja horario/antihorario
	var candidate_reversed = candidate.duplicate()
	candidate_reversed.reverse()
	
	for id in templates:
		var template_pts = templates[id]
		
		var d1 = _path_distance(candidate, template_pts)
		var d2 = _path_distance(candidate_reversed, template_pts)
		var dist = min(d1, d2)
		
		if dist < best_dist:
			best_dist = dist
			best_id = id
			
	var avg_dist = best_dist / SIZE_BOX
	return {"id": best_id, "score": avg_dist}

func _build_templates() -> void:
	templates.clear()
	
	# 1. KINETIC PULSE (Universal) - Horizontal Line
	# GDD: "Simple Horizontal Line ()"
	var line_pts = PackedVector2Array([Vector2(0, 0), Vector2(10, 0), Vector2(20, 0), Vector2(30, 0), Vector2(40, 0), Vector2(50, 0)])
	templates[&"kinetic_pulse"] = _normalize_pipeline(line_pts)
	
	# 2. AEGIS (Vesper/Universal) - Circle
	# Geometric Shape 1
	templates[&"aegis"] = _normalize_pipeline(_regular_polygon_points(32, 100.0, -PI/2))
	
	# 3. PYROCLASM (Ignis) - Triangle
	# Geometric Shape 2
	var raw_tri = _regular_polygon_points(3, 100.0, -PI/2)
	_add_permutations_for_shape(&"pyroclasm", raw_tri, 3)
	
	# 4. STASIS (Axiom) - Square
	# Geometric Shape 3
	var raw_sq = _regular_polygon_points(4, 100.0, -PI/4)
	_add_permutations_for_shape(&"stasis", raw_sq, 4)
# Crea copias rotando el punto de inicio para que no importe dnde empieza el jugador
func _add_permutations_for_shape(base_name: StringName, raw_pts: PackedVector2Array, sides: int) -> void:
	var pts = _resample(raw_pts, RESAMPLE_POINTS)
	var step = int(pts.size() / float(sides))
	
	for i in range(sides):
		var rotated = pts.duplicate()
		# Mover el inicio del array 'step' veces
		for k in range(step * i):
			# rotated.append(rotated.pop_front()) # pop_front not supported on PackedVector2Array
			var first = rotated[0]
			rotated.remove_at(0)
			rotated.append(first)
		
		templates[StringName(base_name + "#" + str(i))] = _normalize_pipeline(rotated)

# ---------- PIPELINE MATEMTICO ----------

func _normalize_pipeline(raw_pts: PackedVector2Array) -> PackedVector2Array:
	var pts = _resample(raw_pts, RESAMPLE_POINTS)
	pts = _rotate_to_zero(pts)
	pts = _scale_to_square(pts, SIZE_BOX) # Este paso arregla los valos
	pts = _translate_to_origin(pts)
	return pts

# Algoritmo de resampleo corregido (sin bug de insercin)
func _resample(pts: PackedVector2Array, n: int) -> PackedVector2Array:
	var I = _path_length(pts) / float(n - 1)
	var D = 0.0
	var new_pts = PackedVector2Array()
	new_pts.append(pts[0])
	var i = 1
	while i < pts.size():
		var d = pts[i-1].distance_to(pts[i])
		if (D + d) >= I:
			var t = (I - D) / d
			var q = pts[i-1].lerp(pts[i], t)
			new_pts.append(q)
			pts.insert(i, q) # Insertamos para mantener la continuidad correcta
			D = 0.0
			i += 1
		else:
			D += d
			i += 1
	while new_pts.size() < n:
		new_pts.append(pts[-1])
	return new_pts

func _rotate_to_zero(pts: PackedVector2Array) -> PackedVector2Array:
	var c = _centroid(pts)
	var angle = atan2(c.y - pts[0].y, c.x - pts[0].x)
	return _rotate_by(pts, -angle, c)

func _rotate_by(pts: PackedVector2Array, radians: float, pivot: Vector2) -> PackedVector2Array:
	var new_pts = PackedVector2Array()
	var t = Transform2D().translated(pivot).rotated(radians).translated(-pivot)
	return t * pts

func _scale_to_square(pts: PackedVector2Array, size: float) -> PackedVector2Array:
	var min_v = Vector2(INF, INF)
	var max_v = Vector2(-INF, -INF)
	for p in pts:
		min_v = min_v.min(p)
		max_v = max_v.max(p)
	var w = max_v.x - min_v.x
	var h = max_v.y - min_v.y
	var new_pts = PackedVector2Array()
	for p in pts:
		new_pts.append(Vector2(
			(p.x - min_v.x) * (size / max(w, 0.01)),
			(p.y - min_v.y) * (size / max(h, 0.01))
		))
	return new_pts

func _translate_to_origin(pts: PackedVector2Array) -> PackedVector2Array:
	var c = _centroid(pts)
	var new_pts = PackedVector2Array()
	for p in pts: new_pts.append(p - c)
	return new_pts

func _centroid(pts: PackedVector2Array) -> Vector2:
	var sum = Vector2.ZERO
	for p in pts: sum += p
	return sum / pts.size()

func _path_length(pts: PackedVector2Array) -> float:
	var d = 0.0
	for i in range(1, pts.size()): d += pts[i-1].distance_to(pts[i])
	return d

func _path_distance(a: PackedVector2Array, b: PackedVector2Array) -> float:
	var d = 0.0
	var n = min(a.size(), b.size())
	for i in range(n): d += a[i].distance_to(b[i])
	return d / n

func _regular_polygon_points(sides: int, radius: float, start_angle: float = 0.0) -> PackedVector2Array:
	var pts = PackedVector2Array()
	for i in range(sides):
		var angle = start_angle + (TAU * i / sides)
		pts.append(Vector2(cos(angle), sin(angle)) * radius)
	pts.append(pts[0])
	return pts
res://source/client/local_player/gesture_manager.gd.uid
res://source/client/local_player/mouse_component.gd

--- res://source/client/local_player/mouse_component.gd ---
class_name MouseComponent
extends Node3D


var mouse_ingame: bool = true
var window_focus: bool = true


func _notification(what: int) -> void:
	if what == NOTIFICATION_WM_MOUSE_ENTER:
		mouse_ingame = true
	elif what == NOTIFICATION_WM_MOUSE_EXIT:
		mouse_ingame = false
	if what == NOTIFICATION_WM_WINDOW_FOCUS_IN:
		window_focus = true
	elif what == NOTIFICATION_WM_WINDOW_FOCUS_OUT:
		window_focus = false


func _process(_delta: float) -> void:
	if mouse_ingame and window_focus:
		pass
res://source/client/local_player/mouse_component.gd.uid
res://source/client/local_player/player_3d.gd.uid
res://source/client/local_player/spell_projectile.gd

--- res://source/client/local_player/spell_projectile.gd ---
extends Node3D

@export var speed: float = 18.0
@export var lifetime: float = 2.0
var direction: Vector3 = Vector3.ZERO
enum Shape { TRIANGLE, CIRCLE, SQUARE }
@export var shape_type: Shape = Shape.CIRCLE

func _ready() -> void:
	_configure_mesh()
	set_physics_process(true)
	await get_tree().create_timer(lifetime).timeout
	queue_free()

func _physics_process(delta: float) -> void:
	if direction != Vector3.ZERO:
		global_translate(direction.normalized() * speed * delta)


func set_shape_from_gesture(gesture_id: String) -> void:
	match gesture_id:
		"triangle":
			shape_type = Shape.TRIANGLE
		"square":
			shape_type = Shape.SQUARE
		_:
			shape_type = Shape.CIRCLE
	_configure_mesh()


func _configure_mesh() -> void:
	var mesh_instance: MeshInstance3D = $MeshInstance3D
	if not mesh_instance:
		return
	
	var new_mesh: Mesh
	
	match shape_type:
		Shape.TRIANGLE:
			# Triangle gesture -> Cone
			var cone = CylinderMesh.new()
			cone.top_radius = 0.0 # Cone tip
			cone.bottom_radius = 0.35
			cone.height = 0.8
			cone.radial_segments = 16
			new_mesh = cone
			_set_color(Color(1, 0.6, 0.2))
		Shape.SQUARE:
			# Square gesture -> Cube
			var box = BoxMesh.new()
			box.size = Vector3(0.6, 0.6, 0.6)
			new_mesh = box
			_set_color(Color(0.2, 0.8, 1))
		Shape.CIRCLE:
			# Circle gesture -> Sphere
			var sphere = SphereMesh.new()
			sphere.radius = 0.4
			sphere.height = 0.8
			sphere.radial_segments = 16
			sphere.rings = 8
			new_mesh = sphere
			_set_color(Color(0.8, 0.2, 1))
			
	mesh_instance.mesh = new_mesh

func _set_color(col: Color) -> void:
	var mesh_instance: MeshInstance3D = $MeshInstance3D
	var mat = StandardMaterial3D.new()
	mat.albedo_color = col
	mat.emission_enabled = true
	mat.emission = col
	mat.emission_energy_multiplier = 2.0
	mesh_instance.material_override = mat
res://source/client/local_player/spell_projectile.gd.uid
res://source/client/local_player/spell_projectile.tscn

--- res://source/client/local_player/spell_projectile.tscn ---
[gd_scene load_steps=3 format=3]

[ext_resource type="Script" path="res://source/client/local_player/spell_projectile.gd" id="1_script"]

[node name="SpellProjectile" type="Node3D"]
script = ExtResource("1_script")

[node name="MeshInstance3D" type="MeshInstance3D" parent="."]
mesh = null
res://source/client/network/instance_client.gd

--- res://source/client/network/instance_client.gd ---
class_name InstanceClient
extends Node

# --- CONFIGURACIN ---
const LOCAL_PLAYER: PackedScene = preload("res://source/common/gameplay/characters/player/net_player.tscn")

static var current: InstanceClient
static var local_player: Node

# Diccionario actualizado para guardar referencias 3D
var players_by_peer_id: Dictionary
var instance_map: Node

# Data Request System (Keep for inventory/stats)
static var _next_data_request_id: int
static var _pending_data_requests: Dictionary
static var _data_subscriptions: Dictionary

static func _static_init() -> void:
	subscribe(&"action.perform", func(data: Dictionary) -> void:
		pass # Combat logic stub
	)

func _ready() -> void:
	current = self
	players_by_peer_id = {}
	_pending_data_requests = {}
	_data_subscriptions = {}
	_next_data_request_id = 1

@rpc("any_peer", "call_remote", "reliable", 0)
func ready_to_enter_instance() -> void:
	print("InstanceClient: Map loaded. Requesting spawn via Spawner...")
	if instance_map:
		var spawner = instance_map.get_node_or_null("SimpleSpawner")
		if spawner:
			spawner.rpc_id(1, "request_spawn_server")
		else:
			printerr("SimpleSpawner not found in map!")

@rpc("authority", "call_remote", "reliable", 0)
func charge_new_instance(map_path: String, instance_name: String) -> void:
	print("InstanceClient: Loading map %s..." % map_path)
	
	if instance_map:
		instance_map.queue_free()
		
	var packed_scene = load(map_path)
	if packed_scene:
		instance_map = packed_scene.instantiate()
		instance_map.name = instance_name # Sync name with server for spawner paths
		add_child(instance_map)
		
		# Once map is loaded, tell server we are ready to receive spawns
		ready_to_enter_instance()
	else:
		printerr("Failed to load map: " + map_path)

# --- Data System ---

static func subscribe(type: StringName, handler: Callable) -> void:
	if _data_subscriptions.has(type):
		_data_subscriptions[type].append(handler)
	else:
		_data_subscriptions[type] = [handler]

static func unsubscribe(type: StringName, handler: Callable) -> void:
	if not _data_subscriptions.has(type):
		return
	_data_subscriptions[type].erase(handler)

func request_data(type: StringName, handler: Callable, args: Dictionary = {}) -> int:
	var request_id: int = _next_data_request_id
	_next_data_request_id += 1
	_pending_data_requests[request_id] = handler
	data_request.rpc_id(1, request_id, type, args)
	return request_id

func cancel_request_data(request_id: int) -> bool:
	return _pending_data_requests.erase(request_id)

@rpc("any_peer", "call_remote", "reliable", 1)
func data_request(_request_id: int, _type: StringName, _args: Dictionary) -> void:
	pass

@rpc("authority", "call_remote", "reliable", 1)
func data_response(request_id: int, type: StringName, data: Dictionary) -> void:
	var callable: Callable = _pending_data_requests.get(request_id, Callable())
	_pending_data_requests.erase(request_id)
	if callable.is_valid():
		callable.call(data)
	data_push(type, data)

@rpc("authority", "call_remote", "reliable", 1)
func data_push(type: StringName, data: Dictionary) -> void:
	for handler: Callable in _data_subscriptions.get(type, []):
		if handler.is_valid():
			handler.call(data)
		else:
			unsubscribe(type, handler)res://source/client/network/instance_client.gd.uid
res://source/client/network/instance_manager.gd

--- res://source/client/network/instance_manager.gd ---
class_name InstanceManagerClient
extends Node


signal instance_changed(instance: InstanceClient)

var current_ui: UI
var current_instance: InstanceClient


func _ready() -> void:
	pass


@rpc("authority", "call_remote", "reliable", 0)
func charge_new_instance(map_path: String, instance_id: String) -> void:
	var new_instance: InstanceClient = InstanceClient.new()
	new_instance.name = instance_id
	
	print("Loading new map: %s." % map_path)
	var map: Map = load(map_path).instantiate() as Map
	if not map:
		printerr("ERROR: Failed to instantiate map from %s" % map_path)
		return
	
	# HACK: Forzamos el nombre para asegurar sincronizacin con el servidor
	# El servidor usa el nombre del nodo raz de la escena (.tscn)
	if map_path.ends_with("cliffwald_world.tscn"):
		if map.name != "CliffwaldMap_Final":
			print("WARNING: Renaming map from '%s' to 'CliffwaldMap_Final' for sync." % map.name)
			map.name = "CliffwaldMap_Final"
	
	print("DEBUG: Map instantiated. Name: '%s'" % map.name)
	
	new_instance.instance_map = map
	
	if current_instance:
		if current_instance.local_player:
			current_instance.instance_map.remove_child(current_instance.local_player)
			#current_instance.local_player.reparent(new_instance, false)
		current_instance.queue_free()
	current_instance = new_instance
	new_instance.add_child(map, true)
	add_child(new_instance, true)
	
	# Enviamos el ready solo cuando el mapa est en el rbol para que InstanceClient tenga instance_map vlido.
	var ready_state := {"sent": false}
	var send_ready := func():
		if ready_state["sent"]:
			return
		ready_state["sent"] = true
		# Prefer calling the RPC on the Manager itself if that is the intended flow,
		# OR keep calling it on new_instance if that matches the child node structure.
		# For now, we just add the definition below to fix the checksum.
		new_instance.ready_to_enter_instance.rpc_id(1)
		instance_changed.emit(new_instance)

	# Si el mapa ya estaba listo, disparamos de inmediato; si no, esperamos al signal.
	if map.is_node_ready():
		send_ready.call()
	else:
		map.ready.connect(send_ready, CONNECT_ONE_SHOT)
	
	# Watchdog: si no tenemos player local en breve, reenviamos el ready.
	call_deferred("_ensure_local_player_spawned", new_instance)
	
	# Charge different type of UI/HUD and clear old one,
	# for mini game / special instances that would require unique HUD ? 
	
	#if current_ui:
		#current_ui.queue_free()
	if not current_ui:
		current_ui = preload("res://source/client/ui/ui.tscn").instantiate()
		get_parent().add_sibling(current_ui)


@rpc("any_peer", "call_remote", "reliable", 0)
func ready_to_enter_instance() -> void:
	pass


func _ensure_local_player_spawned(instance: InstanceClient) -> void:
	# Revisa luego de un pequeo delay si se cre el jugador local; si no, reenva el ready.
	await get_tree().process_frame
	await get_tree().create_timer(1.0).timeout
	if instance != current_instance:
		return
	var my_id: int = multiplayer.get_unique_id()
	if instance.players_by_peer_id.has(my_id):
		return
	print("InstanceManager: re-enviando ready_to_enter_instance (jugador local no spawneado)")
	instance.ready_to_enter_instance.rpc_id(1)
	
res://source/client/network/instance_manager.gd.uid
res://source/client/network/world_client.gd

--- res://source/client/network/world_client.gd ---
class_name WorldClient
extends BaseMultiplayerEndpoint


signal connection_changed(connected_to_server: bool)
signal authentication_requested

var peer_id: int
var is_connected_to_server: bool = false:
	set(value):
		is_connected_to_server = value
		connection_changed.emit(value)

var authentication_token: String


func _ready() -> void:
	pass


func _connect_multiplayer_api_signals(api: SceneMultiplayer) -> void:
	api.connected_to_server.connect(_on_connection_succeeded)
	api.connection_failed.connect(_on_connection_failed)
	api.server_disconnected.connect(_on_server_disconnected)
	
	api.peer_authenticating.connect(_on_peer_authenticating)
	api.peer_authentication_failed.connect(_on_peer_authentication_failed)
	api.set_auth_callback(authentication_call)


func connect_to_server(
	_address: String,
	_port: int,
	_authentication_token: String
) -> void:
	authentication_token = _authentication_token
	var addr := _address
	var port := _port
	
	var cert_path := "res://data/config/tls/certificate.crt"
	var cfg := ConfigFile.new()
	if cfg.load("res://data/config/client_config.cfg") == OK:
		cert_path = cfg.get_value("gateway-client", "certificate_path", cert_path)

	if port <= 0 or addr == "":
		if cfg.load("res://data/config/world_config.cfg") == OK:
			addr = cfg.get_value("world-server", "bind_address", "127.0.0.1")
			port = int(cfg.get_value("world-server", "port", 8087))
	# ltimo guard: no intentes conectar con puerto invlido.
	if port <= 0:
		push_error("WorldClient: puerto invlido (%d)." % port)
		return

	var tls_options: TLSOptions = null
	if not cert_path.is_empty():
		var cert = load(cert_path)
		if cert:
			tls_options = TLSOptions.client_unsafe(cert)

	create(Role.CLIENT, addr, port, tls_options)


func close_connection() -> void:
	multiplayer.set_multiplayer_peer(null)
	peer.close()
	is_connected_to_server = false


func _on_connection_succeeded() -> void:
	print("Successfully connected to the server as %d!" % multiplayer.get_unique_id())
	peer_id = multiplayer.get_unique_id()
	is_connected_to_server = true
	if OS.has_feature("debug"):
		DisplayServer.window_set_title("Client - %d" % peer_id)


func _on_connection_failed() -> void:
	print("Failed to connect to the server.")
	close_connection()


func _on_server_disconnected() -> void:
	print("Server disconnected.")
	close_connection()
	get_tree().paused = true


func _on_peer_authenticating(_peer_id: int) -> void:
	print("Trying to authenticate to the server.")


func _on_peer_authentication_failed(_peer_id: int) -> void:
	print("Authentification to the server failed.")
	close_connection()


func authentication_call(_peer_id: int, data: PackedByteArray) -> void:
	print("Authentification call from server with data: \"%s\"." % data.get_string_from_ascii())
	multiplayer.send_auth(1, var_to_bytes(authentication_token))
	multiplayer.complete_auth(1)
res://source/client/network/world_client.gd.uid
res://source/client/ui/hud/health_bar/health_bar.gd

--- res://source/client/ui/hud/health_bar/health_bar.gd ---
extends Control

@onready var label: Label = $ProgressBar/Label
@onready var progress_bar: ProgressBar = $ProgressBar


func _ready() -> void:
	# CAMBIO: Escuchamos la seal esperando un NetPlayer (antes Player3D)
	ClientState.local_player_ready.connect(
		func(local_player: NetPlayer) -> void:
			# VERIFICACIN DE SEGURIDAD:
			var ability_system = local_player.get("ability_system_component")
			
			if ability_system:
				ability_system.attributes.connect_watcher(&"health", _on_health_changed)
				
				if is_instance_valid(Stat): 
					ability_system.attributes.connect_watcher(Stat.HEALTH_MAX, _on_max_health_changed)
			else:
				# MODO SEGURO (FASE 1):
				progress_bar.max_value = 100
				progress_bar.value = 100
				update_label()
	)


func _on_health_changed(new_health: float) -> void:
	progress_bar.value = new_health
	update_label()


func _on_max_health_changed(new_max_health: float) -> void:
	progress_bar.max_value = new_max_health
	update_label()


func update_label() -> void:
	label.text = "%d / %d" % [progress_bar.value, progress_bar.max_value]res://source/client/ui/hud/health_bar/health_bar.gd.uid
res://source/client/ui/hud/health_bar/health_bar.tscn

--- res://source/client/ui/hud/health_bar/health_bar.tscn ---
[gd_scene load_steps=4 format=3 uid="uid://rncsatpcsbm"]

[ext_resource type="Script" uid="uid://nls33odkod4v" path="res://source/client/ui/hud/health_bar/health_bar.gd" id="1_e3c27"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_veeea"]
bg_color = Color(0.215902, 0.215902, 0.215902, 0.203922)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.0646966, 0.0646965, 0.0646965, 1)
border_blend = true
corner_radius_top_left = 20
corner_radius_bottom_right = 20

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_24t0k"]
bg_color = Color(0.211098, 0.630774, 0.235796, 0.627451)
border_color = Color(0.0646966, 0.0646965, 0.0646965, 1)
border_blend = true
corner_radius_top_left = 20
corner_radius_bottom_right = 20

[node name="HealthBar" type="Control"]
layout_mode = 3
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 0
script = ExtResource("1_e3c27")

[node name="ProgressBar" type="ProgressBar" parent="."]
custom_minimum_size = Vector2(200, 15)
layout_mode = 1
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -100.0
offset_top = -35.0
offset_right = 100.0
offset_bottom = -20.0
grow_horizontal = 2
grow_vertical = 0
size_flags_horizontal = 4
size_flags_vertical = 4
theme_override_styles/background = SubResource("StyleBoxFlat_veeea")
theme_override_styles/fill = SubResource("StyleBoxFlat_24t0k")
step = 0.5
value = 100.0
allow_greater = true
show_percentage = false

[node name="Label" type="Label" parent="ProgressBar"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
text = "100 / 100"
horizontal_alignment = 1
res://source/client/ui/hud/hud.gd

--- res://source/client/ui/hud/hud.gd ---
class_name HUD
extends Control


@export var sub_menu: Control

var last_opened_interface: Control
var menus: Dictionary[StringName, Control]

@onready var menu_overlay: Control = $MenuOverlay
@onready var close_button: Button = $MenuOverlay/VBoxContainer/CloseButton


func _ready() -> void:
	for button: Button in $MenuOverlay/VBoxContainer.get_children():
		if button.text.containsn("CLOSE"):
			button.pressed.connect(_on_overlay_menu_close_button_pressed)
			continue
		button.pressed.connect(display_menu.bind(button.text.to_lower()))


func _on_overlay_menu_close_button_pressed() -> void:
	menu_overlay.hide()


func open_player_profile(player_id: int) -> void:
	display_menu(&"player_profile")
	menus[&"player_profile"].open_player_profile(player_id)


func _on_submenu_visiblity_changed(menu: Control) -> void:
	if menu.visible:
		hide()
	else:
		show()


func display_menu(menu_name: StringName) -> void:
	if not menus.has(menu_name):
		var path: String = "res://source/client/ui/menus/" + menu_name + "/" + menu_name + "_menu.tscn"
		if not ResourceLoader.exists(path):
			return
		var new_menu: Control = load(path).instantiate()
		new_menu.visibility_changed.connect(_on_submenu_visiblity_changed.bind(new_menu))
		sub_menu.add_child(new_menu)
		menus[menu_name] = new_menu
	menus[menu_name].show()


func _on_overlay_menu_button_pressed() -> void:
	var tween: Tween = create_tween()
	tween.tween_property(menu_overlay, ^"position:x", menu_overlay.position.x + menu_overlay.size.x, 0.0)
	tween.tween_callback(menu_overlay.show)
	tween.tween_property(menu_overlay, ^"position:x", 815.0, 0.3)


func _on_notification_button_pressed() -> void:
	pass # Replace with function body.
res://source/client/ui/hud/hud.gd.uid
res://source/client/ui/hud/hud.tscn

--- res://source/client/ui/hud/hud.tscn ---
[gd_scene load_steps=10 format=3 uid="uid://dqt8fnt1l33eu"]

[ext_resource type="Script" uid="uid://dshitaaapbs6x" path="res://source/client/ui/hud/hud.gd" id="1_rchld"]
[ext_resource type="PackedScene" uid="uid://rncsatpcsbm" path="res://source/client/ui/hud/health_bar/health_bar.tscn" id="2_klco5"]
[ext_resource type="PackedScene" uid="uid://cmv168mgurrlp" path="res://source/client/ui/menus/chat/chat_menu.tscn" id="2_xs74v"]
[ext_resource type="Script" uid="uid://pkprr0ll1y44" path="res://source/client/ui/hud/item_slots.gd" id="4_8qpw0"]
[ext_resource type="Script" uid="uid://brq8mxox5bclj" path="res://source/client/ui/hud/menu_overlay.gd" id="4_cx7qp"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_8qpw0"]
bg_color = Color(0.215902, 0.215902, 0.215902, 0.203922)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.0646966, 0.0646965, 0.0646965, 1)
border_blend = true
corner_radius_bottom_right = 20
corner_radius_bottom_left = 20

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_yow4d"]
bg_color = Color(0.421725, 0.311275, 0.859316, 0.627451)
border_color = Color(0.0646966, 0.0646965, 0.0646965, 1)
border_blend = true
corner_radius_bottom_right = 20
corner_radius_bottom_left = 20

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_popxh"]
bg_color = Color(0.215902, 0.215902, 0.215902, 0.203922)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.0646966, 0.0646965, 0.0646965, 1)
border_blend = true
corner_radius_top_right = 20
corner_radius_bottom_left = 20

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_ia7hj"]
bg_color = Color(0.0966887, 0.423688, 0.799925, 0.627451)
border_color = Color(0.0646966, 0.0646965, 0.0646965, 1)
border_blend = true
corner_radius_top_right = 20
corner_radius_bottom_left = 20

[node name="HUD" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_rchld")

[node name="Chat" parent="." instance=ExtResource("2_xs74v")]
layout_mode = 1
metadata/_edit_lock_ = true

[node name="ItemSlots" type="Control" parent="."]
layout_mode = 1
anchors_preset = 6
anchor_left = 1.0
anchor_top = 0.5
anchor_right = 1.0
anchor_bottom = 0.5
offset_top = -2.0
offset_bottom = 2.0
grow_horizontal = 0
grow_vertical = 2
script = ExtResource("4_8qpw0")
metadata/_edit_lock_ = true

[node name="VBoxContainer" type="VBoxContainer" parent="ItemSlots"]
layout_mode = 1
anchors_preset = 6
anchor_left = 1.0
anchor_top = 0.5
anchor_right = 1.0
anchor_bottom = 0.5
offset_left = -62.0
offset_top = -57.0
offset_right = -10.0
offset_bottom = 57.0
grow_horizontal = 0
grow_vertical = 2
theme_override_constants/separation = 10

[node name="ItemSlotButton1" type="Button" parent="ItemSlots/VBoxContainer"]
custom_minimum_size = Vector2(52, 52)
layout_mode = 2
theme_override_constants/icon_max_width = 64
text = "1"
icon_alignment = 1

[node name="ItemSlotButton2" type="Button" parent="ItemSlots/VBoxContainer"]
custom_minimum_size = Vector2(52, 52)
layout_mode = 2
theme_override_constants/icon_max_width = 64
text = "2
"
icon_alignment = 1

[node name="Resources" type="Control" parent="."]
layout_mode = 1
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -20.0
offset_top = -40.0
offset_right = 20.0
grow_horizontal = 2
grow_vertical = 0
metadata/_edit_lock_ = true

[node name="HealthBar" parent="Resources" instance=ExtResource("2_klco5")]
layout_mode = 1
metadata/_edit_lock_ = true

[node name="ExperienceBar" type="ProgressBar" parent="Resources"]
custom_minimum_size = Vector2(200, 5)
layout_mode = 1
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -146.0
offset_top = -16.0
offset_right = 154.0
offset_bottom = -11.0
grow_horizontal = 2
grow_vertical = 0
size_flags_horizontal = 4
size_flags_vertical = 4
theme_override_styles/background = SubResource("StyleBoxFlat_8qpw0")
theme_override_styles/fill = SubResource("StyleBoxFlat_yow4d")
step = 0.5
value = 66.0
allow_greater = true
show_percentage = false
metadata/_edit_group_ = true

[node name="ResourceBar" type="ProgressBar" parent="Resources"]
custom_minimum_size = Vector2(200, 5)
layout_mode = 1
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -100.0
offset_top = -51.0
offset_right = 100.0
offset_bottom = -36.0
grow_horizontal = 2
grow_vertical = 0
size_flags_horizontal = 4
size_flags_vertical = 4
theme_override_styles/background = SubResource("StyleBoxFlat_popxh")
theme_override_styles/fill = SubResource("StyleBoxFlat_ia7hj")
max_value = 40.0
step = 0.5
value = 40.0
allow_greater = true
show_percentage = false
metadata/_edit_group_ = true
metadata/_edit_lock_ = true

[node name="Label" type="Label" parent="Resources/ResourceBar"]
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -23.5
offset_top = -10.5
offset_right = 23.5
offset_bottom = 10.5
grow_horizontal = 2
grow_vertical = 2
text = "40/40"

[node name="ProgressBar" type="ProgressBar" parent="Resources"]
layout_mode = 0
offset_left = 122.0
offset_top = -11.0
offset_right = 172.0
offset_bottom = 21.0
show_percentage = false

[node name="ProgressBar2" type="ProgressBar" parent="Resources"]
layout_mode = 0
offset_left = -126.0
offset_top = -12.0
offset_right = -83.0
offset_bottom = 20.0
show_percentage = false

[node name="MenuButtons" type="Control" parent="."]
layout_mode = 1
anchors_preset = 1
anchor_left = 1.0
anchor_right = 1.0
grow_horizontal = 0

[node name="HBoxContainer" type="HBoxContainer" parent="MenuButtons"]
layout_mode = 1
anchors_preset = 1
anchor_left = 1.0
anchor_right = 1.0
offset_left = -118.0
offset_top = 10.0
offset_right = -10.0
offset_bottom = 62.0
grow_horizontal = 0
alignment = 2

[node name="NotificationButton" type="Button" parent="MenuButtons/HBoxContainer"]
custom_minimum_size = Vector2(52, 52)
layout_mode = 2
size_flags_horizontal = 0
size_flags_vertical = 0
text = "!"
metadata/_edit_lock_ = true

[node name="MenuButton" type="Button" parent="MenuButtons/HBoxContainer"]
custom_minimum_size = Vector2(52, 52)
layout_mode = 2
size_flags_horizontal = 0
size_flags_vertical = 0
text = "Menu"
metadata/_edit_lock_ = true

[node name="MenuOverlay" type="Control" parent="."]
visible = false
layout_mode = 1
anchors_preset = 11
anchor_left = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = -145.0
grow_horizontal = 0
grow_vertical = 2
script = ExtResource("4_cx7qp")
metadata/_edit_lock_ = true

[node name="ColorRect" type="ColorRect" parent="MenuOverlay"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.173, 0.173, 0.173, 0.65)

[node name="VBoxContainer" type="VBoxContainer" parent="MenuOverlay"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
alignment = 1

[node name="GuildButton" type="Button" parent="MenuOverlay/VBoxContainer"]
layout_mode = 2
text = "GUILD"

[node name="InventoryButton" type="Button" parent="MenuOverlay/VBoxContainer"]
layout_mode = 2
text = "INVENTORY"

[node name="SettingsButton" type="Button" parent="MenuOverlay/VBoxContainer"]
layout_mode = 2
text = "SETTINGS"

[node name="CloseButton" type="Button" parent="MenuOverlay/VBoxContainer"]
layout_mode = 2
text = "CLOSE"

[connection signal="pressed" from="MenuButtons/HBoxContainer/NotificationButton" to="." method="_on_notification_button_pressed"]
[connection signal="pressed" from="MenuButtons/HBoxContainer/MenuButton" to="." method="_on_overlay_menu_button_pressed"]
res://source/client/ui/hud/item_slots.gd

--- res://source/client/ui/hud/item_slots.gd ---
extends Control


var item_shortcuts: Array[Item]


func _ready() -> void:
	var i: int = 0
	for button: Button in $VBoxContainer.get_children():
		button.pressed.connect(_on_item_shortcut_pressed.bind(button, i))
		i += 1
	item_shortcuts.resize(i)
	item_shortcuts.fill(null)
	
	for slot_index: int in ClientState.quick_slots.data:
		add_item_to_shorcut(
			slot_index,
			ClientState.quick_slots.data.get(slot_index, null)
		)
	ClientState.quick_slots.data_changed.connect(add_item_to_shorcut)


func _on_item_shortcut_pressed(button: Button, index: int) -> void:
	var item: Item = item_shortcuts[index]
	if not item:
		return
	
	InstanceClient.current.request_data(
		&"item.equip",
		Callable(),
		{"id": item.get_meta(&"id", -1)}
	)


func add_item_to_shorcut(index: int, item: Item) -> void:
	if not index < item_shortcuts.size():
		return
	
	item_shortcuts[index] = item
	var button: Button = $VBoxContainer.get_child(index)
	button.icon = item.item_icon
	if button.icon:
		button.text = ""
	else:
		button.text = item.item_name
res://source/client/ui/hud/item_slots.gd.uid
res://source/client/ui/hud/menu_overlay.gd

--- res://source/client/ui/hud/menu_overlay.gd ---
extends Control
res://source/client/ui/hud/menu_overlay.gd.uid
res://source/client/ui/menus/chat/chat_menu.gd

--- res://source/client/ui/menus/chat/chat_menu.gd ---
extends Control


var channel_messages: Dictionary[int, PackedStringArray]
var current_channel: int
var fade_out_tween: Tween

@onready var peek_feed: VBoxContainer = $PeekFeed
@onready var full_feed: Control = $FullFeed

@onready var peek_feed_text_display: RichTextLabel = $PeekFeed/MessageDisplay
@onready var full_feed_text_display: RichTextLabel = $FullFeed/Control/HBoxContainer/ChatPanel/VBoxContainer2/RichTextLabel

@onready var peek_feed_message_edit: LineEdit = $PeekFeed/MessageEdit
@onready var full_feed_message_edit: LineEdit = $FullFeed/Control/HBoxContainer/ChatPanel/VBoxContainer2/HBoxContainer2/LineEdit

@onready var fade_out_timer: Timer = $PeekFeed/FadeOutTimer


func _ready() -> void:
	InstanceClient.subscribe(&"chat.message", _on_chat_message)
	
	peek_feed_message_edit.text_submitted.connect(_on_message_edit_text_submitted.bind(peek_feed_message_edit))
	full_feed_message_edit.text_submitted.connect(_on_message_edit_text_submitted.bind(full_feed_message_edit))
	
	peek_feed.show()
	full_feed.hide()


func _input(event: InputEvent) -> void:
	if event.is_action_pressed(&"chat"):
		if not full_feed.visible and not peek_feed_message_edit.has_focus():
			get_viewport().set_input_as_handled()
			accept_event()
			open_chat()


func open_chat() -> void:
	peek_feed.show()
	reset_view()
	peek_feed_message_edit.grab_focus()
	fade_out_timer.stop()


func _on_chat_message(message: Dictionary) -> void:
	if not message:
		return
	var text: String = message.get("text", "")
	var sender_name: String = message.get("name", "")
	var channel: int = message.get("channel", 0)
	var sender_id: int = message.get("id", 0)
	var color_name: String = "#33caff"
	var name_to_display: String
	if sender_id == 1:
		color_name = "#b6200f"
		name_to_display = sender_name
	else:
		name_to_display = "[url=%d]%s[/url]" % [sender_id, sender_name]
	var text_to_display: String = "[color=%s]%s:[/color] %s" % [color_name, name_to_display, text]
	
	peek_feed_text_display.append_text(text_to_display)
	peek_feed_text_display.newline()
	
	if full_feed.visible:
		if current_channel == channel:
			full_feed_text_display.append_text(text_to_display)
			full_feed_text_display.newline()
	else:
		reset_view()
		peek_feed_text_display.show()
		fade_out_timer.start()
	if channel_messages.has(channel):
		channel_messages[channel].append(text_to_display)
	else:
		channel_messages[channel] = PackedStringArray([text_to_display])


func _on_fade_out_timer_timeout() -> void:
	if peek_feed_message_edit.has_focus():
		fade_out_timer.start()
		return
	
	if fade_out_tween:
		fade_out_tween.kill()
	
	fade_out_tween = create_tween()
	fade_out_tween.tween_property(peek_feed, ^"modulate:a", 0, 0.3)


func _on_peek_feed_gui_input(event: InputEvent) -> void:
	if event is InputEventMouseMotion and peek_feed.modulate.a < 1.0:
		reset_view()
		fade_out_timer.start()
		return
	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
		peek_feed.hide()
		full_feed.show()
		full_feed_text_display.clear()
		full_feed_text_display.text = ""
		for message: String in channel_messages[0]:
			full_feed_text_display.append_text(message)
			full_feed_text_display.newline()


func _on_close_button_pressed() -> void:
	peek_feed.show()
	reset_view()
	full_feed.hide()


func reset_view() -> void:
	if fade_out_tween and fade_out_tween.is_running():
		fade_out_tween.kill()
	peek_feed.modulate.a = 1.0


func _on_rich_text_label_meta_clicked(meta: Variant) -> void:
	$"..".open_player_profile(str(meta).to_int())


func _on_message_edit_text_submitted(new_text: String, line_edit: LineEdit) -> void:
	line_edit.clear()
	line_edit.release_focus()
	
	if line_edit == peek_feed_message_edit:
		fade_out_timer.start()
	
	if new_text.is_empty():
		return
	
	new_text = new_text.strip_edges(true, true)
	new_text = new_text.substr(0, 120)
	
	if new_text.begins_with("/"):
		new_text = new_text.substr(1)
		var split: PackedStringArray = new_text.split(" ", false, 5)
		var cmd: String = split[0]
		var params: PackedStringArray = split
		
		InstanceClient.current.request_data(
			&"chat.command.exec",
			print_debug,
			{"cmd": cmd, "params": params}
		)
	else:
		InstanceClient.current.request_data(
			&"chat.message.send",
			Callable(), # ACK later
			{"text": new_text, "channel": current_channel}
		)
res://source/client/ui/menus/chat/chat_menu.gd.uid
res://source/client/ui/menus/chat/chat_menu.tscn

--- res://source/client/ui/menus/chat/chat_menu.tscn ---
[gd_scene load_steps=10 format=3 uid="uid://cmv168mgurrlp"]

[ext_resource type="Script" uid="uid://678x32kmrkb5" path="res://source/client/ui/menus/chat/chat_menu.gd" id="1_hxcw4"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_14md2"]
content_margin_left = 6.0
content_margin_top = 6.0
content_margin_right = 6.0
content_margin_bottom = 6.0
bg_color = Color(0.0767404, 0.139002, 0.199102, 0.834)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.156235, 0.282157, 0.307826, 1)
border_blend = true
corner_radius_top_left = 1
corner_radius_top_right = 1
corner_radius_bottom_right = 1
corner_radius_bottom_left = 1
shadow_color = Color(0, 0, 0, 0.22)
shadow_size = 6
shadow_offset = Vector2(0, 2)

[sub_resource type="Gradient" id="Gradient_s6uxj"]
colors = PackedColorArray(0, 0, 0, 0.678431, 0.137255, 0.137255, 0.137255, 0.529412)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_oenax"]
gradient = SubResource("Gradient_s6uxj")

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_ary8x"]
content_margin_left = 10.0
content_margin_top = 10.0
content_margin_right = 5.0
content_margin_bottom = 10.0
bg_color = Color(0.0980392, 0.0980392, 0.0980392, 0.105882)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_jlimx"]
bg_color = Color(0.2, 0.2, 0.2, 1)
border_width_top = 1
border_color = Color(0.2, 0.2, 0.2, 1)
expand_margin_left = 10.0
expand_margin_right = 15.0

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_jlimx"]
content_margin_top = 10.0
content_margin_bottom = 10.0

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_s6uxj"]
bg_color = Color(1, 0.0237725, 0.860263, 1)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_oenax"]
content_margin_left = 5.0
content_margin_top = 5.0
content_margin_right = 5.0
content_margin_bottom = 5.0
bg_color = Color(0.101961, 0.101961, 0.101961, 0.352941)

[node name="Chat" type="Control"]
z_index = 1
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_hxcw4")

[node name="PeekFeed" type="VBoxContainer" parent="."]
layout_mode = 0
offset_left = 10.0
offset_top = 10.0
offset_right = 310.0
offset_bottom = 205.0
mouse_filter = 0

[node name="MessageDisplay" type="RichTextLabel" parent="PeekFeed"]
custom_minimum_size = Vector2(300, 125)
layout_mode = 2
mouse_filter = 1
theme_override_styles/normal = SubResource("StyleBoxFlat_14md2")
bbcode_enabled = true
scroll_following = true

[node name="MessageEdit" type="LineEdit" parent="PeekFeed"]
layout_mode = 2
theme_override_styles/normal = SubResource("StyleBoxFlat_14md2")
placeholder_text = "Enter your message here"

[node name="FadeOutTimer" type="Timer" parent="PeekFeed"]
wait_time = 3.0
one_shot = true

[node name="FullFeed" type="Control" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundGradient" type="TextureRect" parent="FullFeed"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_right = -445.0
grow_horizontal = 2
grow_vertical = 2
texture = SubResource("GradientTexture1D_oenax")

[node name="Control" type="MarginContainer" parent="FullFeed"]
layout_mode = 0
offset_right = 522.0
offset_bottom = 539.0
theme_override_constants/margin_top = 1
theme_override_constants/margin_right = 20

[node name="HBoxContainer" type="HBoxContainer" parent="FullFeed/Control"]
layout_mode = 2
theme_override_constants/separation = 5

[node name="ContactPanel" type="PanelContainer" parent="FullFeed/Control/HBoxContainer"]
layout_mode = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_ary8x")

[node name="VBoxContainer" type="VBoxContainer" parent="FullFeed/Control/HBoxContainer/ContactPanel"]
layout_mode = 2

[node name="PublicLabel" type="Label" parent="FullFeed/Control/HBoxContainer/ContactPanel/VBoxContainer"]
layout_mode = 2
text = "Public"

[node name="Button" type="Button" parent="FullFeed/Control/HBoxContainer/ContactPanel/VBoxContainer"]
custom_minimum_size = Vector2(0, 35)
layout_mode = 2
text = "System"

[node name="Button2" type="Button" parent="FullFeed/Control/HBoxContainer/ContactPanel/VBoxContainer"]
custom_minimum_size = Vector2(0, 35)
layout_mode = 2
text = "World"

[node name="Button6" type="Button" parent="FullFeed/Control/HBoxContainer/ContactPanel/VBoxContainer"]
custom_minimum_size = Vector2(0, 35)
layout_mode = 2
text = "Team"

[node name="Button5" type="Button" parent="FullFeed/Control/HBoxContainer/ContactPanel/VBoxContainer"]
custom_minimum_size = Vector2(0, 35)
layout_mode = 2
text = "Guild"

[node name="HSeparator" type="HSeparator" parent="FullFeed/Control/HBoxContainer/ContactPanel/VBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 5
theme_override_styles/separator = SubResource("StyleBoxFlat_jlimx")

[node name="PrivateLabel" type="Label" parent="FullFeed/Control/HBoxContainer/ContactPanel/VBoxContainer"]
layout_mode = 2
text = "Private"

[node name="Button3" type="Button" parent="FullFeed/Control/HBoxContainer/ContactPanel/VBoxContainer"]
custom_minimum_size = Vector2(0, 35)
layout_mode = 2
text = " New message"

[node name="Button4" type="Button" parent="FullFeed/Control/HBoxContainer/ContactPanel/VBoxContainer"]
custom_minimum_size = Vector2(0, 35)
layout_mode = 2
text = " New message"

[node name="HSeparator2" type="HSeparator" parent="FullFeed/Control/HBoxContainer/ContactPanel/VBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 5
theme_override_styles/separator = SubResource("StyleBoxFlat_jlimx")

[node name="AddButton" type="Button" parent="FullFeed/Control/HBoxContainer/ContactPanel/VBoxContainer"]
custom_minimum_size = Vector2(0, 35)
layout_mode = 2
size_flags_vertical = 10
size_flags_stretch_ratio = 4.0
text = "Add"

[node name="CloseButton" type="Button" parent="FullFeed/Control/HBoxContainer/ContactPanel/VBoxContainer"]
custom_minimum_size = Vector2(0, 35)
layout_mode = 2
size_flags_vertical = 10
text = "Close"

[node name="VSeparator" type="VSeparator" parent="FullFeed/Control/HBoxContainer"]
modulate = Color(0.2, 0.2, 0.2, 1)
layout_mode = 2
theme_override_constants/separation = -1

[node name="ChatPanel" type="PanelContainer" parent="FullFeed/Control/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_styles/panel = SubResource("StyleBoxEmpty_jlimx")

[node name="VBoxContainer2" type="VBoxContainer" parent="FullFeed/Control/HBoxContainer/ChatPanel"]
layout_mode = 2
size_flags_horizontal = 3

[node name="HBoxContainer" type="HBoxContainer" parent="FullFeed/Control/HBoxContainer/ChatPanel/VBoxContainer2"]
layout_mode = 2

[node name="Label" type="Label" parent="FullFeed/Control/HBoxContainer/ChatPanel/VBoxContainer2/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
text = "World"
horizontal_alignment = 1

[node name="Button" type="Button" parent="FullFeed/Control/HBoxContainer/ChatPanel/VBoxContainer2/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_stretch_ratio = 0.3
text = "Settings"

[node name="HSeparator" type="HSeparator" parent="FullFeed/Control/HBoxContainer/ChatPanel/VBoxContainer2"]
self_modulate = Color(0.2, 0.2, 0.2, 1)
layout_mode = 2

[node name="RichTextLabel" type="RichTextLabel" parent="FullFeed/Control/HBoxContainer/ChatPanel/VBoxContainer2"]
layout_mode = 2
size_flags_vertical = 3
theme_override_styles/background = SubResource("StyleBoxFlat_s6uxj")
theme_override_styles/normal = SubResource("StyleBoxFlat_oenax")
bbcode_enabled = true
text = "[color=gray]SenderName[/color]
Hello
[right][color=gray]Me[/color]
[right]Hi
"

[node name="HSeparator2" type="HSeparator" parent="FullFeed/Control/HBoxContainer/ChatPanel/VBoxContainer2"]
modulate = Color(0.2, 0.2, 0.2, 1)
layout_mode = 2

[node name="HBoxContainer2" type="HBoxContainer" parent="FullFeed/Control/HBoxContainer/ChatPanel/VBoxContainer2"]
layout_mode = 2

[node name="LineEdit" type="LineEdit" parent="FullFeed/Control/HBoxContainer/ChatPanel/VBoxContainer2/HBoxContainer2"]
layout_mode = 2
size_flags_horizontal = 3
placeholder_text = "Enter a message"
alignment = 1

[node name="Button" type="Button" parent="FullFeed/Control/HBoxContainer/ChatPanel/VBoxContainer2/HBoxContainer2"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_stretch_ratio = 0.3
text = "Send"

[connection signal="gui_input" from="PeekFeed" to="." method="_on_peek_feed_gui_input"]
[connection signal="timeout" from="PeekFeed/FadeOutTimer" to="." method="_on_fade_out_timer_timeout"]
[connection signal="pressed" from="FullFeed/Control/HBoxContainer/ContactPanel/VBoxContainer/CloseButton" to="." method="_on_close_button_pressed"]
[connection signal="meta_clicked" from="FullFeed/Control/HBoxContainer/ChatPanel/VBoxContainer2/RichTextLabel" to="." method="_on_rich_text_label_meta_clicked"]
res://source/client/ui/menus/inventory/attributes_panel.gd

--- res://source/client/ui/menus/inventory/attributes_panel.gd ---
extends VBoxContainer


var attributes: Dictionary
var available_points: int:
	set = _set_available_points

@onready var available_points_label: Label = $AvailablePointsLabel


func _ready() -> void:
	InstanceClient.current.request_data(
		&"attribute.get",
		_on_attribute_received,
	)
	for child: Node in get_children():
		if child is HBoxContainer:
			var label: Label = child.get_child(0)
			var button: Button = child.get_child(1)
			button.pressed.connect(_on_attribute_pressed.bind(label, button))
	
	#for child: Node in find_children("*Button", "Button"):
		#if child is Button:
			#child.pressed.connect(_on_attribute_pressed.bind(child.text.to_lower()))


#func _on_attribute_pressed(attribute_name: String) -> void:
func _on_attribute_pressed(label: Label, button: Button) -> void:
	# Checked on server too.
	if not available_points > 0:
		return
	available_points -= 1
	
	var attribute_name: String = label.text.get_slice(" ", 0).to_lower()
	if attributes.has(attribute_name):
		attributes[attribute_name] += 1
	else:
		attributes[attribute_name] = 1
		
	var attribute_points: int = attributes[attribute_name]
	
	label.text = "%s %d" % [attribute_name, attribute_points]
	
	var stats: Dictionary = AttributeMap.attr_to_stats({attribute_name: 1})
	for stat_name: StringName in stats:
		if ClientState.stats.data.has(stat_name):
			ClientState.stats.data[stat_name] += stats[stat_name]
		else:
			ClientState.stats.data[stat_name] = stats[stat_name]
	InstanceClient.current.data_push(&"stats.update", ClientState.stats.data)
	
	InstanceClient.current.request_data(
		&"attribute.spend",
		Callable(), #_on_attribute_result_received
		{"attr": attribute_name}
	)


# If we want to check for error
#func _on_attribute_result_received(data: Dictionary) -> void:
	#if attributes
#	

func _on_attribute_received(data: Dictionary) -> void:
	attributes = data.get("attr", {})
	available_points = data.get("points", 0)
	print_debug("Debug:\n" + str(data))
	for child: Node in get_children():
		if child is HBoxContainer:
			var label: Label = child.get_child(0)
			var label_attribute: String = label.text.get_slice(" ", 0).to_lower()
			if attributes.has(label_attribute):
				label.text.replace(
					label.text.get_slice(" ", 1),
					str(attributes[label_attribute])
				)


func _set_available_points(value: int) -> void:
	available_points_label.text = "Available points: %d" % value
	available_points = value
res://source/client/ui/menus/inventory/attributes_panel.gd.uid
res://source/client/ui/menus/inventory/gear_slot.gd

--- res://source/client/ui/menus/inventory/gear_slot.gd ---
extends Button
class_name GearSlotButton


@export var gear_slot: ItemSlot


func _ready() -> void:
	if not gear_slot:
		disabled = true
		return
	
	tooltip_text = gear_slot.display_name
	icon = gear_slot.icon
	if gear_slot.unlock_rule.kind == SlotUnlockRule.Kind.PLAYER_LEVEL:
		text = str(gear_slot.unlock_rule.level)
res://source/client/ui/menus/inventory/gear_slot.gd.uid
res://source/client/ui/menus/inventory/inventory_menu.gd

--- res://source/client/ui/menus/inventory/inventory_menu.gd ---
extends Control


## ALl items of the player inventory.
var inventory: Dictionary[int, InventorySlot]
## Filtered inventory showing equipment only.
var equipment_inventory: Dictionary
## Filtered inventory showing equipment only.
var materials_inventory: Dictionary

var latest_items: Dictionary
var gear_slots_cache: Dictionary[Button, Item]
var selected_item: Item

@onready var inventory_grid: GridContainer = $MarginContainer/VBoxContainer/MainContainer/InventoryPanel/VBoxContainer/ScrollContainer/InventoryGrid
@onready var equipment_slots: GridContainer = $MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/EquipmentSlots

@onready var item_info: ColorRect = $ItemInfo
@onready var item_preview_icon: TextureRect = $ItemInfo/PanelContainer/VBoxContainer/ItemPreviewIcon
@onready var item_description: RichTextLabel = $ItemInfo/PanelContainer/VBoxContainer/ItemDescription
@onready var item_action_button: Button = $ItemInfo/PanelContainer/VBoxContainer/HBoxContainer/ItemActionButton
@onready var quick_slots_container: HBoxContainer = $ItemInfo/HotkeyPanel/VBoxContainer/HBoxContainer


func _ready() -> void:
	for equipment_slot: GearSlotButton in equipment_slots.get_children():
		if equipment_slot.gear_slot:
			if equipment_slot.gear_slot == null:
				equipment_slot.text = "Empty"
		else:
			equipment_slot.icon = null
			equipment_slot.text = "Lock"
	InstanceClient.current.request_data(&"inventory.get", fill_inventory)


func fill_inventory(inventory_data: Dictionary) -> void:
	for item_id: int in inventory_data:
		var item_data: Dictionary = inventory_data[item_id]
		if not inventory.has(item_id):
			add_item(item_id, item_data)
			continue
		inventory[item_id].update_slot(item_data)


func add_item(item_id: int, item_data: Dictionary) -> void:
	var item: Item = ContentRegistryHub.load_by_id(&"items", item_id)
	if not item:
		return
	
	var inventory_slot: InventorySlot = InventorySlot.new()
	
	var new_button: Button = Button.new()
	
	new_button.custom_minimum_size = Vector2(62, 62)
	
	new_button.icon_alignment = HORIZONTAL_ALIGNMENT_CENTER
	new_button.expand_icon = true
	
	# Calcul the should be size of the icon
	# If we don't want to have blrurry pixel art
	var sb: StyleBox = BetterThemeDB.theme.get_stylebox(&"normal", &"Button")
	var content_margin: Vector2i = Vector2i(
		sb.get_content_margin(SIDE_LEFT) + sb.get_content_margin(SIDE_RIGHT),
		sb.get_content_margin(SIDE_TOP) +  sb.get_content_margin(SIDE_BOTTOM),
	)
	var available_size: Vector2i = Vector2i(new_button.custom_minimum_size) - content_margin
	var item_icon_size: Vector2i = item.item_icon.get_size()

	var final_size: Vector2i = (available_size - item_icon_size).snapped(item_icon_size)
	
	new_button.add_theme_constant_override(
			&"icon_max_width",
			final_size[final_size.min_axis_index()]
			)
	
	new_button.icon = item.item_icon
	new_button.pressed.connect(
		_on_item_slot_button_pressed.bind(inventory_slot)
	)
	
	inventory_grid.add_child(new_button)
	
	inventory_slot.button = new_button
	inventory_slot.item_id = item_id
	inventory_slot.quantity = item_data.get("qty", 1)
	inventory_slot.item_data = item_data
	inventory_slot.item = item
	
	inventory[item_id] = inventory_slot


func _on_close_button_pressed() -> void:
	hide()


func _on_item_slot_button_pressed(inventory_slot: InventorySlot) -> void:
	item_preview_icon.texture = inventory_slot.item.item_icon
	item_description.text = inventory_slot.item.description
	
	# Actions are disabled in the current MVP; just show info.
	item_action_button.text = "Not available"
	item_action_button.disabled = true
	
	selected_item = inventory_slot.item
	
	item_info.gui_input.connect(_on_item_info_gui_input)
	
	$ItemInfo/PanelContainer/VBoxContainer/HBoxContainer/HotkeyButton.hide()
	item_info.show()


func _on_item_info_gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.pressed:
		item_info.gui_input.disconnect(_on_item_info_gui_input)
		$ItemInfo/HotkeyPanel.hide()
		item_info.hide()


func _on_item_action_button_pressed() -> void:
	# Disabled: server-side equip/use not implemented.
	item_info.gui_input.disconnect(_on_item_info_gui_input)
	item_info.hide()


class InventorySlot:
	var button: Button
	var quantity: int
	var item_id: int
	var item_data: Dictionary
	var item: Item


	func update_slot(data: Dictionary) -> void:
		quantity += data.get("add", 0)
		item_data.merge(data, true)
		button.text = str(quantity)

var connect_hotkey_once: bool = false
func _on_hotkey_button_pressed() -> void:
	# Hotkeys disabled in current MVP.
	$ItemInfo/HotkeyPanel.hide()


func _on_hotkey_index_pressed(hotkey_index: int) -> void:
	ClientState.quick_slots.set_key(hotkey_index, selected_item)
	
	var button: Button = quick_slots_container.get_child(hotkey_index)
	button.icon = selected_item.item_icon
	$ItemInfo/HotkeyPanel.hide()


func _on_hotkey_cancel_button_pressed() -> void:
	$ItemInfo/HotkeyPanel.hide()
res://source/client/ui/menus/inventory/inventory_menu.gd.uid
res://source/client/ui/menus/inventory/inventory_menu.tscn

--- res://source/client/ui/menus/inventory/inventory_menu.tscn ---
[gd_scene load_steps=19 format=3 uid="uid://dia55s0a7lhnv"]

[ext_resource type="Script" uid="uid://3kue0fgf78ik" path="res://source/client/ui/menus/inventory/inventory_menu.gd" id="1_g6fyq"]
[ext_resource type="Script" uid="uid://cx6ltmvpbwdng" path="res://source/client/ui/menus/inventory/gear_slot.gd" id="2_0wccm"]
[ext_resource type="Texture2D" uid="uid://tg02o3a14emh" path="res://assets/sprites/items/icons/Icon162.png" id="2_q1iwn"]
[ext_resource type="Texture2D" uid="uid://bd0ohyvo6looc" path="res://assets/sprites/items/icons/Icon202.png" id="3_3w0rw"]
[ext_resource type="Texture2D" uid="uid://bb7ec36sc1thr" path="res://assets/sprites/items/icons/Icon182.png" id="4_0wccm"]
[ext_resource type="Texture2D" uid="uid://cf0y64q72i32l" path="res://assets/sprites/items/icons/Icon2.png" id="5_lqdnc"]
[ext_resource type="Texture2D" uid="uid://c5i67th8u1h7l" path="res://assets/sprites/items/icons/Icon222.png" id="6_7d8wy"]
[ext_resource type="Texture2D" uid="uid://c3n053obioby0" path="res://assets/sprites/items/icons/Icon142.png" id="7_4toxt"]
[ext_resource type="Texture2D" uid="uid://cslc64xbpxpsd" path="res://assets/sprites/items/icons/Icon321.png" id="8_3w0rw"]
[ext_resource type="Resource" uid="uid://qav4p12rsbn3" path="res://source/common/gameplay/items/item_slot/slots/weapon.tres" id="8_as6qe"]
[ext_resource type="Texture2D" uid="uid://w14y1o4gi3l2" path="res://assets/sprites/items/icons/Icon325.png" id="9_0wccm"]
[ext_resource type="Resource" uid="uid://wi13k03tseev" path="res://source/common/gameplay/items/item_slot/slots/torso.tres" id="10_xkgtg"]
[ext_resource type="Script" uid="uid://blh63bbqvk7pv" path="res://source/client/ui/menus/inventory/attributes_panel.gd" id="14_hc0xo"]
[ext_resource type="Script" uid="uid://dm4es1smo6nxw" path="res://source/client/ui/menus/inventory/stats_panel.gd" id="14_xkgtg"]
[ext_resource type="Texture2D" uid="uid://dtvatbrsvpnpe" path="res://assets/sprites/items/icons/Icon271.png" id="15_svewr"]

[sub_resource type="Gradient" id="Gradient_xkgtg"]
offsets = PackedFloat32Array(0, 0.522634)
colors = PackedColorArray(0.0745098, 0.0862745, 0.117647, 1, 0, 0, 0, 0)

[sub_resource type="GradientTexture2D" id="GradientTexture2D_bu56u"]
gradient = SubResource("Gradient_xkgtg")
fill_from = Vector2(0, 1)
fill_to = Vector2(0, 0)

[sub_resource type="StyleBoxTexture" id="StyleBoxTexture_b71y3"]
texture = SubResource("GradientTexture2D_bu56u")

[node name="Inventory" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_g6fyq")

[node name="BackgroundRect" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.184314, 0.184314, 0.184314, 0.662745)
metadata/_edit_lock_ = true

[node name="MarginContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 7
theme_override_constants/margin_top = 7
theme_override_constants/margin_right = 7
theme_override_constants/margin_bottom = 7
metadata/_edit_lock_ = true

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer"]
layout_mode = 2

[node name="MainContainer" type="HBoxContainer" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 15

[node name="InventoryPanel" type="PanelContainer" parent="MarginContainer/VBoxContainer/MainContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer/VBoxContainer/MainContainer/InventoryPanel"]
layout_mode = 2
size_flags_horizontal = 3

[node name="ScrollContainer" type="ScrollContainer" parent="MarginContainer/VBoxContainer/MainContainer/InventoryPanel/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3
theme_override_styles/panel = SubResource("StyleBoxTexture_b71y3")
horizontal_scroll_mode = 0
vertical_scroll_mode = 3

[node name="InventoryGrid" type="GridContainer" parent="MarginContainer/VBoxContainer/MainContainer/InventoryPanel/VBoxContainer/ScrollContainer"]
show_behind_parent = true
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/h_separation = 10
theme_override_constants/v_separation = 10
columns = 4
metadata/_edit_group_ = true

[node name="HBoxContainer" type="HBoxContainer" parent="MarginContainer/VBoxContainer/MainContainer/InventoryPanel/VBoxContainer"]
layout_mode = 2

[node name="Button" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/InventoryPanel/VBoxContainer/HBoxContainer"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
text = "PREVIOUS"
icon_alignment = 1
expand_icon = true

[node name="Button2" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/InventoryPanel/VBoxContainer/HBoxContainer"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "EQUIPMENT"
icon_alignment = 1
expand_icon = true

[node name="Button4" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/InventoryPanel/VBoxContainer/HBoxContainer"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
text = "NEXT"
icon_alignment = 1
expand_icon = true

[node name="CharacterPanel" type="PanelContainer" parent="MarginContainer/VBoxContainer/MainContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="TitleLabel" type="Label" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel"]
visible = false
layout_mode = 2
size_flags_vertical = 0
text = "Inventory"

[node name="VBoxContainer2" type="VBoxContainer" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 30

[node name="EquipmentSlots" type="GridContainer" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2"]
layout_mode = 2
size_flags_horizontal = 4
size_flags_vertical = 3
columns = 3
metadata/_edit_group_ = true

[node name="Button" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/EquipmentSlots"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
text = "lvl. 10"
icon_alignment = 1
expand_icon = true
script = ExtResource("2_0wccm")
metadata/_custom_type_script = "uid://cx6ltmvpbwdng"

[node name="Button4" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/EquipmentSlots"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
icon = ExtResource("2_q1iwn")
icon_alignment = 1
expand_icon = true
script = ExtResource("2_0wccm")
metadata/_custom_type_script = "uid://cx6ltmvpbwdng"

[node name="Button3" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/EquipmentSlots"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
text = "lvl. 20"
icon_alignment = 1
expand_icon = true
script = ExtResource("2_0wccm")
metadata/_custom_type_script = "uid://cx6ltmvpbwdng"

[node name="Button2" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/EquipmentSlots"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
icon = ExtResource("3_3w0rw")
icon_alignment = 1
expand_icon = true
script = ExtResource("2_0wccm")
metadata/_custom_type_script = "uid://cx6ltmvpbwdng"

[node name="Button5" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/EquipmentSlots"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
icon = ExtResource("4_0wccm")
icon_alignment = 1
expand_icon = true
script = ExtResource("2_0wccm")
gear_slot = ExtResource("10_xkgtg")
metadata/_custom_type_script = "uid://cx6ltmvpbwdng"

[node name="Button7" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/EquipmentSlots"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
text = "lvl. 5"
icon_alignment = 1
expand_icon = true
script = ExtResource("2_0wccm")
metadata/_custom_type_script = "uid://cx6ltmvpbwdng"

[node name="HandSlot1" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/EquipmentSlots"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
icon = ExtResource("5_lqdnc")
icon_alignment = 1
expand_icon = true
script = ExtResource("2_0wccm")
gear_slot = ExtResource("8_as6qe")
metadata/_custom_type_script = "uid://cx6ltmvpbwdng"

[node name="Button6" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/EquipmentSlots"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
icon = ExtResource("6_7d8wy")
icon_alignment = 1
expand_icon = true
script = ExtResource("2_0wccm")
metadata/_custom_type_script = "uid://cx6ltmvpbwdng"

[node name="HandSlot2" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/EquipmentSlots"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
icon = ExtResource("7_4toxt")
icon_alignment = 1
expand_icon = true
script = ExtResource("2_0wccm")
metadata/_custom_type_script = "uid://cx6ltmvpbwdng"

[node name="HBoxContainer" type="HBoxContainer" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2"]
layout_mode = 2
alignment = 1

[node name="Button" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/HBoxContainer"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
text = "???"
icon_alignment = 1
expand_icon = true
script = ExtResource("2_0wccm")
metadata/_custom_type_script = "uid://cx6ltmvpbwdng"

[node name="Button2" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/HBoxContainer"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
text = "???"
icon_alignment = 1
expand_icon = true
script = ExtResource("2_0wccm")
metadata/_custom_type_script = "uid://cx6ltmvpbwdng"

[node name="Button3" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/HBoxContainer"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
text = "???"
icon_alignment = 1
expand_icon = true
script = ExtResource("2_0wccm")
metadata/_custom_type_script = "uid://cx6ltmvpbwdng"

[node name="Button4" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/HBoxContainer"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
text = "???"
icon_alignment = 1
expand_icon = true
script = ExtResource("2_0wccm")
metadata/_custom_type_script = "uid://cx6ltmvpbwdng"

[node name="Stats" type="PanelContainer" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2"]
layout_mode = 2
size_flags_vertical = 3
script = ExtResource("14_xkgtg")

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/Stats"]
layout_mode = 2

[node name="RichTextLabel" type="RichTextLabel" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/Stats/VBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
bbcode_enabled = true
text = "[color=#08b502]HP 100[/color]
Damage 20
Magic 0"
scroll_active = false

[node name="DetailsButton" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/Stats/VBoxContainer"]
layout_mode = 2
text = "Details"

[node name="TabContainer" type="TabContainer" parent="MarginContainer/VBoxContainer/MainContainer"]
layout_mode = 2
size_flags_horizontal = 3
current_tab = 1
tabs_position = 1
tab_focus_mode = 0

[node name="Status" type="VBoxContainer" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer"]
visible = false
layout_mode = 2
size_flags_horizontal = 3
metadata/_tab_index = 0

[node name="Label2" type="Label" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Status"]
layout_mode = 2
text = "Level 18
Job Fighter
Golds 0"
horizontal_alignment = 3

[node name="Label3" type="Label" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Status"]
layout_mode = 2
text = "Energy 100/100"
horizontal_alignment = 3

[node name="Label8" type="Label" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Status"]
layout_mode = 2
text = "Experience 22/5000"
horizontal_alignment = 3

[node name="Button" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Status"]
layout_mode = 2
text = "SKILL BOOK"

[node name="Button2" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Status"]
layout_mode = 2
text = "TITLES"

[node name="Attributes" type="VBoxContainer" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer"]
layout_mode = 2
theme_override_constants/separation = 8
script = ExtResource("14_hc0xo")
metadata/_tab_index = 1

[node name="HBoxContainer" type="HBoxContainer" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="Label" type="Label" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
text = "Vitality 0"
horizontal_alignment = 3

[node name="Button" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes/HBoxContainer"]
custom_minimum_size = Vector2(48, 48)
layout_mode = 2
text = "+"

[node name="HSeparator" type="HSeparator" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes"]
layout_mode = 2

[node name="HBoxContainer2" type="HBoxContainer" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="Label" type="Label" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes/HBoxContainer2"]
layout_mode = 2
size_flags_horizontal = 3
text = "Strenght 0"
horizontal_alignment = 3

[node name="Button" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes/HBoxContainer2"]
custom_minimum_size = Vector2(48, 48)
layout_mode = 2
text = "+"

[node name="HSeparator2" type="HSeparator" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes"]
layout_mode = 2

[node name="HBoxContainer3" type="HBoxContainer" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="Label" type="Label" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes/HBoxContainer3"]
layout_mode = 2
size_flags_horizontal = 3
text = "Spirit 0"
horizontal_alignment = 3

[node name="Button" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes/HBoxContainer3"]
custom_minimum_size = Vector2(48, 48)
layout_mode = 2
text = "+"

[node name="HSeparator3" type="HSeparator" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes"]
layout_mode = 2

[node name="HBoxContainer4" type="HBoxContainer" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="Label" type="Label" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes/HBoxContainer4"]
layout_mode = 2
size_flags_horizontal = 3
text = "Intelligence 0"
horizontal_alignment = 3

[node name="Button" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes/HBoxContainer4"]
custom_minimum_size = Vector2(48, 48)
layout_mode = 2
text = "+"

[node name="HSeparator4" type="HSeparator" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes"]
layout_mode = 2

[node name="HBoxContainer5" type="HBoxContainer" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="Label" type="Label" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes/HBoxContainer5"]
layout_mode = 2
size_flags_horizontal = 3
text = "Agility 0"
horizontal_alignment = 3

[node name="Button" type="Button" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes/HBoxContainer5"]
custom_minimum_size = Vector2(48, 48)
layout_mode = 2
text = "+"

[node name="HSeparator5" type="HSeparator" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes"]
layout_mode = 2

[node name="AvailablePointsLabel" type="Label" parent="MarginContainer/VBoxContainer/MainContainer/TabContainer/Attributes"]
layout_mode = 2
size_flags_vertical = 10
text = "Available points: 10"
horizontal_alignment = 1

[node name="MaterialsContainer" type="PanelContainer" parent="MarginContainer/VBoxContainer"]
visible = false
layout_mode = 2
size_flags_vertical = 3

[node name="RichTextLabel" type="RichTextLabel" parent="MarginContainer/VBoxContainer/MaterialsContainer"]
layout_mode = 2
bbcode_enabled = true
text = "[center]Grey Stone[/center]
[center]A stone used to craft items.[/center]"

[node name="InventoryGrid" type="GridContainer" parent="MarginContainer/VBoxContainer/MaterialsContainer"]
layout_mode = 2
size_flags_horizontal = 4
size_flags_vertical = 4
theme_override_constants/h_separation = 10
theme_override_constants/v_separation = 10
columns = 10
metadata/_edit_group_ = true

[node name="Button" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
text = "x32"
icon = ExtResource("8_3w0rw")
icon_alignment = 1
expand_icon = true

[node name="Button2" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
text = "x32"
icon = ExtResource("9_0wccm")
icon_alignment = 1
expand_icon = true

[node name="Button3" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
icon_alignment = 1
expand_icon = true

[node name="Button4" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
icon_alignment = 1
expand_icon = true

[node name="Button5" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
icon_alignment = 1
expand_icon = true

[node name="Button6" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button7" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button8" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button9" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button10" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button11" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button12" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button13" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button14" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button15" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button16" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button17" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button18" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button19" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button20" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button21" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button22" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button23" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button24" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button25" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button26" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button27" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button28" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button29" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button30" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2

[node name="Button31" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
text = "Lock"

[node name="Button32" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
text = "Lock"

[node name="Button33" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
text = "Lock"

[node name="Button34" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
text = "Lock"

[node name="Button35" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
text = "Lock"

[node name="Button36" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
text = "Lock"

[node name="Button37" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
text = "Lock"

[node name="Button38" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
text = "Lock"

[node name="Button39" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
text = "Lock"

[node name="Button40" type="Button" parent="MarginContainer/VBoxContainer/MaterialsContainer/InventoryGrid"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
text = "Lock"

[node name="BottomContainer" type="HBoxContainer" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
alignment = 2

[node name="Label" type="Label" parent="MarginContainer/VBoxContainer/BottomContainer"]
layout_mode = 2
size_flags_horizontal = 3
text = "[console-icon-action-2] Details [console-icon-action-8] Exit"

[node name="HistoryButton" type="Button" parent="MarginContainer/VBoxContainer/BottomContainer"]
custom_minimum_size = Vector2(80, 48)
layout_mode = 2
text = "History"

[node name="CloseButton" type="Button" parent="MarginContainer/VBoxContainer/BottomContainer"]
custom_minimum_size = Vector2(80, 48)
layout_mode = 2
text = "Close"

[node name="ItemInfo" type="ColorRect" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.092, 0.092, 0.092, 0.541)
metadata/_edit_lock_ = true

[node name="PanelContainer" type="PanelContainer" parent="ItemInfo"]
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -183.0
offset_top = -192.0
offset_right = 183.0
offset_bottom = 192.0
grow_horizontal = 2
grow_vertical = 2
size_flags_vertical = 3
metadata/_edit_group_ = true

[node name="VBoxContainer" type="VBoxContainer" parent="ItemInfo/PanelContainer"]
layout_mode = 2

[node name="ItemPreviewIcon" type="TextureRect" parent="ItemInfo/PanelContainer/VBoxContainer"]
custom_minimum_size = Vector2(62, 62)
layout_mode = 2
size_flags_horizontal = 4
texture = ExtResource("15_svewr")
stretch_mode = 4

[node name="ItemDescription" type="RichTextLabel" parent="ItemInfo/PanelContainer/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3
text = "Thornmail - Level 1

30 Health
5 Armor

Unique  Thorns: When struck by a basic attack on-hit, deal 2 (+ 5% bonus armor) magic damage to the attacker."

[node name="HBoxContainer" type="HBoxContainer" parent="ItemInfo/PanelContainer/VBoxContainer"]
layout_mode = 2
alignment = 1

[node name="ItemActionButton" type="Button" parent="ItemInfo/PanelContainer/VBoxContainer/HBoxContainer"]
custom_minimum_size = Vector2(120, 52)
layout_mode = 2
size_flags_horizontal = 4
text = "Equip"

[node name="HotkeyButton" type="Button" parent="ItemInfo/PanelContainer/VBoxContainer/HBoxContainer"]
custom_minimum_size = Vector2(120, 52)
layout_mode = 2
size_flags_horizontal = 4
text = "Hotkey"

[node name="HotkeyPanel" type="PanelContainer" parent="ItemInfo"]
visible = false
custom_minimum_size = Vector2(366, 384)
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -183.0
offset_top = -192.0
offset_right = 183.0
offset_bottom = 192.0
grow_horizontal = 2
grow_vertical = 2

[node name="VBoxContainer" type="VBoxContainer" parent="ItemInfo/HotkeyPanel"]
layout_mode = 2
alignment = 1

[node name="Label" type="Label" parent="ItemInfo/HotkeyPanel/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 10
text = "Chooose an hotkey:"
horizontal_alignment = 1

[node name="HBoxContainer" type="HBoxContainer" parent="ItemInfo/HotkeyPanel/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 6
theme_override_constants/separation = 20
alignment = 1

[node name="Button" type="Button" parent="ItemInfo/HotkeyPanel/VBoxContainer/HBoxContainer"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
icon_alignment = 1
expand_icon = true

[node name="Button2" type="Button" parent="ItemInfo/HotkeyPanel/VBoxContainer/HBoxContainer"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
icon_alignment = 1
expand_icon = true

[node name="Button3" type="Button" parent="ItemInfo/HotkeyPanel/VBoxContainer/HBoxContainer"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
icon_alignment = 1
expand_icon = true

[node name="Button4" type="Button" parent="ItemInfo/HotkeyPanel/VBoxContainer/HBoxContainer"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
icon_alignment = 1
expand_icon = true

[node name="CancelButton" type="Button" parent="ItemInfo/HotkeyPanel/VBoxContainer"]
custom_minimum_size = Vector2(0, 48)
layout_mode = 2
size_flags_vertical = 10
text = "Cancel"

[connection signal="pressed" from="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/Stats/VBoxContainer/DetailsButton" to="MarginContainer/VBoxContainer/MainContainer/CharacterPanel/VBoxContainer2/Stats" method="_on_details_button_pressed"]
[connection signal="pressed" from="MarginContainer/VBoxContainer/BottomContainer/CloseButton" to="." method="_on_close_button_pressed"]
[connection signal="pressed" from="ItemInfo/PanelContainer/VBoxContainer/HBoxContainer/ItemActionButton" to="." method="_on_item_action_button_pressed"]
[connection signal="pressed" from="ItemInfo/PanelContainer/VBoxContainer/HBoxContainer/HotkeyButton" to="." method="_on_hotkey_button_pressed"]
[connection signal="pressed" from="ItemInfo/HotkeyPanel/VBoxContainer/CancelButton" to="." method="_on_hotkey_cancel_button_pressed"]
res://source/client/ui/menus/inventory/item_slot_button.gd

--- res://source/client/ui/menus/inventory/item_slot_button.gd ---
class_name ItemSlotButton
extends Button


var item: Item


#func _init() -> void:
	
res://source/client/ui/menus/inventory/item_slot_button.gd.uid
res://source/client/ui/menus/inventory/stats_panel.gd

--- res://source/client/ui/menus/inventory/stats_panel.gd ---
extends PanelContainer


var stats: Dictionary

@onready var stats_display: RichTextLabel = $VBoxContainer/RichTextLabel


func _ready() -> void:
	InstanceClient.subscribe(&"stats.update", fill_stats)
	# If already stored.
	fill_stats(ClientState.stats.data)


func fill_stats(data: Dictionary) -> void:
	if data.is_empty():
		return
	ClientState.stats.data.merge(data, true)
	
	stats_display.text = ""
	
	stats = ClientState.stats.data.duplicate()
	
	stats_display.push_table(2)
	stats_display.set_table_column_expand(0, true)
	stats_display.set_table_column_expand(1, true)
	
	
	add_stat_text("HP %d/%d", Color("#3de600"),
		[stats.get(Stat.HEALTH, 0), stats.get(Stat.HEALTH, 0)]
	)
	
	add_stat_text("Mana %d", Color("#009dc4"),
		[stats.get(Stat.MANA, 0)]
	)
	
	add_stat_text("Attack %d", Color("#fc7f03"),
		[stats.get(Stat.AD, 0)]
	)
	
	add_stat_text("Armor %d", Color("#fc7f03"),
		[stats.get(Stat.ARMOR, 0)]
	)
	
	add_stat_text("Magic %d", Color("#6f03fc"),
		[stats.get(Stat.AP, 0)]
	)
	
	add_stat_text("MagicRes %d", Color("#6f03fc"),
		[stats.get(Stat.MR, 0)]
	)

	add_stat_text("Speed %d", Color("#dbd802"),
		[stats.get(Stat.MOVE_SPEED, 0)]
	)
	
	add_stat_text("Tenacity %d", Color("#619902"),
		[stats.get(&"tenacity", 0)]
	)
	
	stats_display.pop()


func add_stat_text(text: String, color: Color, stats: Array) -> void:
	stats_display.push_cell()
	stats_display.push_color(color)
	stats_display.append_text(text % stats)
	stats_display.pop()
	stats_display.pop()


func _on_details_button_pressed() -> void:
	# Bad practice but good for fast test
	$"../EquipmentSlots".visible = not $"../EquipmentSlots".visible
	$"../HBoxContainer".visible = not $"../HBoxContainer".visible
res://source/client/ui/menus/inventory/stats_panel.gd.uid
res://source/client/ui/menus/player_profile/player_profile.gd

--- res://source/client/ui/menus/player_profile/player_profile.gd ---
extends Control


var cache: Dictionary[int, Dictionary]

@onready var name_label: Label = $PanelContainer/HBoxContainer/VBoxContainer2/Label
@onready var stats_text: RichTextLabel = $PanelContainer/HBoxContainer/StatsContainer/RichTextLabel
@onready var description_text: RichTextLabel = $PanelContainer/HBoxContainer/VBoxContainer2/RichTextLabel
@onready var profile_viewport: SubViewport = $PanelContainer/HBoxContainer/VBoxContainer2/Control/Control/ProfileViewportContainer/SubViewport
@onready var preview_root: Node3D = $PanelContainer/HBoxContainer/VBoxContainer2/Control/Control/ProfileViewportContainer/SubViewport/PreviewRoot

@onready var message_button: Button = $PanelContainer/HBoxContainer/VBoxContainer/MessageButton
@onready var friend_button: Button = $PanelContainer/HBoxContainer/VBoxContainer/FriendButton

var preview_instance: Node3D


func open_player_profile(player_id: int) -> void:
	if cache.has(player_id):
		apply_profile(cache[player_id])
	else:
		InstanceClient.current.request_data(
			&"profile.get",
			apply_profile,
			{"q": player_id}
		)


func apply_profile(profile: Dictionary) -> void:
	print_debug(profile)
	var stats: Dictionary = profile.get("stats", {})
	var player_name: String = profile.get("name", "No Name")
	var player_skin: int = profile.get("skin", 0)
	var animation: String = profile.get("animation", "idle")
	var description: String = profile.get("description", "")
	
	var params: Dictionary = profile.get("params", {})
	
	description_text.clear()
	description_text.append_text(description)
	
	add_stats(stats)
	set_player_character(player_skin, animation)
	name_label.text = player_name
	
	friend_button.visible = params.get("self", false)
	message_button.visible = params.get("self", false)
	friend_button.text = "Add friend" if params.get("friend", false) == true else "Remove Friend"
	
	show()
	
	if profile.get("id", 0):
		cache[profile.get("id")] = profile
	

func add_stats(stats: Dictionary):
	stats_text.clear()
	stats_text.text = ""
	for stat_name: String in stats:
		print("%s: %s" % [stat_name, stats[stat_name]])
		stats_text.append_text("%s: %s" % [stat_name, stats[stat_name]])


func set_player_character(skin_id: int, animation: String) -> void:
	if not preview_root:
		return

	if preview_instance and is_instance_valid(preview_instance):
		preview_instance.queue_free()

	var character_scene: PackedScene = load("res://source/common/gameplay/characters/character.tscn")
	if not character_scene:
		return

	preview_instance = character_scene.instantiate() as Node3D
	if not preview_instance:
		return

	# Keep the preview static; disable heavy processing if present.
	if preview_instance.has_method("set_process"):
		preview_instance.set_process(false)
	if preview_instance.has_method("set_physics_process"):
		preview_instance.set_physics_process(false)

	preview_instance.global_position = Vector3.ZERO
	preview_instance.rotation.y = PI
	preview_root.add_child(preview_instance)

	var anim_player: AnimationPlayer = preview_instance.find_child("AnimationPlayer", true, false)
	if anim_player:
		if animation != "" and anim_player.has_animation(animation):
			anim_player.play(animation)
		elif anim_player.has_animation("idle"):
			anim_player.play("idle")



func _on_close_pressed() -> void:
	hide()
res://source/client/ui/menus/player_profile/player_profile.gd.uid
res://source/client/ui/menus/player_profile/player_profile_menu.tscn

--- res://source/client/ui/menus/player_profile/player_profile_menu.tscn ---
[gd_scene load_steps=3 format=3 uid="uid://beypr510eoqml"]

[ext_resource type="Script" uid="uid://2dnwg3gkbaeg" path="res://source/client/ui/menus/player_profile/player_profile.gd" id="1_fnhhi"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_x41y2"]
content_margin_left = 15.0
content_margin_top = 15.0
content_margin_right = 15.0
content_margin_bottom = 15.0
bg_color = Color(0.237539, 0.237539, 0.237539, 1)

[node name="PlayerProfile" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_fnhhi")

[node name="PanelContainer" type="PanelContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 59.0
offset_top = 25.0
offset_right = -38.0
offset_bottom = -33.0
grow_horizontal = 2
grow_vertical = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_x41y2")

[node name="HBoxContainer" type="HBoxContainer" parent="PanelContainer"]
layout_mode = 2

[node name="StatsContainer" type="VBoxContainer" parent="PanelContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_stretch_ratio = 0.4

[node name="RichTextLabel" type="RichTextLabel" parent="PanelContainer/HBoxContainer/StatsContainer"]
layout_mode = 2
size_flags_vertical = 3
bbcode_enabled = true
text = "money: 0
character_class: knight
level: 0"
horizontal_alignment = 3
vertical_alignment = 1

[node name="VBoxContainer2" type="VBoxContainer" parent="PanelContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Label" type="Label" parent="PanelContainer/HBoxContainer/VBoxContainer2"]
layout_mode = 2
text = "hori"

[node name="Control" type="CenterContainer" parent="PanelContainer/HBoxContainer/VBoxContainer2"]
layout_mode = 2
size_flags_vertical = 3

[node name="Control" type="Control" parent="PanelContainer/HBoxContainer/VBoxContainer2/Control"]
layout_mode = 2
[node name="ProfileViewportContainer" type="SubViewportContainer" parent="PanelContainer/HBoxContainer/VBoxContainer2/Control/Control"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
stretch = true

[node name="SubViewport" type="SubViewport" parent="PanelContainer/HBoxContainer/VBoxContainer2/Control/Control/ProfileViewportContainer"]
handle_input_locally = false
render_target_update_mode = 3
size = Vector2i(300, 260)

[node name="PreviewRoot" type="Node3D" parent="PanelContainer/HBoxContainer/VBoxContainer2/Control/Control/ProfileViewportContainer/SubViewport"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0)

[node name="OmniLight3D" type="OmniLight3D" parent="PanelContainer/HBoxContainer/VBoxContainer2/Control/Control/ProfileViewportContainer/SubViewport"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.5, 2.5, 1.5)
light_intensity_lumens = 900.0

[node name="Camera3D" type="Camera3D" parent="PanelContainer/HBoxContainer/VBoxContainer2/Control/Control/ProfileViewportContainer/SubViewport"]
transform = Transform3D(0.707107, 0, -0.707107, 0.258819, 0.965926, 0.258819, 0.65974, -0.258819, 0.70588, 4, 2.5, 4)
current = true
fov = 40.0

[node name="RichTextLabel" type="RichTextLabel" parent="PanelContainer/HBoxContainer/VBoxContainer2"]
layout_mode = 2
size_flags_vertical = 3
bbcode_enabled = true
horizontal_alignment = 1
vertical_alignment = 1

[node name="VBoxContainer" type="VBoxContainer" parent="PanelContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_stretch_ratio = 0.3
alignment = 1

[node name="MessageButton" type="Button" parent="PanelContainer/HBoxContainer/VBoxContainer"]
layout_mode = 2
text = "Message"

[node name="FriendButton" type="Button" parent="PanelContainer/HBoxContainer/VBoxContainer"]
layout_mode = 2
text = "Add friend"

[node name="Close" type="Button" parent="PanelContainer/HBoxContainer/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 10
text = "Close"

[connection signal="pressed" from="PanelContainer/HBoxContainer/VBoxContainer/Close" to="." method="_on_close_pressed"]
res://source/client/ui/shared/sub_panel.gd

--- res://source/client/ui/shared/sub_panel.gd ---
class_name SubPanel
extends PanelContainer


signal swap_requested(target: SubPanel, data: Dictionary, can_back: bool)
signal back_requested


func open(data: Dictionary) -> void:
	pass


func close() -> void:
	pass
res://source/client/ui/shared/sub_panel.gd.uid
res://source/client/ui/themes/styles/gradient_button.tres
res://source/client/ui/themes/theme_desert.tres
res://source/client/ui/themes/theme_navy.tres
res://source/client/ui/ui.gd

--- res://source/client/ui/ui.gd ---
class_name UI
extends CanvasLayer


@onready var hud: Control = $HUD


func _ready() -> void:
	for child: Node in get_children():
		if child is Control:
			child.theme = BetterThemeDB.theme
res://source/client/ui/ui.gd.uid
res://source/client/ui/ui.tscn

--- res://source/client/ui/ui.tscn ---
[gd_scene load_steps=3 format=3 uid="uid://b20pv25ct6nmt"]

[ext_resource type="Script" uid="uid://bkb1spvl3spry" path="res://source/client/ui/ui.gd" id="1_wpqoj"]
[ext_resource type="PackedScene" uid="uid://dqt8fnt1l33eu" path="res://source/client/ui/hud/hud.tscn" id="2_equq2"]

[node name="UI" type="CanvasLayer"]
script = ExtResource("1_wpqoj")

[node name="HUD" parent="." node_paths=PackedStringArray("sub_menu") instance=ExtResource("2_equq2")]
sub_menu = NodePath("../Submenu")

[node name="Submenu" type="Control" parent="."]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
res://source/client/utils/button_utils.gd

--- res://source/client/utils/button_utils.gd ---
class_name ButtonUtils


static func set_focus_for_children_buttons(target: Node) -> void:
	var buttons: Array[Button] = find_buttons_in_children(target)
	if buttons.size() >= 2:
		set_focus_neighbors_for_buttons(buttons)


# Similar to find_children("*", "CharacterClassButton", true)
static func find_buttons_in_children(target: Node, type_hint: Variant = Button) -> Array:
	var buttons: Array = []
	for child: Node in target.get_children():
		if is_instance_of(child, type_hint):
			buttons.append(child)
		if child.get_child_count() > 0:
			buttons.append_array(find_buttons_in_children(child))
	return buttons


static func set_focus_neighbors_for_buttons(buttons: Array[Button]) -> void:
	var previous_button: Button = buttons.front()
	for button: Button in buttons:
		button.focus_neighbor_top = previous_button.get_path()
		previous_button.focus_neighbor_bottom = button.get_path()
		previous_button = button
	buttons.front().focus_neighbor_top = buttons.back().get_path()
	buttons.back().focus_neighbor_bottom = buttons.front().get_path()
res://source/client/utils/button_utils.gd.uid
res://source/client/utils/theme_changer.gd

--- res://source/client/utils/theme_changer.gd ---
class_name BetterThemeDB


static var theme: Theme:
	get = get_theme


static func get_theme() -> Theme:
	if not theme:
		theme = load(
			ProjectSettings.get_setting("gui/theme/custom", "res://source/client/ui/themes/theme_navy.tres")
		)
	return theme
res://source/client/utils/theme_changer.gd.uid
res://source/common/gameplay/characters/character.gd

--- res://source/common/gameplay/characters/character.gd ---
@icon("res://assets/node_icons/blue/icon_character.png")
class_name Character
extends CharacterBody3D

enum Animations {
	IDLE,
	RUN,
	DEATH,
}

var skin_id: int:
	set = _set_skin_id

var anim: Animations = Animations.IDLE:
	set = _set_anim

var pivot: float = 0.0:
	set = _set_pivot

# Removed StateSynchronizer
var ability_system_component: AbilitySystemComponent
var equipment_component: EquipmentComponent
var animation_player: AnimationPlayer
var animation_tree: AnimationTree
var locomotion_state_machine: AnimationNodeStateMachinePlayback


func _ready() -> void:
	# state_synchronizer = get_node_or_null("StateSynchronizer")
	ability_system_component = get_node_or_null("AbilitySystemComponent")
	equipment_component = get_node_or_null("EquipmentComponent")
	animation_player = get_node_or_null("AnimationPlayer")
	animation_tree = get_node_or_null("AnimationTree")
	if animation_tree:
		locomotion_state_machine = animation_tree.get("parameters/OnFoot/LocomotionSM/playback")

	if multiplayer.is_server():
		return
	
	if ability_system_component and ability_system_component.attributes:
		# Hook stat watchers only if the component exists.
		ability_system_component.attributes.connect_watcher(Stat.HEALTH,
			func(_value: float) -> void:
				pass # UI Logic Placeholder
		)
		# Se corrigi la indentacin aqu:
		ability_system_component.attributes.connect_watcher(Stat.HEALTH_MAX,
			func(_value: float) -> void:
				pass # UI Logic Placeholder
		)

func _set_skin_id(id: int) -> void:
	skin_id = id
	if multiplayer.is_server():
		return
	# Lgica visual desactivada temporalmente para la migracin
	pass

func _set_anim(new_anim: Animations) -> void:
	if locomotion_state_machine == null:
		anim = new_anim
		return
	match new_anim:
		Animations.IDLE:
			locomotion_state_machine.travel(&"locomotion_idle")
		Animations.RUN:
			locomotion_state_machine.travel(&"locomotion_run")
		Animations.DEATH:
			locomotion_state_machine[&"parameters/OnFoot/InteruptShot/request"] = AnimationNodeOneShot.ONE_SHOT_REQUEST_FIRE
	anim = new_anim

func _set_pivot(new_pivot: float) -> void:
	pivot = new_pivot


# Rotate character on the Y axis instead of 2D-style flipping.
func face_direction(direction: Vector3) -> void:
	if direction.length() < 0.001:
		return
	var yaw: float = atan2(direction.x, direction.z)
	rotation.y = yawres://source/common/gameplay/characters/character.gd.uid
res://source/common/gameplay/characters/character.tscn

--- res://source/common/gameplay/characters/character.tscn ---
[gd_scene load_steps=3 format=3 uid="uid://6bcg7fwcl6mi"]

[ext_resource type="Script" uid="uid://bu6yn6ww7d7c8" path="res://source/common/gameplay/characters/character.gd" id="1_bnwqd"]

[sub_resource type="CapsuleShape3D" id="CapsuleShape3D_bnwqd"]
radius = 0.4
height = 1.8

[sub_resource type="BoxMesh" id="CubeMesh"]
size = Vector3(0.8, 1.8, 0.8)

[node name="Character" type="CharacterBody3D"]
collision_layer = 2
collision_mask = 6
script = ExtResource("1_bnwqd")

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
shape = SubResource("CapsuleShape3D_bnwqd")

[node name="Visuals" type="Node3D" parent="."]

[node name="CharacterModel" type="MeshInstance3D" parent="Visuals"]
mesh = SubResource("CubeMesh")
res://source/common/gameplay/characters/npc/echo_ai.gd.uid
res://source/common/gameplay/characters/npc/npc.gd.uid
res://source/common/gameplay/characters/npc/npc_ai.gd.uid
res://source/common/gameplay/characters/npc/npc_simple.gd

--- res://source/common/gameplay/characters/npc/npc_simple.gd ---
extends CharacterBody3D
class_name NpcSimple

@export var doctrine: String = "Ignis"
@export var year: int = 1
@export var student_index: int = 1

func _ready():
	print("NPC Simple Ready: ", name)
res://source/common/gameplay/characters/npc/npc_simple.gd.uid
res://source/common/gameplay/characters/npc/npc_simple.tscn

--- res://source/common/gameplay/characters/npc/npc_simple.tscn ---
[gd_scene load_steps=4 format=3 uid="uid://npc_simple_v1"]

[ext_resource type="Script" path="res://source/common/gameplay/characters/npc/npc_simple.gd" id="1_script"]
[ext_resource type="PackedScene" path="res://source/common/gameplay/characters/character.tscn" id="2_base"]

[sub_resource type="SphereShape3D" id="SphereShape3D_e1g67"]
radius = 230.0

[node name="NpcSimple" instance=ExtResource("2_base")]
script = ExtResource("1_script")

[node name="DetectionArea" type="Area3D" parent="." index="10"]

[node name="CollisionShape3D" type="CollisionShape3D" parent="DetectionArea" index="0"]
shape = SubResource("SphereShape3D_e1g67")
res://source/common/gameplay/characters/npc/schedule_resource.gd

--- res://source/common/gameplay/characters/npc/schedule_resource.gd ---
class_name ScheduleResource
extends Resource

# 08:00 -> Desayuno (Todos al Gran Saln, a su mesa)
# 09:00 -> Clases (Ignis Y1 a Pociones, Axiom Y1 a Biblioteca)
# 13:00 -> Comida
# 20:00 -> Dormir

@export var schedule_data: Dictionary = {
	"08:00": {
		"group": "All_Students",
		"action": "Eat",
		"target": "Great_Hall"
	},
	"09:00_1": {
		"group": "Ignis_Year1",
		"action": "Class",
		"target": "Potions"
	},
	"09:00_2": {
		"group": "Axiom_Year1",
		"action": "Class",
		"target": "Library"
	},
	"13:00": {
		"group": "All_Students",
		"action": "Eat",
		"target": "Great_Hall"
	},
	"20:00": {
		"group": "All_Students",
		"action": "Sleep",
		"target": "Dormitory"
	}
}

func get_events_at_time(time_str: String) -> Array[Dictionary]:
	var events: Array[Dictionary] = []
	for key in schedule_data:
		if key == time_str or key.begins_with(time_str + "_"):
			events.append(schedule_data[key])
	return eventsres://source/common/gameplay/characters/npc/schedule_resource.gd.uid
res://source/common/gameplay/characters/player/net_player.gd

--- res://source/common/gameplay/characters/player/net_player.gd ---
extends CharacterBody3D
class_name NetPlayer

const SPEED = 6.5
const JUMP_VELOCITY = 5.5
const GRAVITY = 15.0

# Set by the server when spawning
@export var player_id: int = 1
@export var skin_id: int = 1:
	set(value):
		skin_id = value
		_update_skin()

@onready var input_synchronizer: MultiplayerSynchronizer = $InputSynchronizer
@onready var server_synchronizer: MultiplayerSynchronizer = $ServerSynchronizer
@onready var visuals: Node3D = $Visuals
@onready var spring_arm: SpringArm3D = $SpringArm3D
@onready var camera: Camera3D = $SpringArm3D/Camera3D
@onready var gesture_manager: Node = $GestureManager

# Input properties (Synced Client -> Server)
@export var input_dir: Vector2 = Vector2.ZERO
@export var input_jump: bool = false
@export var cam_rotation: float = 0.0

# Auto-Jump (Copied from previous implementation)
var ray_knee: RayCast3D
var ray_floor: RayCast3D

# Spells
var spells = {
	"kinetic_pulse": preload("res://source/common/gameplay/combat/projectiles/projectile_kinetic.tscn"),
	"aegis": preload("res://source/common/gameplay/combat/projectiles/projectile_aegis.tscn"),
	"pyroclasm": preload("res://source/common/gameplay/combat/projectiles/projectile_pyroclasm.tscn"),
	"stasis": preload("res://source/common/gameplay/combat/projectiles/projectile_stasis.tscn")
}

func _enter_tree():
	var id_int = str(name).to_int()
	set_multiplayer_authority(id_int)
	
	# Register with InstanceClient if we are on the client
	if not multiplayer.is_server() and InstanceClient.current:
		InstanceClient.current.players_by_peer_id[id_int] = self

func _exit_tree():
	# Unregister from InstanceClient
	if not multiplayer.is_server() and InstanceClient.current:
		var id_int = str(name).to_int()
		if InstanceClient.current.players_by_peer_id.has(id_int):
			InstanceClient.current.players_by_peer_id.erase(id_int)

func _ready():
	_update_skin()
	if is_multiplayer_authority() and multiplayer.get_unique_id() == str(name).to_int():
		if camera: camera.current = true
		Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
		
		# Connect Gesture Manager signal
		
		# Connect Gesture Manager signal
		if gesture_manager:
			gesture_manager.spell_cast.connect(_on_gesture_cast)
	else:
		if camera: camera.current = false
		set_process_unhandled_input(false)
	
	_setup_auto_jump()

func _update_skin():
	if not is_inside_tree(): return
	if not visuals: return
	var mesh_instance = visuals.get_node_or_null("CharacterModel")
	if not mesh_instance: return
	
	var mat = StandardMaterial3D.new()
	match skin_id:
		0: mat.albedo_color = Color.RED
		1: mat.albedo_color = Color.GREEN
		2: mat.albedo_color = Color.BLUE
		_: mat.albedo_color = Color.WHITE
	
	mesh_instance.material_override = mat

func _on_gesture_cast(gesture_id: StringName, _aim_dir: Vector3):
	# Client detects gesture -> Send RPC to server to spawn projectile
	rpc_cast_spell.rpc_id(1, String(gesture_id), spring_arm.rotation.y)

@rpc("any_peer", "call_remote", "reliable")
func rpc_cast_spell(gesture_id: String, aim_yaw: float):
	if not multiplayer.is_server(): return
	
	print("Server: Casting spell %s" % gesture_id)
	
	if spells.has(gesture_id):
		var proj_scene = spells[gesture_id]
		var proj = proj_scene.instantiate()
		
		# Calculate spawn pos (offset forward)
		var forward = Vector3.FORWARD.rotated(Vector3.UP, aim_yaw)
		proj.position = global_position + Vector3(0, 1.0, 0) + (forward * 1.0)
		proj.direction = forward
		proj.owner_id = player_id
		
		get_parent().add_child(proj)

func _physics_process(delta):
	if multiplayer.is_server():
		_process_server_physics(delta)
	elif is_multiplayer_authority():
		_process_client_input()

func _process_client_input():
	input_dir = Input.get_vector("move_left", "move_right", "move_forward", "move_back")
	input_jump = Input.is_action_just_pressed("jump")
	cam_rotation = spring_arm.rotation.y

func _process_server_physics(delta):
	if not is_on_floor():
		velocity.y -= GRAVITY * delta

	var direction = (Vector3(input_dir.x, 0, input_dir.y)).rotated(Vector3.UP, cam_rotation).normalized()
	
	if direction:
		velocity.x = direction.x * SPEED
		velocity.z = direction.z * SPEED
		rotation.y = lerp_angle(rotation.y, atan2(direction.x, direction.z), 10 * delta)
	else:
		velocity.x = move_toward(velocity.x, 0, SPEED)
		velocity.z = move_toward(velocity.z, 0, SPEED)

	if input_jump or (is_on_floor() and _check_auto_jump(direction)):
		velocity.y = JUMP_VELOCITY
		input_jump = false

	move_and_slide()

func _unhandled_input(event: InputEvent) -> void:
	if not is_multiplayer_authority(): return
	
	if event is InputEventMouseMotion and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
		spring_arm.rotation.x = clamp(spring_arm.rotation.x - event.relative.y * 0.005, -PI / 2.0, PI / 4.0)
		spring_arm.rotation.y -= event.relative.x * 0.005

func _setup_auto_jump() -> void:
	ray_knee = RayCast3D.new()
	ray_knee.position = Vector3(0, 0.5, 0)
	ray_knee.target_position = Vector3(0, 0, -0.6)
	ray_knee.enabled = true
	add_child(ray_knee)
	
	ray_floor = RayCast3D.new()
	ray_floor.position = Vector3(0, 0.1, -0.6)
	ray_floor.target_position = Vector3(0, -1.2, 0)
	ray_floor.enabled = true
	add_child(ray_floor)

func _check_auto_jump(move_dir: Vector3) -> bool:
	if velocity.y > 0 or move_dir.length() < 0.1: return false
	
	var local_dir = to_local(global_position + move_dir).normalized()
	ray_knee.target_position = local_dir * 0.6
	ray_floor.position = Vector3(0, 0.1, 0) + (local_dir * 0.6)
	
	ray_knee.force_raycast_update()
	ray_floor.force_raycast_update()
	
	if not ray_knee.is_colliding() and ray_floor.is_colliding():
		var hit_point = ray_floor.get_collision_point()
		var height_diff = hit_point.y - global_position.y
		if height_diff > -1.0 and height_diff < 0.5:
			return true
	return falseres://source/common/gameplay/characters/player/net_player.gd.uid
res://source/common/gameplay/characters/player/net_player.tscn

--- res://source/common/gameplay/characters/player/net_player.tscn ---
[gd_scene load_steps=6 format=3 uid="uid://net_player_v1"]

[ext_resource type="Script" path="res://source/common/gameplay/characters/player/net_player.gd" id="1_script"]
[ext_resource type="Script" path="res://source/client/local_player/gesture_manager.gd" id="2_gesture"]

[sub_resource type="CapsuleShape3D" id="CapsuleShape3D_body"]
radius = 0.4
height = 1.8

[sub_resource type="BoxMesh" id="BoxMesh_visual"]
size = Vector3(0.8, 1.8, 0.8)

[sub_resource type="SceneReplicationConfig" id="SceneReplicationConfig_input"]
properties/0/path = NodePath(".:input_dir")
properties/0/spawn = true
properties/0/replication_mode = 1
properties/1/path = NodePath(".:input_jump")
properties/1/spawn = true
properties/1/replication_mode = 1
properties/2/path = NodePath(".:cam_rotation")
properties/2/spawn = true
properties/2/replication_mode = 1

[sub_resource type="SceneReplicationConfig" id="SceneReplicationConfig_server"]
properties/0/path = NodePath(".:position")
properties/0/spawn = true
properties/0/replication_mode = 1
properties/1/path = NodePath(".:rotation")
properties/1/spawn = true
properties/1/replication_mode = 1
properties/2/path = NodePath(".:velocity")
properties/2/spawn = true
properties/2/replication_mode = 1
properties/3/path = NodePath(".:skin_id")
properties/3/spawn = true
properties/3/replication_mode = 1

[node name="NetPlayer" type="CharacterBody3D"]
collision_layer = 2
collision_mask = 7
script = ExtResource("1_script")

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0.9, 0)
shape = SubResource("CapsuleShape3D_body")

[node name="Visuals" type="Node3D" parent="."]

[node name="CharacterModel" type="MeshInstance3D" parent="Visuals"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0.9, 0)
mesh = SubResource("BoxMesh_visual")

[node name="SpringArm3D" type="SpringArm3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 2.5, 0)
rotation = Vector3(-0.4, 0, 0)
spring_length = 6.0
margin = 0.2

[node name="Camera3D" type="Camera3D" parent="SpringArm3D"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0)

[node name="InputSynchronizer" type="MultiplayerSynchronizer" parent="."]
replication_config = SubResource("SceneReplicationConfig_input")

[node name="ServerSynchronizer" type="MultiplayerSynchronizer" parent="."]
replication_config = SubResource("SceneReplicationConfig_server")

[node name="GestureManager" type="Node" parent="."]
script = ExtResource("2_gesture")
res://source/common/gameplay/characters/player/player_resource.gd

--- res://source/common/gameplay/characters/player/player_resource.gd ---
class_name PlayerResource
extends Resource


const ATTRIBUTE_POINTS_PER_LEVEL: int = 3

const BASE_STATS: Dictionary[StringName, float] = {
	Stat.HEALTH_MAX: 100.0,
	Stat.HEALTH: 100.0,
	Stat.AD: 20.0,
	Stat.ARMOR: 15.0,
	Stat.MR: 15.0,
	Stat.MOVE_SPEED: 75.0,
	Stat.ATTACK_SPEED: 0.8
}

@export var player_id: int
@export var account_name: String

@export var display_name: String = "Player"
@export var skin_id: int = 1 # Default skin
@export var house: StringName = &""

@export var golds: int
@export var inventory: Dictionary

@export var attributes: Dictionary
@export var available_attributes_points: int = 0
# Nivel fijo; no hay progresin RPG tradicional.
@export var level: int = 1

@export var club: Club
##
@export var server_roles: Dictionary

## Current Network ID
var current_peer_id: int

var stats: Dictionary


func init(
	_player_id: int,
	_account_name: String,
	_display_name: String = display_name,
	_skin_id: int = skin_id
) -> void:
	player_id = _player_id
	account_name = _account_name
	display_name = _display_name
	skin_id = _skin_id


func level_up() -> void:
	# Sin progresin de nivel en este diseo.
	pass
res://source/common/gameplay/characters/player/player_resource.gd.uid
res://source/common/gameplay/combat/ability/ability.gd

--- res://source/common/gameplay/combat/ability/ability.gd ---
class_name AbilityResource
extends Resource


@export var name: String
@export var cooldown: float = 1.0


var last_action_time: float = -INF


func use_ability(_entity: CharacterBody3D, _direction: Vector3) -> void:
	pass
#func use_ability(_entity: CharacterBody3D, _payload: Dictionary) -> void:

func can_use() -> bool:
	return (Time.get_ticks_msec() / 1000.0) - last_action_time >= cooldown


func mark_used():
	last_action_time = Time.get_ticks_msec() / 1000.0
res://source/common/gameplay/combat/ability/ability.gd.uid
res://source/common/gameplay/combat/attack/attack.gd

--- res://source/common/gameplay/combat/attack/attack.gd ---
class_name Attack


var source: CharacterBody3D
var damage: float


func _init(_source: CharacterBody3D, _damage: float) -> void:
	source = _source
	damage = _damage
res://source/common/gameplay/combat/attack/attack.gd.uid
res://source/common/gameplay/combat/attributes/attributes_map.gd

--- res://source/common/gameplay/combat/attributes/attributes_map.gd ---
class_name AttributeMap


const VITALITY: Dictionary[StringName, float] = {
	Stat.HEALTH: 5.0,
	Stat.HEALTH_MAX: 5.0
}

const STRENGHT: Dictionary[StringName, float] = {
	Stat.AD: 2.0,
}

const INTELLIGENCE: Dictionary[StringName, float] = {
	Stat.AP: 2.0,
}

const SPIRIT: Dictionary[StringName, float] = {
	Stat.MANA: 10.0,
	Stat.MANA_MAX: 10.0,
	Stat.ENERGY: 10.0,
}

const MAGICAL_DEFENSE: Dictionary[StringName, float] = {
	Stat.MR: 1.5,
	Stat.HEALTH: 2.0,
	Stat.HEALTH_MAX: 2.0
}

const PHYSICAL_DEFENSE: Dictionary[StringName, float] = {
	Stat.ARMOR: 1.5,
	Stat.HEALTH: 2.0,
	Stat.HEALTH_MAX: 2.0
}


const CONDITION: Dictionary[StringName, float] = {
	&"tenacity": 3.0,#Stat.TENACITY
	Stat.ARMOR: 1.0,
	Stat.MR: 1.0,
	Stat.HEALTH: 2.0,
	Stat.HEALTH_MAX: 2.0
}


const AGILITY: Dictionary[StringName, float] = {
	Stat.MOVE_SPEED: 4,
	Stat.ATTACK_SPEED: 0.1
}

static func attr_to_stats(attributes: Dictionary) -> Dictionary[StringName, float]:
	var stats: Dictionary[StringName, float] = {}
	for attribute_name: StringName in attributes:
		var amount: int = attributes[attribute_name]
		match attribute_name:
			# Move to a proper mapper ?
			&"vitality":
				add_attribute_to_stats(VITALITY, amount, stats)
			&"strenght":
				add_attribute_to_stats(STRENGHT, amount, stats)
			&"intelligence":
				add_attribute_to_stats(INTELLIGENCE, amount, stats)
			&"spirit":
				add_attribute_to_stats(SPIRIT, amount, stats)
			&"agility":
				add_attribute_to_stats(AGILITY, amount, stats)
			#...
				#...
	return stats


static func add_attribute_to_stats(
	attribute: Dictionary[StringName, float],
	amount: int,
	stats: Dictionary[StringName, float]
) -> void:
	for stat_name: StringName in attribute:
		if stats.has(stat_name):
			stats[stat_name] += attribute[stat_name] * amount
		else:
			stats[stat_name] = attribute[stat_name] * amount
res://source/common/gameplay/combat/attributes/attributes_map.gd.uid
res://source/common/gameplay/combat/attributes/stat.gd

--- res://source/common/gameplay/combat/attributes/stat.gd ---
class_name Stat


const HEALTH: StringName = &"health"
const HEALTH_MAX: StringName = &"health_max"

const MANA: StringName = &"mana"
const MANA_MAX: StringName = &"mana_max"

const ENERGY: StringName = &"energy"
const ENERGY_MAX: StringName = &"energy_max"

const SHIELD: StringName = &"shield"

## Physical Resistance
const ARMOR: StringName = &"armor"
## Magic Resistance
const MR: StringName = &"mr"

## Attack Damage
const AD: StringName = &"ad"
## Ability Power
const AP: StringName = &"ap"

const ATTACK_SPEED: StringName = &"attack_speed"
const ATTACK_RANGE: StringName = &"attack_range"

const MOVE_SPEED: StringName = &"move_speed"

const CRIT_CHANCE: StringName = &"crit_chance"
const CRIT_DAMAGE: StringName = &"crit_damage"
const ABILITY_HASTE: StringName = &"ability_haste"

enum Id {
	HEALTH,
	HEALTH_MAX,

	MANA,
	MANA_MAX,

	ENERGY,
	ENERGY_MAX,

	SHIELD,

	ARMOR,# Physical resistance
	MR,# Magic resistance

	AD,# Attack Damage
	AP,# Ability Power

	ATTACK_SPEED,
	ATTACK_RANGE,

	MOVE_SPEED,

	CRIT_CHANCE,
	CRIT_DAMAGE,

	ABILITY_HASTE,
}
res://source/common/gameplay/combat/attributes/stat.gd.uid
res://source/common/gameplay/combat/attributes/stat_modifier.gd

--- res://source/common/gameplay/combat/attributes/stat_modifier.gd ---
class_name StatModifier
extends Resource


@export var stat_id: Stat.Id = Stat.Id.HEALTH
@export var value: float = 0.0
res://source/common/gameplay/combat/attributes/stat_modifier.gd.uid
res://source/common/gameplay/combat/components/ability_system_component.gd

--- res://source/common/gameplay/combat/components/ability_system_component.gd ---
class_name AbilitySystemComponent
extends Node

# Removed StateSynchronizer dependency
# @export var synchronizer: Node

var modifiers: Array[StatModifier]
var attributes: Attributes = Attributes.new()

class Attributes:
	var attributes: Dictionary
	var watchers: Dictionary
	
	func _set(property: StringName, value: Variant) -> bool:
		if not typeof(value) == TYPE_FLOAT:
			return false
		attributes[property] = value # Corrected syntax
		for watcher: Callable in watchers.get(property, []):
				watcher.call(value)
		return true

	func _get(property: StringName) -> Variant:
		return attributes.get(property, 0.0)

	func connect_watcher(property: StringName, to_connect: Callable) -> void:
		if watchers.has(property):
			watchers[property].append(to_connect)
		else:
			watchers[property] = [to_connect]
		to_connect.call(attributes.get(property, 0.0))

static func attribute_path(attribute_name: StringName) -> String:
	return "AbilitySystemComponent:attributes:%s" % attribute_name

func _ready() -> void:
	pass

func ensure_attribute(attribute_name: StringName, value: float) -> void:
	attributes._set(attribute_name, value)
	# TODO: Implement native replication for attributes (e.g. using a specific MultiplayerSynchronizer config)

func get_attribute_value(attribute_name: StringName) -> float:
	return attributes._get(attribute_name)

func set_attribute_value(attribute_name: StringName, value: float, source: StringName = &"") -> void:
	ensure_attribute(attribute_name, value)

# Gameplay
# Dead simple logic for now
func apply_damage(damage: float) -> void:
	set_attribute_value(
		Stat.HEALTH,
		get_attribute_value(Stat.HEALTH) - damage
	)

func add_modifier(modifier: StatModifier) -> void:
	modifiers.append(modifier)

func remove_modifier(modifier: StatModifier) -> void:
	modifiers.erase(modifier)

func recalc_modifiers() -> void:
	passres://source/common/gameplay/combat/components/ability_system_component.gd.uid
res://source/common/gameplay/combat/components/equipment_component.gd

--- res://source/common/gameplay/combat/components/equipment_component.gd ---
class_name EquipmentComponent
extends Node

# Componente simplificado para Cliffwald.
# Ya no gestiona lgica de armas (varitas son fijas).
# En el futuro gestionar armaduras/tnicas (GearItem).

@export var character: Node 
var _slots: Dictionary = {}

func _ready() -> void:
	pass

# Funciones 'dummy' para mantener compatibilidad si algn sistema viejo llama aqu
func can_use(_slot: StringName, _index: int) -> bool:
	return false

func equip(slot: StringName, item: Resource) -> bool:
	_slots[slot] = item
	print("Equipado cosmtico en: ", slot)
	return true
	
func unequip(slot: StringName) -> void:
	_slots.erase(slot)
res://source/common/gameplay/combat/components/equipment_component.gd.uid
res://source/common/gameplay/combat/effect_spec.gd

--- res://source/common/gameplay/combat/effect_spec.gd ---
class_name EffectSpec
extends Resource


@export var tags: PackedStringArray = []

var magnitudes: Dictionary = {}
var ignore_layers: PackedStringArray = []
var meta: Dictionary = {}


static func damage(amount: float, _tags: PackedStringArray = [], _meta: Dictionary = {}) -> EffectSpec:
	var s: EffectSpec = EffectSpec.new()
	s.tags = _tags
	s.magnitudes[StringName("damage")] = amount
	s.meta = _meta
	return s


static func heal(amount: float, _tags: PackedStringArray = [], _meta: Dictionary = {}) -> EffectSpec:
	var s: EffectSpec = EffectSpec.new()
	s.tags = _tags
	s.magnitudes[StringName("heal")] = amount
	s.meta = _meta
	return s
res://source/common/gameplay/combat/effect_spec.gd.uid
res://source/common/gameplay/combat/gameplay_event.gd

--- res://source/common/gameplay/combat/gameplay_event.gd ---
class_name GameplayEvent
extends RefCounted


var spec: EffectSpec
var source: AbilitySystemComponent = null
var target: AbilitySystemComponent = null
var amount: float = 0.0
var canceled: bool = false


func mod_mul(f: float) -> void: amount *= f
func mod_add(x: float) -> void: amount += x
func cancel() -> void: canceled = true
res://source/common/gameplay/combat/gameplay_event.gd.uid
res://source/common/gameplay/combat/projectiles/base_projectile.gd

--- res://source/common/gameplay/combat/projectiles/base_projectile.gd ---
extends Node3D
class_name BaseProjectile

@export var speed: float = 20.0
@export var damage: float = 10.0
@export var lifetime: float = 3.0
@export var effect_type: String = "Damage" # Damage, Stun, Shield

var direction: Vector3 = Vector3.FORWARD
var owner_id: int = -1

func _ready() -> void:
	set_as_top_level(true) # Desacoplar del padre para movimiento libre
	
	# Auto-destroy after lifetime (Server only handling cleanup usually, but client needs to know)
	if multiplayer.is_server():
		await get_tree().create_timer(lifetime).timeout
		queue_free()

func _physics_process(delta: float) -> void:
	position += direction * speed * delta

func _on_body_entered(body: Node) -> void:
	if not multiplayer.is_server(): return
	
	# Ignore self collision via owner_id check logic if needed, 
	# but simpler is to use collision layers (Layer 3: Spells)
	
	if body.has_method("take_damage"):
		body.take_damage(damage, effect_type)
		queue_free()
	elif body is StaticBody3D or body is CSGShape3D:
		# Wall hit
		queue_free()
res://source/common/gameplay/combat/projectiles/base_projectile.gd.uid
res://source/common/gameplay/combat/projectiles/projectile_aegis.tscn

--- res://source/common/gameplay/combat/projectiles/projectile_aegis.tscn ---
[gd_scene load_steps=6 format=3 uid="uid://proj_aegis"]

[ext_resource type="Script" path="res://source/common/gameplay/combat/projectiles/base_projectile.gd" id="1_script"]

[sub_resource type="StandardMaterial3D" id="Mat_Proj"]
albedo_color = Color(0, 0.5, 1, 1)
emission_enabled = true
emission = Color(0, 0.5, 1, 1)
emission_energy_multiplier = 2.0

[sub_resource type="SphereMesh" id="SphereMesh_v1"]
radius = 0.3
height = 0.6
material = SubResource("Mat_Proj")

[sub_resource type="SphereShape3D" id="Shape_Col"]
radius = 0.3

[sub_resource type="SceneReplicationConfig" id="Rep_Config"]
properties/0/path = NodePath(".:position")
properties/0/spawn = true
properties/0/replication_mode = 1
properties/1/path = NodePath(".:direction")
properties/1/spawn = true
properties/1/replication_mode = 1

[node name="Aegis" type="Area3D"]
collision_layer = 4
collision_mask = 3
script = ExtResource("1_script")
speed = 0.0
damage = 0.0

[node name="MeshInstance3D" type="MeshInstance3D" parent="."]
mesh = SubResource("SphereMesh_v1")

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
shape = SubResource("Shape_Col")

[node name="MultiplayerSynchronizer" type="MultiplayerSynchronizer" parent="."]
replication_config = SubResource("Rep_Config")
res://source/common/gameplay/combat/projectiles/projectile_kinetic.tscn

--- res://source/common/gameplay/combat/projectiles/projectile_kinetic.tscn ---
[gd_scene load_steps=6 format=3 uid="uid://proj_kinetic"]

[ext_resource type="Script" path="res://source/common/gameplay/combat/projectiles/base_projectile.gd" id="1_script"]

[sub_resource type="StandardMaterial3D" id="Mat_Proj"]
albedo_color = Color(1, 1, 1, 1)
emission_enabled = true
emission = Color(1, 1, 1, 1)
emission_energy_multiplier = 2.0

[sub_resource type="SphereMesh" id="SphereMesh_v1"]
radius = 0.3
height = 0.6
material = SubResource("Mat_Proj")

[sub_resource type="SphereShape3D" id="Shape_Col"]
radius = 0.3

[sub_resource type="SceneReplicationConfig" id="Rep_Config"]
properties/0/path = NodePath(".:position")
properties/0/spawn = true
properties/0/replication_mode = 1
properties/1/path = NodePath(".:direction")
properties/1/spawn = true
properties/1/replication_mode = 1

[node name="Kinetic" type="Area3D"]
collision_layer = 4
collision_mask = 3
script = ExtResource("1_script")
speed = 25.0
damage = 10.0

[node name="MeshInstance3D" type="MeshInstance3D" parent="."]
mesh = SubResource("SphereMesh_v1")

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
shape = SubResource("Shape_Col")

[node name="MultiplayerSynchronizer" type="MultiplayerSynchronizer" parent="."]
replication_config = SubResource("Rep_Config")
res://source/common/gameplay/combat/projectiles/projectile_pyroclasm.tscn

--- res://source/common/gameplay/combat/projectiles/projectile_pyroclasm.tscn ---
[gd_scene load_steps=6 format=3 uid="uid://proj_pyroclasm"]

[ext_resource type="Script" path="res://source/common/gameplay/combat/projectiles/base_projectile.gd" id="1_script"]

[sub_resource type="StandardMaterial3D" id="Mat_Proj"]
albedo_color = Color(1, 0.2, 0, 1)
emission_enabled = true
emission = Color(1, 0.2, 0, 1)
emission_energy_multiplier = 2.0

[sub_resource type="PrismMesh" id="PrismMesh_v1"]
size = Vector3(0.5, 0.5, 0.5)
material = SubResource("Mat_Proj")

[sub_resource type="SphereShape3D" id="Shape_Col"]
radius = 0.3

[sub_resource type="SceneReplicationConfig" id="Rep_Config"]
properties/0/path = NodePath(".:position")
properties/0/spawn = true
properties/0/replication_mode = 1
properties/1/path = NodePath(".:direction")
properties/1/spawn = true
properties/1/replication_mode = 1

[node name="Pyroclasm" type="Area3D"]
collision_layer = 4
collision_mask = 3
script = ExtResource("1_script")
speed = 15.0
damage = 30.0

[node name="MeshInstance3D" type="MeshInstance3D" parent="."]
mesh = SubResource("PrismMesh_v1")

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
shape = SubResource("Shape_Col")

[node name="MultiplayerSynchronizer" type="MultiplayerSynchronizer" parent="."]
replication_config = SubResource("Rep_Config")
res://source/common/gameplay/combat/projectiles/projectile_stasis.tscn

--- res://source/common/gameplay/combat/projectiles/projectile_stasis.tscn ---
[gd_scene load_steps=6 format=3 uid="uid://proj_stasis"]

[ext_resource type="Script" path="res://source/common/gameplay/combat/projectiles/base_projectile.gd" id="1_script"]

[sub_resource type="StandardMaterial3D" id="Mat_Proj"]
albedo_color = Color(1, 1, 0, 1)
emission_enabled = true
emission = Color(1, 1, 0, 1)
emission_energy_multiplier = 2.0

[sub_resource type="BoxMesh" id="BoxMesh_v1"]
size = Vector3(0.5, 0.5, 0.5)
material = SubResource("Mat_Proj")

[sub_resource type="SphereShape3D" id="Shape_Col"]
radius = 0.3

[sub_resource type="SceneReplicationConfig" id="Rep_Config"]
properties/0/path = NodePath(".:position")
properties/0/spawn = true
properties/0/replication_mode = 1
properties/1/path = NodePath(".:direction")
properties/1/spawn = true
properties/1/replication_mode = 1

[node name="Stasis" type="Area3D"]
collision_layer = 4
collision_mask = 3
script = ExtResource("1_script")
speed = 30.0
damage = 5.0

[node name="MeshInstance3D" type="MeshInstance3D" parent="."]
mesh = SubResource("BoxMesh_v1")

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
shape = SubResource("Shape_Col")

[node name="MultiplayerSynchronizer" type="MultiplayerSynchronizer" parent="."]
replication_config = SubResource("Rep_Config")
res://source/common/gameplay/combat/team/team_component.gd

--- res://source/common/gameplay/combat/team/team_component.gd ---
class_name Team


var team_id: int
var team_name: String
var team_color: Color


func _init(_team_id: int, _team_name: String, _team_color: Color) -> void:
	team_id = _team_id
	team_name = _team_name
	team_color = _team_color
res://source/common/gameplay/combat/team/team_component.gd.uid
res://source/common/gameplay/items/consumables/health_potion.tres
res://source/common/gameplay/items/consumable_item.gd

--- res://source/common/gameplay/items/consumable_item.gd ---
class_name ConsumableItem
extends Item


#@export var effects: Array[GameplayEffect]
@export var shared_cooldown_ms: int = 1500
@export var cooldown_category: StringName = &"potion"
## initial charges per single copy if 1 can use the potion one time, if 2 can use the potion 2 times for example.
@export var default_charges: int = 1


func can_use(player: Node) -> bool:
	return false
	#var charges := stack.get_int(&"charges", default_charges)
	#if charges <= 0:
		#return false
	#if asc.has_method("cooldown_ready"):
		#return asc.cooldown_ready(cooldown_category)
	#return true


func on_use(character: Node) -> void:
	pass
	#for effect: GameplayEffect in effects:
		#effect.on_added(character.ability_system_component)
#func on_use(asc: Node, stack: ItemStack) -> bool:
	#if not can_use(asc, stack):
		#return false
	#for e in effects:
		#asc.add_effect(e)
	#if asc.has_method("trigger_cooldown"):
		#asc.trigger_cooldown(cooldown_category, shared_cooldown_ms)
	## decrement charges (per-copy state lives in stack.data)
	#var charges := stack.get_int(&"charges", default_charges)
	#charges -= 1
	#stack.set_int(&"charges", max(0, charges))
	# If stackable, the inventory system can also reduce stack.count
	#return true
res://source/common/gameplay/items/consumable_item.gd.uid
res://source/common/gameplay/items/gears/copper_ring.tres
res://source/common/gameplay/items/gears/thornmail.tres
res://source/common/gameplay/items/gear_item.gd

--- res://source/common/gameplay/items/gear_item.gd ---
class_name GearItem
extends Item


@export var slot: ItemSlot
@export_range(0, 99, 1.0, "suffix:lvl") var required_level: int = 0

## Main Stats (Base stats)
@export var base_modifiers: Array[StatModifier]


func can_equip(player: Node) -> bool:
	if player.player_resource:
		return slot.is_unlocked_for(player.player_resource) and player.player_resource.level >= required_level
	return false


func on_equip(character: Node) -> void:
	for modifier: StatModifier in base_modifiers:
		character.ability_system_component.add_modifier(modifier)


func on_unequip(character: Node) -> void:
	for modifier: StatModifier in base_modifiers:
		character.ability_system_component.remove_modifier_by_id(modifier.runtime_id)
res://source/common/gameplay/items/gear_item.gd.uid
res://source/common/gameplay/items/item.gd

--- res://source/common/gameplay/items/item.gd ---
class_name Item
extends Resource

# Definition
@export var item_name: StringName = &"ItemDefault"

# CAMBIO: Quitamos el preload de la imagen borrada y lo dejamos null
@export var item_icon: Texture2D = null 

@export_multiline var description: String

# Trading / Economy
@export var can_trade: bool = false
@export var can_sell: bool = false
@export var minimum_price: int = 0

# Inventory
@export_range(0, 99, 1.0) var stack_limit: int = 0
@export var tags: PackedStringArray = []

func is_stackable() -> bool:
	return stack_limit != 1

@warning_ignore("unused_parameter")
func can_use(player: Node) -> bool:
	return false

@warning_ignore("unused_parameter")
func on_use(character: Node) -> void:
	pass

@warning_ignore("unused_parameter")
func can_equip(player: Node) -> bool:
	return false

@warning_ignore("unused_parameter")
func on_equip(character: Node) -> void:
	pass

@warning_ignore("unused_parameter")
func on_unequip(character: Node) -> void:
	pass
res://source/common/gameplay/items/item.gd.uid
res://source/common/gameplay/items/item_slot/item_slot.gd

--- res://source/common/gameplay/items/item_slot/item_slot.gd ---
class_name ItemSlot
extends Resource


# &"Weapon", &"Helmet", ...
## Should be constant, never changed like an unique identifier.
@export var key: StringName

## Can be translated, means to be used in UI.
@export var display_name: String

@export var unlock_rule: SlotUnlockRule

## Option icon for UI
@export var icon: Texture2D

## Avoid keeping runtime flag on a resource, may move it later.
var unlocked: bool = false


func is_unlocked_for(player: PlayerResource) -> bool:
	return unlock_rule and unlock_rule.is_unlocked(player)
res://source/common/gameplay/items/item_slot/item_slot.gd.uid
res://source/common/gameplay/items/item_slot/item_slot_unlock_rule.gd

--- res://source/common/gameplay/items/item_slot/item_slot_unlock_rule.gd ---
class_name SlotUnlockRule
extends Resource


enum Kind {
	ALWAYS,
	PLAYER_LEVEL,
	QUEST_COMPLETED,
	MANUAL_FLAG
}

@export var kind: Kind = Kind.ALWAYS
@export var level: int = 0
@export var quest_id: int = 0
@export var flag_key: StringName = &""


func is_unlocked(player: PlayerResource) -> bool:
	match kind:
		Kind.ALWAYS: return true
		Kind.PLAYER_LEVEL: return player.level >= level
		# Later ?
		#Kind.QUEST_COMPLETED: return player.has_completed_quest(quest_id)
		# Later ?
		#Kind.MANUAL_FLAG: return player.progress_flags.has(flag_key)
		_: return false
res://source/common/gameplay/items/item_slot/item_slot_unlock_rule.gd.uid
res://source/common/gameplay/items/item_slot/slots/helmet.tres
res://source/common/gameplay/items/item_slot/slots/relic.tres
res://source/common/gameplay/items/item_slot/slots/ring.tres
res://source/common/gameplay/items/item_slot/slots/torso.tres
res://source/common/gameplay/items/item_slot/slots/weapon.tres
res://source/common/gameplay/items/materials/bone.tres
res://source/common/gameplay/items/material_item.gd

--- res://source/common/gameplay/items/material_item.gd ---
class_name MaterialItem
extends Item
# Pure data item for crafting; no runtime hooks needed (not yet?).
# Keep recipes & crafting logic elsewhere.
res://source/common/gameplay/items/material_item.gd.uid
res://source/common/gameplay/items/quest_item.gd

--- res://source/common/gameplay/items/quest_item.gd ---
class_name QuestItem
extends Item

@export var quest_id: int = 0
@export var auto_bind: bool = true


func _init() -> void:
	can_trade = false
	can_sell = false
	stack_limit = 1
	#inventory_tab = Item.InventoryTab.OTHER
res://source/common/gameplay/items/quest_item.gd.uid
res://source/common/gameplay/items/weapon_item.gd

--- res://source/common/gameplay/items/weapon_item.gd ---
class_name WeaponItem
extends Item

# Varita puramente esttica; no hay equipamiento ni lgica de combate basada en armas.
@export var wand_scene: PackedScene

func on_equip(_character: Node) -> void:
	pass


func on_unequip(_character: Node) -> void:
	pass
res://source/common/gameplay/items/weapon_item.gd.uid
res://source/common/gameplay/maps/castle_generator.gd.uid
res://source/common/gameplay/maps/castle_greybox.tscn

--- res://source/common/gameplay/maps/castle_greybox.tscn ---
[gd_scene load_steps=7 format=3 uid="uid://castle_greybox_v3"]

[sub_resource type="StandardMaterial3D" id="Mat_Floor"]
albedo_color = Color(0.15, 0.15, 0.15, 1)

[sub_resource type="StandardMaterial3D" id="Mat_Wall"]
albedo_color = Color(0.6, 0.6, 0.6, 1)

[sub_resource type="StandardMaterial3D" id="Mat_Bed"]
albedo_color = Color(0.8, 0.2, 0.2, 1)

[sub_resource type="StandardMaterial3D" id="Mat_Table"]
albedo_color = Color(0.4, 0.2, 0.1, 1)

[sub_resource type="StandardMaterial3D" id="Mat_Crafting"]
albedo_color = Color(0.2, 0.8, 0.2, 1)

[sub_resource type="StandardMaterial3D" id="Mat_Glass"]
transparency = 1
albedo_color = Color(0.4, 0.7, 1.0, 0.3)

[sub_resource type="NavigationMesh" id="NavigationMesh_v1"]
geometry_parsed_geometry_type = 1
geometry_source_geometry_mode = 0
agent_height = 1.8
agent_radius = 0.4

[node name="CastleGreybox" type="NavigationRegion3D"]
navigation_mesh = SubResource("NavigationMesh_v1")

[node name="CastleCSG" type="CSGCombiner3D" parent="."]
use_collision = true

[node name="Floor_9714" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 4.5, 0)

size = Vector3(30, 1, 50)
material = SubResource("Mat_Floor")

[node name="Wall_N_d447" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 11.0, -25.0)

size = Vector3(30, 12, 1.0)
material = SubResource("Mat_Wall")

[node name="Wall_S_d99f" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 11.0, 25.0)

size = Vector3(30, 12, 1.0)
material = SubResource("Mat_Wall")

[node name="Wall_E_e210" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 15.0, 11.0, 0)

size = Vector3(1.0, 12, 50)
material = SubResource("Mat_Wall")

[node name="Wall_W_e599" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -15.0, 11.0, 0)

size = Vector3(1.0, 12, 50)
material = SubResource("Mat_Wall")

[node name="Ceiling_adf6" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 17.5, 0)

size = Vector3(30, 1, 50)
material = SubResource("Mat_Wall")

[node name="Table_Ignis_36a1" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 8, 5.5, 0)

size = Vector3(1.5, 1, 30)
material = SubResource("Mat_Table")

[node name="Table_Axiom_fd8b" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 3, 5.5, 0)

size = Vector3(1.5, 1, 30)
material = SubResource("Mat_Table")

[node name="Table_Vesper_6c5e" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -3, 5.5, 0)

size = Vector3(1.5, 1, 30)
material = SubResource("Mat_Table")

[node name="Table_Staff_9263" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -8, 5.5, 0)

size = Vector3(1.5, 1, 30)
material = SubResource("Mat_Table")

[node name="WindowCut_3b10" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 15, 8.0, -20)
operation = 2
size = Vector3(4.0, 3.0, 2.0)
material = SubResource("Mat_Glass")

[node name="WindowCut_23a7" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -15, 8.0, -20)
operation = 2
size = Vector3(4.0, 3.0, 2.0)
material = SubResource("Mat_Glass")

[node name="WindowCut_a97d" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 15, 8.0, -10)
operation = 2
size = Vector3(4.0, 3.0, 2.0)
material = SubResource("Mat_Glass")

[node name="WindowCut_d90a" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -15, 8.0, -10)
operation = 2
size = Vector3(4.0, 3.0, 2.0)
material = SubResource("Mat_Glass")

[node name="WindowCut_dcbc" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 15, 8.0, 0)
operation = 2
size = Vector3(4.0, 3.0, 2.0)
material = SubResource("Mat_Glass")

[node name="WindowCut_cf39" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -15, 8.0, 0)
operation = 2
size = Vector3(4.0, 3.0, 2.0)
material = SubResource("Mat_Glass")

[node name="WindowCut_a834" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 15, 8.0, 10)
operation = 2
size = Vector3(4.0, 3.0, 2.0)
material = SubResource("Mat_Glass")

[node name="WindowCut_7709" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -15, 8.0, 10)
operation = 2
size = Vector3(4.0, 3.0, 2.0)
material = SubResource("Mat_Glass")

[node name="WindowCut_fc93" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 15, 8.0, 20)
operation = 2
size = Vector3(4.0, 3.0, 2.0)
material = SubResource("Mat_Glass")

[node name="WindowCut_cfad" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -15, 8.0, 20)
operation = 2
size = Vector3(4.0, 3.0, 2.0)
material = SubResource("Mat_Glass")

[node name="Floor_56c7" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 40, -5.5, 10)

size = Vector3(25, 1, 30)
material = SubResource("Mat_Floor")

[node name="Wall_N_136b" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 40, -2.0, -5.0)

size = Vector3(25, 6, 1.0)
material = SubResource("Mat_Wall")

[node name="Wall_S_156a" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 40, -2.0, 25.0)

size = Vector3(25, 6, 1.0)
material = SubResource("Mat_Wall")

[node name="Wall_E_8ac8" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 52.5, -2.0, 10)

size = Vector3(1.0, 6, 30)
material = SubResource("Mat_Wall")

[node name="Wall_W_a5d0" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 27.5, -2.0, 10)

size = Vector3(1.0, 6, 30)
material = SubResource("Mat_Wall")

[node name="Ceiling_6ced" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 40, 1.5, 10)

size = Vector3(25, 1, 30)
material = SubResource("Mat_Wall")

[node name="Bed_Ignis_Y1_01_8370" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 32.0, -4.75, 2.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y1_02_d9aa" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 32.0, -4.75, 6.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y1_03_87ba" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 32.0, -4.75, 10.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y1_04_baa7" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 32.0, -4.75, 14.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y1_05_acdf" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 32.0, -4.75, 18.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y1_06_8a8d" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 32.0, -4.75, 22.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y1_07_2775" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 36.0, -4.75, 2.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y2_01_9485" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 36.0, -4.75, 6.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y2_02_a6fc" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 36.0, -4.75, 10.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y2_03_edeb" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 36.0, -4.75, 14.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y2_04_6a11" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 36.0, -4.75, 18.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y2_05_b18a" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 36.0, -4.75, 22.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y2_06_d6de" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 40.0, -4.75, 2.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y2_07_54d1" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 40.0, -4.75, 6.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y3_01_5c15" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 40.0, -4.75, 10.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y3_02_eac6" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 40.0, -4.75, 14.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y3_03_0517" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 40.0, -4.75, 18.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y3_04_921a" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 40.0, -4.75, 22.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y3_05_6a94" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 44.0, -4.75, 2.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y3_06_3afa" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 44.0, -4.75, 6.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y3_07_0c91" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 44.0, -4.75, 10.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y4_01_cbaf" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 44.0, -4.75, 14.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y4_02_6f2b" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 44.0, -4.75, 18.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y4_03_093c" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 44.0, -4.75, 22.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y4_04_1490" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 48.0, -4.75, 2.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y4_05_6c80" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 48.0, -4.75, 6.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y4_06_c4f0" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 48.0, -4.75, 10.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Ignis_Y4_07_0077" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 48.0, -4.75, 14.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="WindowCut_f23f" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 52.5, -2.0, 0)
operation = 2
size = Vector3(4.0, 3.0, 2.0)
material = SubResource("Mat_Glass")

[node name="WindowCut_6412" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 52.5, -2.0, 10)
operation = 2
size = Vector3(4.0, 3.0, 2.0)
material = SubResource("Mat_Glass")

[node name="WindowCut_19b8" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 52.5, -2.0, 20)
operation = 2
size = Vector3(4.0, 3.0, 2.0)
material = SubResource("Mat_Glass")

[node name="Floor_e434" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -40, 14.5, 10)

size = Vector3(20, 1, 20)
material = SubResource("Mat_Floor")

[node name="Wall_N_6aa5" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -40, 19.0, 0.0)

size = Vector3(20, 8, 1.0)
material = SubResource("Mat_Wall")

[node name="Wall_S_bcfe" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -40, 19.0, 20.0)

size = Vector3(20, 8, 1.0)
material = SubResource("Mat_Wall")

[node name="Wall_E_80f8" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -30.0, 19.0, 10)

size = Vector3(1.0, 8, 20)
material = SubResource("Mat_Wall")

[node name="Wall_W_6583" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -50.0, 19.0, 10)

size = Vector3(1.0, 8, 20)
material = SubResource("Mat_Wall")

[node name="Ceiling_e8b3" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -40, 23.5, 10)

size = Vector3(20, 1, 20)
material = SubResource("Mat_Wall")

[node name="Bed_Axiom_Y1_01_aff2" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -48.0, 15.25, 2.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y1_02_5899" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -48.0, 15.25, 6.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y1_03_0643" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -48.0, 15.25, 10.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y1_04_4aa2" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -48.0, 15.25, 14.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y1_05_7c5b" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -48.0, 15.25, 18.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y1_06_23b7" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -48.0, 15.25, 22.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y1_07_581b" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -44.0, 15.25, 2.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y2_01_b3a0" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -44.0, 15.25, 6.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y2_02_9864" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -44.0, 15.25, 10.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y2_03_9071" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -44.0, 15.25, 14.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y2_04_2df6" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -44.0, 15.25, 18.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y2_05_caed" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -44.0, 15.25, 22.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y2_06_ea87" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -40.0, 15.25, 2.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y2_07_22b4" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -40.0, 15.25, 6.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y3_01_9fa0" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -40.0, 15.25, 10.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y3_02_3fe2" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -40.0, 15.25, 14.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y3_03_56f6" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -40.0, 15.25, 18.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y3_04_0610" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -40.0, 15.25, 22.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y3_05_3b69" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -36.0, 15.25, 2.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y3_06_82bb" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -36.0, 15.25, 6.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y3_07_477f" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -36.0, 15.25, 10.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y4_01_94a6" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -36.0, 15.25, 14.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y4_02_899d" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -36.0, 15.25, 18.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y4_03_a593" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -36.0, 15.25, 22.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y4_04_f716" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -32.0, 15.25, 2.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y4_05_f784" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -32.0, 15.25, 6.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y4_06_2dd1" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -32.0, 15.25, 10.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Axiom_Y4_07_2595" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -32.0, 15.25, 14.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="WindowCut_e795" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -40, 18.0, 20)
operation = 2
size = Vector3(2.0, 3.0, 4.0)
material = SubResource("Mat_Glass")

[node name="WindowCut_ec65" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -40, 18.0, 0)
operation = 2
size = Vector3(2.0, 3.0, 4.0)
material = SubResource("Mat_Glass")

[node name="WindowCut_1990" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -30, 18.0, 10)
operation = 2
size = Vector3(4.0, 3.0, 2.0)
material = SubResource("Mat_Glass")

[node name="WindowCut_7a16" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -50, 18.0, 10)
operation = 2
size = Vector3(4.0, 3.0, 2.0)
material = SubResource("Mat_Glass")

[node name="Floor_bca3" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 4.5, -40)

size = Vector3(30, 1, 30)
material = SubResource("Mat_Floor")

[node name="Wall_N_1a96" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 8.0, -55.0)

size = Vector3(30, 6, 1.0)
material = SubResource("Mat_Wall")

[node name="Wall_S_82e3" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 8.0, -25.0)

size = Vector3(30, 6, 1.0)
material = SubResource("Mat_Wall")

[node name="Wall_E_6d75" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 15.0, 8.0, -40)

size = Vector3(1.0, 6, 30)
material = SubResource("Mat_Wall")

[node name="Wall_W_5e60" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -15.0, 8.0, -40)

size = Vector3(1.0, 6, 30)
material = SubResource("Mat_Wall")

[node name="Bed_Vesper_Y1_01_e19e" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -8.0, 5.25, -48.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y1_02_c006" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -8.0, 5.25, -44.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y1_03_3e37" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -8.0, 5.25, -40.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y1_04_0315" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -8.0, 5.25, -36.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y1_05_a8a1" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -8.0, 5.25, -32.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y1_06_a7c5" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -8.0, 5.25, -28.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y1_07_11c8" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -4.0, 5.25, -48.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y2_01_1a78" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -4.0, 5.25, -44.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y2_02_af12" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -4.0, 5.25, -40.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y2_03_8aed" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -4.0, 5.25, -36.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y2_04_a95c" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -4.0, 5.25, -32.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y2_05_c21e" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -4.0, 5.25, -28.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y2_06_02f1" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.0, 5.25, -48.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y2_07_49bf" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.0, 5.25, -44.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y3_01_a6e1" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.0, 5.25, -40.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y3_02_c8e7" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.0, 5.25, -36.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y3_03_2c2c" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.0, 5.25, -32.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y3_04_ba13" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.0, 5.25, -28.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y3_05_9a38" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 4.0, 5.25, -48.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y3_06_8637" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 4.0, 5.25, -44.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y3_07_5aa0" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 4.0, 5.25, -40.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y4_01_3c4f" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 4.0, 5.25, -36.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y4_02_ece1" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 4.0, 5.25, -32.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y4_03_1685" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 4.0, 5.25, -28.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y4_04_9be6" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 8.0, 5.25, -48.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y4_05_a5d1" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 8.0, 5.25, -44.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y4_06_2ced" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 8.0, 5.25, -40.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="Bed_Vesper_Y4_07_02dc" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 8.0, 5.25, -36.0)

size = Vector3(1.0, 0.5, 2.0)
material = SubResource("Mat_Bed")

[node name="WindowCut_1ab9" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 8.0, -55)
operation = 2
size = Vector3(2.0, 3.0, 4.0)
material = SubResource("Mat_Glass")

[node name="DoorCut_375d" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.0, 7.0, -27.5)
operation = 2
size = Vector3(3.0, 4.0, 9.0)
material = SubResource("Mat_Wall")

[node name="DoorCut_82be" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 20.0, 7.0, 5.0)
operation = 2
size = Vector3(14.0, 4.0, 3.0)
material = SubResource("Mat_Wall")

[node name="Ramp_Ignis_8c5d" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 20, 0, 5)

size = Vector3(10, 1, 15)
material = SubResource("Mat_Floor")

[node name="DoorCut_5771" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 27.5, -3.0, 5.0)
operation = 2
size = Vector3(5.0, 4.0, 3.0)
material = SubResource("Mat_Wall")

[node name="Floor_a48d" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 50, -5.5, -20)

size = Vector3(15, 1, 15)
material = SubResource("Mat_Floor")

[node name="Wall_N_4a2f" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 50, -2.0, -27.5)

size = Vector3(15, 6, 1.0)
material = SubResource("Mat_Wall")

[node name="Wall_S_aca4" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 50, -2.0, -12.5)

size = Vector3(15, 6, 1.0)
material = SubResource("Mat_Wall")

[node name="Wall_E_deaa" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 57.5, -2.0, -20)

size = Vector3(1.0, 6, 15)
material = SubResource("Mat_Wall")

[node name="Wall_W_9552" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 42.5, -2.0, -20)

size = Vector3(1.0, 6, 15)
material = SubResource("Mat_Wall")

[node name="Ceiling_4cff" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 50, 1.5, -20)

size = Vector3(15, 1, 15)
material = SubResource("Mat_Wall")

[node name="DoorCut_d5d3" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 45.0, -3.0, -5.0)
operation = 2
size = Vector3(3.0, 4.0, 35.622776601683796)
material = SubResource("Mat_Wall")

[node name="Floor_dcef" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -50, 14.5, -20)

size = Vector3(15, 1, 15)
material = SubResource("Mat_Floor")

[node name="Wall_N_0306" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -50, 18.0, -27.5)

size = Vector3(15, 6, 1.0)
material = SubResource("Mat_Wall")

[node name="Wall_S_2e40" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -50, 18.0, -12.5)

size = Vector3(15, 6, 1.0)
material = SubResource("Mat_Wall")

[node name="Wall_E_bd24" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -42.5, 18.0, -20)

size = Vector3(1.0, 6, 15)
material = SubResource("Mat_Wall")

[node name="Wall_W_70e3" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -57.5, 18.0, -20)

size = Vector3(1.0, 6, 15)
material = SubResource("Mat_Wall")

[node name="Ceiling_1abf" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -50, 21.5, -20)

size = Vector3(15, 1, 15)
material = SubResource("Mat_Wall")

[node name="WindowCut_f5ac" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -50, 18.0, -27.5)
operation = 2
size = Vector3(2.0, 3.0, 4.0)
material = SubResource("Mat_Glass")

[node name="SecretTunnel_Floor_c0c9" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 25, 0, -35)

size = Vector3(40, 1, 4)
material = SubResource("Mat_Floor")

[node name="TunnelWall_1_ceeb" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 25, 2, -33)

size = Vector3(40, 4, 1)
material = SubResource("Mat_Wall")

[node name="TunnelWall_2_03dc" type="CSGBox3D" parent="CastleCSG"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 25, 2, -37)

size = Vector3(40, 4, 1)
material = SubResource("Mat_Wall")
res://source/common/gameplay/maps/cliffwald_world.tscn

--- res://source/common/gameplay/maps/cliffwald_world.tscn ---
[gd_scene load_steps=9 format=3 uid="uid://bhnkv8ma51g03"]

[ext_resource type="Script" uid="uid://7mbux4mybta0" path="res://source/common/gameplay/maps/map.gd" id="1_map"]
[ext_resource type="Script" path="res://source/server/world/components/schedule_manager.gd" id="3_schedule"]
[ext_resource type="PackedScene" path="res://source/common/gameplay/maps/markers.tscn" id="4_markers"]
[ext_resource type="PackedScene" uid="uid://npc_simple_v1" path="res://source/common/gameplay/characters/npc/npc_simple.tscn" id="5_npc"]
[ext_resource type="PackedScene" uid="uid://castle_greybox_v1" path="res://source/common/gameplay/maps/castle_greybox.tscn" id="6_castle"]
[ext_resource type="Script" path="res://source/server/world/components/simple_spawner.gd" id="7_spawner"]

[sub_resource type="ProceduralSkyMaterial" id="SkyMat"]
sky_top_color = Color(0.1, 0.2, 0.4, 1)
sky_horizon_color = Color(0.5, 0.6, 0.7, 1)

[sub_resource type="Sky" id="SkyRes"]
sky_material = SubResource("SkyMat")

[sub_resource type="Environment" id="Env"]
background_mode = 2
sky = SubResource("SkyRes")
ambient_light_source = 3
reflected_light_source = 2

[node name="CliffwaldMap_Final" type="Node3D"]
script = ExtResource("1_map")

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Env")

[node name="CastleGreybox" parent="." instance=ExtResource("6_castle")]

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="."]
transform = Transform3D(0.5, -0.707107, 0.5, 0, 0.707107, 0.707107, -0.866025, -0.353553, 0.353553, 0, 50, 0)
shadow_enabled = true

[node name="SpawnPoint" type="Marker3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 2.5, 0)

[node name="ScheduleManager" type="Node" parent="."]
script = ExtResource("3_schedule")

[node name="Markers" parent="." instance=ExtResource("4_markers")]

[node name="MultiplayerSpawner" type="MultiplayerSpawner" parent="."]
_spawnable_scenes = PackedStringArray("res://source/common/gameplay/characters/player/net_player.tscn", "res://source/common/gameplay/combat/projectiles/projectile_kinetic.tscn", "res://source/common/gameplay/combat/projectiles/projectile_aegis.tscn", "res://source/common/gameplay/combat/projectiles/projectile_pyroclasm.tscn", "res://source/common/gameplay/combat/projectiles/projectile_stasis.tscn")
spawn_path = NodePath("..")

[node name="SimpleSpawner" type="Node" parent="."]
script = ExtResource("7_spawner")

[node name="Professor_Potions" parent="." instance=ExtResource("5_npc")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 10, 0, 10)res://source/common/gameplay/maps/components/interaction_areas/interaction_area.gd

--- res://source/common/gameplay/maps/components/interaction_areas/interaction_area.gd ---
class_name InteractionArea
extends Area3D

signal player_entered_interaction_area(player: Node3D, interaction_area: InteractionArea)

func _init() -> void:
	body_entered.connect(_on_body_entered)
	collision_mask = 2 
	monitorable = false
	monitoring = true

func _on_body_entered(body: Node) -> void:
	if body is CharacterBody3D: 
		player_entered_interaction_area.emit(body, self)
res://source/common/gameplay/maps/components/interaction_areas/interaction_area.gd.uid
res://source/common/gameplay/maps/components/interaction_areas/interaction_area.tscn

--- res://source/common/gameplay/maps/components/interaction_areas/interaction_area.tscn ---
[gd_scene load_steps=2 format=3 uid="uid://d0rhh01b2jj7f"]

[ext_resource type="Script" uid="uid://b3r6vglj3doxu" path="res://source/common/gameplay/maps/components/interaction_areas/interaction_area.gd" id="1_0ligj"]

[node name="InteractionArea" type="Area3D"]
script = ExtResource("1_0ligj")

[connection signal="body_entered" from="." to="." method="_on_body_entered"]
res://source/common/gameplay/maps/components/interaction_areas/teleporter/teleporter.gd

--- res://source/common/gameplay/maps/components/interaction_areas/teleporter/teleporter.gd ---
@tool
extends InteractionArea
class_name Teleporter

@export var one_way: bool = false
@export var target: Teleporter

# [3D FIX] Usar Vector3 en lugar de Vector2
@export var size: Vector3 = Vector3(1, 1, 1):
	set(value):
		size = value
		_update_shape()

func _ready():
	super._init() # Configurar capas de colisin desde la clase base
	_update_shape()

func _update_shape():
	var col = get_node_or_null("CollisionShape3D")
	if col and col.shape is BoxShape3D:
		col.shape.size = size
res://source/common/gameplay/maps/components/interaction_areas/teleporter/teleporter.gd.uid
res://source/common/gameplay/maps/components/interaction_areas/teleporter/teleporter.tscn

--- res://source/common/gameplay/maps/components/interaction_areas/teleporter/teleporter.tscn ---
[gd_scene load_steps=3 format=3 uid="uid://dbg8y8if4vv5p"]

[ext_resource type="Script" uid="uid://dd13qn2chpxp2" path="res://source/common/gameplay/maps/components/interaction_areas/teleporter/teleporter.gd" id="1_325em"]

[sub_resource type="BoxShape3D" id="BoxShape3D_vfhs3"]

[node name="Teleporter" type="Area3D"]
collision_mask = 2
monitorable = false
script = ExtResource("1_325em")

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
shape = SubResource("BoxShape3D_vfhs3")
res://source/common/gameplay/maps/components/interaction_areas/warper/warper.gd

--- res://source/common/gameplay/maps/components/interaction_areas/warper/warper.gd ---
@icon("res://assets/node_icons/blue/icon_door.png")
class_name Warper
extends Area3D # <--- CAMBIO: De InteractionArea (2D) a Area3D

@export var target_instance: InstanceResource
@export var warper_id: int = 0
@export var target_id: int = 0

func _ready() -> void:
	monitorable = false
	monitoring = true
	# Capas de colisin: Detectar Player (Layer 2)
	collision_mask = 2 
	
	body_entered.connect(_on_body_entered)

func _on_body_entered(body: Node3D) -> void:
	if body is CharacterBody3D:
		print("Jugador entr en Warper: ", warper_id)
		# Aqu ira la lgica de cambio de mapa
res://source/common/gameplay/maps/components/interaction_areas/warper/warper.gd.uid
res://source/common/gameplay/maps/components/interaction_areas/warper/warper.tscn

--- res://source/common/gameplay/maps/components/interaction_areas/warper/warper.tscn ---
[gd_scene load_steps=3 format=3 uid="uid://b2ckixon7ryh6"]

[ext_resource type="Script" path="res://source/common/gameplay/maps/components/interaction_areas/warper/warper.gd" id="1_w00al"]

[sub_resource type="BoxShape3D" id="BoxShape3D_trigger"]
size = Vector3(2, 2, 2)

[node name="Warper" type="Area3D"]
collision_layer = 8
collision_mask = 2
monitorable = false
script = ExtResource("1_w00al")

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0)
shape = SubResource("BoxShape3D_trigger")res://source/common/gameplay/maps/instance/instance_collection/overworld.tres
res://source/common/gameplay/maps/instance/instance_resource.gd

--- res://source/common/gameplay/maps/instance/instance_resource.gd ---
class_name InstanceResource
extends Resource


@export var instance_name: StringName
@export_file("*.tscn") var map_path: String
@export var load_at_startup: bool = false

var loading_instances: Array
var charged_instances: Array[ServerInstance]


@warning_ignore("unused_parameter")
func can_join_instance(player: Node, index: int = -1) -> bool:
	return true


func get_instance(index: int = -1) -> ServerInstance:
	if charged_instances.is_empty() or charged_instances.size() <= index:
		return null
	return charged_instances[index]
res://source/common/gameplay/maps/instance/instance_resource.gd.uid
res://source/common/gameplay/maps/map.gd

--- res://source/common/gameplay/maps/map.gd ---
@tool
class_name Map
extends Node3D

enum AOIMode { NONE, GRID }
enum ZoneMode { SAFE, PVP }

# --- CONFIGURACIN DEL MAPA ---
@export_category("Map Settings")
@export_group("Area Of Interest (Network)")
@export var aoi_mode: AOIMode = AOIMode.NONE
@export var aoi_cell_size: Vector2i = Vector2i(250, 250)
@export var aoi_visible_radius_cells: int = 2

@export_group("Default Rules")
@export var map_background_color := Color(0.1, 0.2, 0.4)

# Removed dependency on ReplicatedPropsContainer
# @export var replicated_props_container: Node 

var _spawn_points: Dictionary = {}
var sun: DirectionalLight3D
var env: WorldEnvironment

func _ready() -> void:
	# Wait for CSG collision generation (avoids parsing RenderingServer meshes warning)
	if not Engine.is_editor_hint():
		await get_tree().physics_frame
		await get_tree().physics_frame

	# Auto-bake navigation for generated castle
	var nav_region = find_child("CastleGreybox", true, false)
	if nav_region and nav_region is NavigationRegion3D:
		print("Map: Baking navigation mesh for castle...")
		nav_region.bake_navigation_mesh(true)

	if Engine.is_editor_hint(): return
	
	sun = find_child("DirectionalLight3D")
	env = find_child("WorldEnvironment")
	
	_scan_spawn_points()
	
	# Connect to ScheduleManager
	var managers = get_tree().get_nodes_in_group("ScheduleManager")
	if not managers.is_empty():
		managers[0].time_changed.connect(_on_time_changed)

func _on_time_changed(time_str: String) -> void:
	# Parse HH:MM
	var parts = time_str.split(":")
	var hour = parts[0].to_int()
	var minute = parts[1].to_int()
	
	# Calculate day progress (0.0 to 1.0)
	# 06:00 = Sunrise (0.25)
	# 12:00 = Noon (0.5)
	# 18:00 = Sunset (0.75)
	# 00:00 = Midnight (0.0 / 1.0)
	
	var total_minutes = (hour * 60) + minute
	var progress = total_minutes / 1440.0
	
	if sun:
		# Rotate sun based on progress (360 degrees)
		# Noon (0.5) should be -90 degrees X rotation?
		# Standard Godot sun: -90 is Zenith.
		# Progress 0.0 (Midnight) -> Rotation X = 90 (Nadir)
		# Progress 0.5 (Noon) -> Rotation X = -90 (Zenith)
		var angle = (progress * 360.0) - 90.0
		sun.rotation_degrees.x = angle

func _scan_spawn_points() -> void:
	_spawn_points.clear()
	for child in get_children():
		if "warper_id" in child:
			_spawn_points[child.warper_id] = child
		elif child is Marker3D:
			_spawn_points[child.name] = child

func get_spawn_position(id: Variant = 0) -> Vector3:
	if _spawn_points.has(id):
		return _spawn_points[id].global_position
	if not _spawn_points.is_empty():
		return _spawn_points.values()[0].global_position
	return Vector3(0, 5.0, 0)

func get_zone_authoring_data() -> Dictionary:
	return {}res://source/common/gameplay/maps/map.gd.uid
res://source/common/gameplay/maps/markers.tscn

--- res://source/common/gameplay/maps/markers.tscn ---
[gd_scene load_steps=1 format=3 uid="uid://markers_scene_v1"]

[node name="Markers" type="Node3D"]

[node name="Great_Hall" type="Marker3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0)

[node name="Potions_Tower" type="Marker3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 10, 0, 10)

[node name="Library" type="Marker3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -10, 0, -10)

[node name="Dormitory_Ignis" type="Marker3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 20, 0, 0)

[node name="Dormitory_Axiom" type="Marker3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -20, 0, 0)
res://source/common/gameplay/maps/props/collectibles/coin.gd.uid
res://source/common/gameplay/maps/props/doors/activable_door/activable_door.gd

--- res://source/common/gameplay/maps/props/doors/activable_door/activable_door.gd ---
extends StaticBody3D


@export var door_id: int = 0

@onready var door_anim: AnimatedSprite3D = $AnimatedSprite3D
@onready var door_collision: CollisionShape3D = $CollisionShape3D


func _ready() -> void:
	door_anim.play(&"closed")


func open_door() -> void:
	door_anim.play(&"opening")
	door_collision.disabled = true
res://source/common/gameplay/maps/props/doors/activable_door/activable_door.gd.uid
res://source/common/gameplay/maps/props/doors/activable_door/activable_door.tscn

--- res://source/common/gameplay/maps/props/doors/activable_door/activable_door.tscn ---
[gd_scene load_steps=16 format=3 uid="uid://hcfiu2vpqr3u"]

[ext_resource type="Script" uid="uid://cjqrkmohwgdql" path="res://source/common/gameplay/maps/props/doors/activable_door/activable_door.gd" id="1_ppv3d"]
[ext_resource type="Texture2D" uid="uid://da32oaudh5aew" path="res://assets/sprites/environment/environment_objects/spike_trap.png" id="2_pl2kf"]

[sub_resource type="AtlasTexture" id="AtlasTexture_oopog"]
atlas = ExtResource("2_pl2kf")
region = Rect2(64, 0, 16, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_ncqil"]
atlas = ExtResource("2_pl2kf")
region = Rect2(0, 0, 16, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_7xcfj"]
atlas = ExtResource("2_pl2kf")
region = Rect2(16, 0, 16, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_801ri"]
atlas = ExtResource("2_pl2kf")
region = Rect2(32, 0, 16, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_w6j8x"]
atlas = ExtResource("2_pl2kf")
region = Rect2(48, 0, 16, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_nx16n"]
atlas = ExtResource("2_pl2kf")
region = Rect2(64, 0, 16, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_p6sbt"]
atlas = ExtResource("2_pl2kf")
region = Rect2(64, 0, 16, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_m60pa"]
atlas = ExtResource("2_pl2kf")
region = Rect2(80, 0, 16, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_upsji"]
atlas = ExtResource("2_pl2kf")
region = Rect2(96, 0, 16, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_n14bl"]
atlas = ExtResource("2_pl2kf")
region = Rect2(112, 0, 16, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_nplpu"]
atlas = ExtResource("2_pl2kf")
region = Rect2(128, 0, 16, 32)

[sub_resource type="SpriteFrames" id="SpriteFrames_8y88c"]
animations = [{
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_oopog")
}],
"loop": false,
"name": &"closed",
"speed": 5.0
}, {
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_ncqil")
}, {
"duration": 0.5,
"texture": SubResource("AtlasTexture_7xcfj")
}, {
"duration": 0.5,
"texture": SubResource("AtlasTexture_801ri")
}, {
"duration": 0.75,
"texture": SubResource("AtlasTexture_w6j8x")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_nx16n")
}],
"loop": false,
"name": &"closing",
"speed": 5.0
}, {
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_p6sbt")
}, {
"duration": 0.9,
"texture": SubResource("AtlasTexture_m60pa")
}, {
"duration": 0.75,
"texture": SubResource("AtlasTexture_upsji")
}, {
"duration": 0.5,
"texture": SubResource("AtlasTexture_n14bl")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_nplpu")
}],
"loop": false,
"name": &"opening",
"speed": 5.0
}]

[sub_resource type="BoxShape3D" id="BoxShape3D_7sfpt"]
size = Vector3(1, 1, 0.25)

[node name="ActivableDoor" type="StaticBody3D"]
collision_layer = 4
script = ExtResource("1_ppv3d")

[node name="AnimatedSprite3D" type="AnimatedSprite3D" parent="."]
texture_filter = 1
position = Vector3(0, 0, -8)
sprite_frames = SubResource("SpriteFrames_8y88c")
animation = &"closed"

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
shape = SubResource("BoxShape3D_7sfpt")
res://source/common/gameplay/maps/props/ground_button/ground_button.gd

--- res://source/common/gameplay/maps/props/ground_button/ground_button.gd ---
extends Area3D


@export var activable_door: Array[Node3D]
@export var interaction_id: int = 0
@export var cooldown: float = 6.0

var pressed: bool = false

@onready var button_anim: AnimatedSprite3D = $AnimatedSprite3D


func _ready() -> void:
	if multiplayer.is_server():
		# Only the server checks for collision.
		body_entered.connect(_on_body_entered)
	button_anim.play(&"up") # Default animation


func _on_body_entered(body: Node3D) -> void:
	if body is CharacterBody3D and not pressed:
		
		var container: ReplicatedPropsContainer = get_parent()
		var prop_id: int = container.child_id_of_node(self)
		container.set_baseline_ops(prop_id, [["rp_button_pressed", []]])
		container.queue_op(prop_id, "rp_button_pressed", [])
		
		pressed = true
		
		# Call the function also on server so door collisions are moved.
		rp_button_pressed()


func rp_button_pressed() -> void:
	button_anim.play(&"pressed")
	await button_anim.animation_finished
	for door: Node3D in activable_door:
		if door.has_method("open_door"):
			door.open_door()
res://source/common/gameplay/maps/props/ground_button/ground_button.gd.uid
res://source/common/gameplay/maps/props/ground_button/ground_button.tscn

--- res://source/common/gameplay/maps/props/ground_button/ground_button.tscn ---
[gd_scene load_steps=7 format=3 uid="uid://bojii5hxh2lgh"]

[ext_resource type="Script" uid="uid://wh5map4o52qc" path="res://source/common/gameplay/maps/props/ground_button/ground_button.gd" id="1_tgw3s"]
[ext_resource type="Texture2D" uid="uid://b1lsob56myiuh" path="res://assets/sprites/environment/environment_objects/pressure_plate.png" id="2_exn2p"]

[sub_resource type="AtlasTexture" id="AtlasTexture_xf86q"]
atlas = ExtResource("2_exn2p")
region = Rect2(16, 0, 16, 16)

[sub_resource type="AtlasTexture" id="AtlasTexture_882yo"]
atlas = ExtResource("2_exn2p")
region = Rect2(0, 0, 16, 16)

[sub_resource type="SpriteFrames" id="SpriteFrames_aa61n"]
animations = [{
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_xf86q")
}],
"loop": false,
"name": &"pressed",
"speed": 5.0
}, {
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_882yo")
}],
"loop": false,
"name": &"up",
"speed": 5.0
}]

[sub_resource type="BoxShape3D" id="BoxShape3D_uru4r"]
size = Vector3(0.5, 0.2, 0.5)

[node name="GroundButton" type="Area3D"]
script = ExtResource("1_tgw3s")

[node name="AnimatedSprite3D" type="AnimatedSprite3D" parent="."]
texture_filter = 1
sprite_frames = SubResource("SpriteFrames_aa61n")
animation = &"pressed"

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
shape = SubResource("BoxShape3D_uru4r")
res://source/common/main.gd

--- res://source/common/main.gd ---
extends Node

const GATEWAY_SCENE = preload("res://source/server/gateway/gateway_main.tscn")
const MASTER_SCENE = preload("res://source/server/master/master_main.tscn")
const WORLD_SCENE = preload("res://source/server/world/world_main.tscn")
const CLIENT_MAIN_SCENE = preload("res://source/client/client_main.tscn")

func _ready() -> void:
	print("--- MAIN ENTRY POINT ---")
	
	# [FIX] Ocultar la etiqueta de error si existe
	if has_node("ErrorLabel"):
		$ErrorLabel.hide()
		$ErrorLabel.queue_free()

	if OS.has_feature("gateway-server"):
		_load_scene(GATEWAY_SCENE)
	elif OS.has_feature("master-server"):
		_load_scene(MASTER_SCENE)
	elif OS.has_feature("world-server"):
		_load_scene(WORLD_SCENE)
	elif OS.has_feature("client"):
		_load_scene(CLIENT_MAIN_SCENE)
	else:
		# Sin etiquetas vlidas, mostramos la etiqueta de error si est disponible.
		if has_node("ErrorLabel"):
			$ErrorLabel.show()

func _load_scene(packed_scene: PackedScene) -> void:
	var instance = packed_scene.instantiate()
	add_child(instance)
res://source/common/main.gd.uid
res://source/common/main.tscn

--- res://source/common/main.tscn ---
[gd_scene load_steps=2 format=3 uid="uid://vexbi605indu"]

[ext_resource type="Script" uid="uid://bmrprxwywd2oj" path="res://source/common/main.gd" id="1_gnr3o"]

[node name="Main" type="Node"]
script = ExtResource("1_gnr3o")

[node name="ErrorLabel" type="Label" parent="."]
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -20.0
offset_top = -11.5
offset_right = 20.0
offset_bottom = 11.5
grow_horizontal = 2
grow_vertical = 2
text = "You see this label because no valid feature tag was found.
Please check either README.md or common/main.gd for more information."
horizontal_alignment = 1
vertical_alignment = 1
res://source/common/network/endpoints/base_multiplayer_endpoint.gd

--- res://source/common/network/endpoints/base_multiplayer_endpoint.gd ---
extends Node
class_name BaseMultiplayerEndpoint

## horizon: feel free to edit if needed
## Minimal, reusable multiplayer bootstrap.
## Override `_connect_multiplayer_api_signals()` in subclasses to wire only what you need.

enum Role {
	CLIENT,
	SERVER
}

var peer: WebSocketMultiplayerPeer #extends MultiplayerPeer
var multiplayer_api: SceneMultiplayer #extends MultiplayerAPI


# Uncomment if you want to do your own polling, otherwise SceneTree takes care of it.
func _process(_delta: float) -> void:
	if multiplayer_api and multiplayer_api.has_multiplayer_peer():
		multiplayer_api.poll()


## Should be called once
func init_multiplayer(use_root_api: bool = false) -> void:
	multiplayer_api = (
		MultiplayerAPI.create_default_interface()
		if not use_root_api else multiplayer
	)
	
	# MMO choice, no peer gossip via server
	multiplayer_api.server_relay = false
	
	# Setup signals, has to be ovverride by subclass.
	_connect_multiplayer_api_signals(multiplayer_api)
	
	# Set to a custom path, else use root path.
	get_tree().set_multiplayer(
		multiplayer_api,
		NodePath("") if use_root_api else get_path()
	)

	# Create the kind of peer we want.
	peer = WebSocketMultiplayerPeer.new()

	if peer.is_server_relay_supported(): # Necessary check ?
		# We want to disable the server feature that can notifies clients of other peers' connection/disconnection,
		# and relays messages between them.
		multiplayer_api.server_relay = false


## Override this in subclasses to connect native SceneMultiplayer signals.
func _connect_multiplayer_api_signals(api: SceneMultiplayer) -> void:
	pass


## Create as client or server.
## TLS usefull for wss (WebSocket Secure) unless you have anything else taking care of it like Caddy.
func create(role: Role, address: String, port: int, tls_options: TLSOptions = null) -> Error:
	if not multiplayer_api:
		init_multiplayer();

	var error: Error

	match role:
		Role.CLIENT:
			var scheme: String = "ws" if tls_options == null else "wss"
			error = peer.create_client("%s://%s:%d" % [scheme, address, port], tls_options)
		Role.SERVER:
			var bind_address: String = "*" if address.is_empty() else address
			error = peer.create_server(port, bind_address, tls_options)
		_:
			return Error.FAILED

	if error != OK:
		printerr("Error while creating peer: %s" % error_string(error))
		return error

	# Setting this, calls SceneMultiplayer::set_multiplayer_peer
	# which check "p_peer.is_valid() && p_peer->get_connection_status() == MultiplayerPeer::CONNECTION_DISCONNECTED"
	# Meaning the supplied peer must be either connecting or connected I guess
	multiplayer_api.multiplayer_peer = peer

	return Error.OK
res://source/common/network/endpoints/base_multiplayer_endpoint.gd.uid
res://source/common/network/gateway_api.gd

--- res://source/common/network/gateway_api.gd ---


## Shared keys (client + gateway)
const KEY_TOKEN_ID: String = "t-id"
const KEY_ACCOUNT_ID: String = "a-id"
const KEY_ACCOUNT_USERNAME: String = "a-u"
const KEY_WORLD_ID: String = "w-id"
const KEY_CHAR_ID: String = "c-id"


static func base_url() -> String:
	# Hardcoded default one
	return "http://127.0.0.1:8088"
	#var command_line_arg: String = CmdlineUtils.get_parsed_args().get("api", "")
	#if command_line_arg:
		#return command_line_arg
#
	## Check if has default in ProjectSettings
	## (set different values for debug/release export presets))
	#var value: String = ProjectSettings.get_setting("network/api/base_url", "")
	#if not value.is_empty():
		#return value
	#return "http://127.0.0.1:8088"


static func get_endpoint(path: String) -> String:
	return "%s%s" % [base_url().rstrip("/"), path]


# Endpoints
static func login() -> String: return get_endpoint("/v1/login")
static func guest() -> String: return get_endpoint("/v1/guest")
static func worlds() -> String: return get_endpoint("/v1/worlds")
static func account_create() -> StringName:
		return get_endpoint(&"/v1/account/create")
static func world_characters() -> String: return get_endpoint("/v1/world/characters")
static func world_enter() -> String: return get_endpoint("/v1/world/enter")
static func world_create_char() -> String: return get_endpoint("/v1/world/character/create")
res://source/common/network/gateway_api.gd.uid
res://source/common/network/utils/sync_utils.gd

--- res://source/common/network/utils/sync_utils.gd ---
class_name SyncUtils


static func roughly_equal(a: Variant, b: Variant) -> bool:
	assert(typeof(a) == typeof(b), "Trying to compare different types")
	
	match typeof(a):
		TYPE_FLOAT:
			return is_equal_approx(a, b)
		TYPE_VECTOR2:#TYPE_VECTOR3 etc. for 3D game
			return (a as Vector2).is_equal_approx(b)
		TYPE_VECTOR3:
			return (a as Vector3).is_equal_approx(b)
		TYPE_QUATERNION:
			return (a as Quaternion).is_equal_approx(b)
		_:
			return a == b
res://source/common/network/utils/sync_utils.gd.uid
res://source/common/network/utils/tls_options_utils.gd

--- res://source/common/network/utils/tls_options_utils.gd ---
class_name TLSOptionsUtils


static func create_server_tls_options(key_path: String, certificate_path: String) -> TLSOptions:
	var key: CryptoKey = CryptoKey.new()
	var error: Error = key.load(key_path)
	if error != OK:
		printerr("Failed loading key with error: %s" % error_string(error))
		return null

	var certificate := X509Certificate.new()
	error = certificate.load(certificate_path)
	if error != OK:
		printerr("Failed to load certificate with error: %s" % error_string(error))
		return null
	
	return TLSOptions.server(key, certificate)


static func create_client_tls_options(certificate_path: String) -> TLSOptions:
	var certificate := X509Certificate.new()
	var error: Error = certificate.load(certificate_path)
	if error != OK:
		printerr("Failed to load certificate with error: %s" % error_string(error))
	
	if OS.has_feature("enforcedtls"):
		return TLSOptions.client(certificate)
	else:
		return TLSOptions.client_unsafe(certificate)
res://source/common/network/utils/tls_options_utils.gd.uid
res://source/common/network/wire.gd

--- res://source/common/network/wire.gd ---
class_name Wire

enum Type {
	VARIANT,
	BOOL,
	U8, U16, U32, U64,
	S8, S16, S32, S64,
	F16, F32, F64,
	STR_UTF8_U16, STR_UTF8_U32,
	STR_ASCII_U16, STR_ASCII_U32,
	BYTES_U16, BYTES_U32,
	VEC2_F32,
	VEC3_F32, # Nuevo para 3D
	QUAT_F32  # Nuevo para Rotaciones
}
res://source/common/network/wire.gd.uid
res://source/common/network/wire_codec.gd

--- res://source/common/network/wire_codec.gd ---
class_name WireCodec
extends Node

static func _new_buff() -> StreamPeerBuffer:
	var stream_peer_buffer: StreamPeerBuffer = StreamPeerBuffer.new()
	stream_peer_buffer.big_endian = false
	return stream_peer_buffer

static func _from_bytes(bytes: PackedByteArray) -> StreamPeerBuffer:
	var stream_peer_buffer: StreamPeerBuffer = StreamPeerBuffer.new()
	stream_peer_buffer.big_endian = false
	stream_peer_buffer.data_array = bytes
	return stream_peer_buffer

#region vector helpers
static func _put_vec2(spb: StreamPeerBuffer, v: Vector2) -> void:
	spb.put_float(v.x)
	spb.put_float(v.y)

static func _get_vec2(spb: StreamPeerBuffer) -> Vector2:
	var x: float = spb.get_float()
	var y: float = spb.get_float()
	return Vector2(x, y)

static func _put_vec3(spb: StreamPeerBuffer, v: Vector3) -> void:
	spb.put_float(v.x)
	spb.put_float(v.y)
	spb.put_float(v.z)

static func _get_vec3(spb: StreamPeerBuffer) -> Vector3:
	var x: float = spb.get_float()
	var y: float = spb.get_float()
	var z: float = spb.get_float()
	return Vector3(x, y, z)
#endregion

static func _encode_value(spb: StreamPeerBuffer, wire_type: int, value: Variant) -> void:
	match wire_type:
		Wire.Type.VARIANT: spb.put_var(value)
		Wire.Type.BOOL: spb.put_u8(int(bool(value)))
		Wire.Type.U8: spb.put_u8(int(value))
		Wire.Type.U16: spb.put_u16(int(value))
		Wire.Type.U32: spb.put_u32(int(value))
		Wire.Type.U64: spb.put_u64(int(value))
		Wire.Type.S8: spb.put_8(int(value))
		Wire.Type.S16: spb.put_16(int(value))
		Wire.Type.S32: spb.put_32(int(value))
		Wire.Type.S64: spb.put_64(int(value))
		Wire.Type.F16: spb.put_half(float(value))
		Wire.Type.F32: spb.put_float(float(value))
		Wire.Type.F64: spb.put_double(float(value))
		Wire.Type.STR_UTF8_U16:
			var bytes := String(value).to_utf8_buffer()
			spb.put_u16(bytes.size())
			spb.put_data(bytes)
		Wire.Type.STR_UTF8_U32: spb.put_utf8_string(String(value))
		Wire.Type.BYTES_U16:
			var b := value as PackedByteArray
			spb.put_u16(b.size())
			spb.put_data(b)
		Wire.Type.BYTES_U32:
			var b2 := value as PackedByteArray
			spb.put_u32(b2.size())
			spb.put_data(b2)
		Wire.Type.VEC2_F32: _put_vec2(spb, value as Vector2)
		Wire.Type.VEC3_F32: _put_vec3(spb, value as Vector3)
		_: spb.put_var(value)

static func _decode_value(spb: StreamPeerBuffer, wire_type: int) -> Variant:
	# Minimal decode with a single guard to avoid reading past buffer end.
	if spb.get_available_bytes() <= 0:
		return null
	match wire_type:
		Wire.Type.VARIANT:
			return spb.get_var()
		Wire.Type.BOOL:
			return spb.get_u8() != 0
		Wire.Type.U8:
			return spb.get_u8()
		Wire.Type.U16:
			return spb.get_u16()
		Wire.Type.U32:
			return spb.get_u32()
		Wire.Type.U64:
			return spb.get_u64()
		Wire.Type.S8:
			return spb.get_8()
		Wire.Type.S16:
			return spb.get_16()
		Wire.Type.S32:
			return spb.get_32()
		Wire.Type.S64:
			return spb.get_64()
		Wire.Type.F16:
			return spb.get_half()
		Wire.Type.F32:
			return spb.get_float()
		Wire.Type.F64:
			return spb.get_double()
		Wire.Type.STR_UTF8_U16:
			var n: int = spb.get_u16()
			var res: Array = spb.get_data(n)
			return res[1].get_string_from_utf8() if res[0] == OK else ""
		Wire.Type.STR_UTF8_U32:
			return spb.get_utf8_string()
		Wire.Type.BYTES_U16:
			var n: int = spb.get_u16()
			var res2: Array = spb.get_data(n)
			return res2[1] if res2[0] == OK else PackedByteArray()
		Wire.Type.BYTES_U32:
			var n: int = spb.get_u32()
			var res3: Array = spb.get_data(n)
			return res3[1] if res3[0] == OK else PackedByteArray()
		Wire.Type.VEC2_F32:
			return _get_vec2(spb)
		Wire.Type.VEC3_F32:
			return _get_vec3(spb)
		_:
			return spb.get_var()

static func encode_entity_block(eid: int, pairs: Array) -> PackedByteArray:
	var spb: StreamPeerBuffer = _new_buff()
	spb.put_u32(eid)
	var n: int = pairs.size()
	spb.put_u16(n)
	for i in range(n):
		var p: Array = pairs[i]
		var pid: int = int(p[0])
		spb.put_u16(pid)
		var wt: int = PathRegistry.type_of(pid)
		_encode_value(spb, wt, p[1])
	return spb.data_array

static func assemble_delta_from_blocks(blocks_bytes: Array) -> PackedByteArray:
	var spb: StreamPeerBuffer = _new_buff()
	spb.put_u16(blocks_bytes.size())
	for i in range(blocks_bytes.size()):
		var bb: PackedByteArray = blocks_bytes[i]
		spb.put_data(bb)
	return spb.data_array

static func encode_delta(blocks: Array) -> PackedByteArray:
	var spb := _new_buff()
	spb.put_u16(blocks.size())
	for block in blocks:
		var eid: int = int(block["eid"])
		spb.put_u32(eid)
		var pairs: Array = block.get("pairs", [])
		spb.put_u16(pairs.size())
		for p in pairs:
			var pid: int = int(p[0])
			spb.put_u16(pid)
			var wt: int = PathRegistry.type_of(pid)
			_encode_value(spb, wt, p[1])
	return spb.data_array

static func decode_delta(data: PackedByteArray) -> Array:
	var spb := _from_bytes(data)
	var block_count := spb.get_u16()
	var out: Array = []
	for _i in range(block_count):
		var eid := spb.get_u32()
		var pair_count := spb.get_u16()
		var pairs: Array = []
		for _j in range(pair_count):
			var pid := spb.get_u16()
			var wt := PathRegistry.type_of(pid)
			pairs.append([pid, _decode_value(spb, wt)])
		out.append({ "eid": eid, "pairs": pairs })
	return out

static func encode_bootstrap(map_updates: Array, objects: Array) -> PackedByteArray:
	var spb: StreamPeerBuffer = StreamPeerBuffer.new()
	spb.big_endian = false
	var updates_count: int = map_updates.size()
	spb.put_u16(updates_count)
	for i in range(updates_count):
		var u: Array = map_updates[i]
		var pid: int = int(u[0])
		var path: String = String(u[1])
		var wt: int = int(u[2])
		spb.put_u16(pid)
		spb.put_utf8_string(path)
		spb.put_u8(wt)
	var obj_count: int = objects.size()
	spb.put_u16(obj_count)
	for i in range(obj_count):
		var obj: Dictionary = objects[i]
		var eid: int = int(obj["eid"])
		spb.put_u32(eid)
		var pairs: Array = obj.get("pairs", [])
		var pair_count: int = pairs.size()
		spb.put_u16(pair_count)
		for j in range(pair_count):
			var p: Array = pairs[j]
			var pid2: int = int(p[0])
			spb.put_u16(pid2)
			var wt2: int = PathRegistry.type_of(pid2)
			_encode_value(spb, wt2, p[1])
	return spb.data_array

static func decode_bootstrap(data: PackedByteArray) -> Dictionary:
	var spb := _from_bytes(data)
	var updates_count := spb.get_u16()
	var updates: Array = []
	for _i in range(updates_count):
		var pid := spb.get_u16()
		var path := spb.get_utf8_string()
		var wt := spb.get_u8()
		updates.append([pid, path, wt])
	if updates.size() > 0:
		PathRegistry.apply_map_updates(updates)
	var obj_count := spb.get_u16()
	var objects: Array = []
	for _j in range(obj_count):
		var eid := spb.get_u32()
		var pair_count := spb.get_u16()
		var pairs: Array = []
		for _k in range(pair_count):
			var pid2 := spb.get_u16()
			var wt2 := PathRegistry.type_of(pid2)
			var v: Variant = _decode_value(spb, wt2)
			pairs.append([pid2, v])
		objects.append({ "eid": eid, "pairs": pairs })
	return { "map_updates": updates, "objects": objects }

static func encode_container_block_named(eid: int, spawns: Array, pairs: Array, despawns: Array, ops_named: Array) -> PackedByteArray:
	var spb := _new_buff()
	spb.put_u32(eid)
	spb.put_u16(spawns.size())
	for s in spawns:
		spb.put_u16(int(s[0]))
		spb.put_u16(int(s[1]))
	spb.put_u16(pairs.size())
	for p in pairs:
		var cpid := int(p[0])
		var fid := cpid & 0xFFFF
		spb.put_u32(cpid)
		_encode_value(spb, PathRegistry.type_of(fid), p[1])
	spb.put_u16(despawns.size())
	for d in despawns:
		spb.put_u16(int(d))
	spb.put_u16(ops_named.size())
	for o in ops_named:
		spb.put_u16(int(o[0]))
		spb.put_utf8_string(String(o[1]))
		var args: Array = o[2] as Array if o.size() else []
		spb.put_8(args.size())
		for a in args:
			spb.put_var(a)
	return spb.data_array

static func decode_container_block_named(data: PackedByteArray) -> Dictionary:
	var spb := _from_bytes(data)
	var eid := spb.get_u32()
	var spn_n := spb.get_u16()
	var spawns: Array = []
	for _i in range(spn_n):
		spawns.append([spb.get_u16(), spb.get_u16()])
	var pr_n := spb.get_u16()
	var pairs: Array = []
	for _j in range(pr_n):
		var cpid := spb.get_u32()
		var fid := cpid & 0xFFFF
		pairs.append([cpid, _decode_value(spb, PathRegistry.type_of(fid))])
	var dsp_n := spb.get_u16()
	var despawns: Array = []
	for _k in range(dsp_n):
		despawns.append(spb.get_u16())
	var op_n := spb.get_u16()
	var ops_named: Array = []
	for _m in range(op_n):
		var cid := spb.get_u16()
		var method := spb.get_utf8_string()
		var argc := spb.get_u8()
		var args: Array = []
		for _t in range(argc):
			args.append(spb.get_var())
		ops_named.append([cid, method, args])
	return { "eid": eid, "spawns": spawns, "pairs": pairs, "despawns": despawns, "ops_named": ops_named }

static func peek_container_block_named(data: PackedByteArray) -> Dictionary:
	var spb := StreamPeerBuffer.new()
	spb.data_array = data
	var eid := spb.get_u32()
	return { "eid": eid }
res://source/common/network/wire_codec.gd.uid
res://source/common/project_export.gd

--- res://source/common/project_export.gd ---
extends Node

const OUTPUT_PATH := "res://server_audit.txt"
const ROOT_DIR := "res://"

func _ready() -> void:
	# Ejecuta la exportacin al arrancar el juego.
	_export_project()
	# No se necesita en el rbol despus de exportar.
	queue_free()


func _export_project() -> void:
	var file := FileAccess.open(OUTPUT_PATH, FileAccess.WRITE)
	if not file:
		push_error("No se pudo abrir %s" % OUTPUT_PATH)
		return
	file.store_line("=== PROJECT EXPORT (files + scripts + scenes) ===")
	_dump_dir(ROOT_DIR, file)
	file.close()
	print("ProjectExport: wrote %s" % OUTPUT_PATH)


func _dump_dir(path: String, file: FileAccess) -> void:
	var dir := DirAccess.open(path)
	if dir == null:
		return
	dir.list_dir_begin()
	while true:
		var entry_name := dir.get_next()
		if entry_name == "":
			break
		if dir.current_is_dir():
			if entry_name.begins_with("."):
				continue
			_dump_dir(path.path_join(entry_name), file)
		else:
			var full_path := path.path_join(entry_name)
			# List every file name
			file.store_line(full_path)
			# Dump content for .gd/.tscn
			if entry_name.ends_with(".gd") or entry_name.ends_with(".tscn"):
				file.store_line("\n--- %s ---" % full_path)
				var content := FileAccess.get_file_as_string(full_path)
				file.store_string(content)
res://source/common/project_export.gd.uid
res://source/common/registry/content_index.gd

--- res://source/common/registry/content_index.gd ---
class_name ContentIndex
extends Resource


@export var content_name: StringName
@export var version: int
@export var next_id: int = 1
##{
##	&"slug": &"human_readable,
##	&"id": 123,
##	&"path": &"res://item.tres" or value ?
##}
## 
@export var entries: Array[Dictionary]

@export var scan_path: String
@export var filters: PackedStringArray
res://source/common/registry/content_index.gd.uid
res://source/common/registry/content_registry.gd

--- res://source/common/registry/content_registry.gd ---
class_name ContentRegistry
extends RefCounted


var _id_to_path: Dictionary
var _slug_to_id: Dictionary


func _init(content_index: ContentIndex) -> void:
	load_content_index(content_index)


func load_content_index(content_index: ContentIndex) -> void:
	for entry: Dictionary in content_index.entries:
		if not entry.has_all([&"id", &"slug", &"path"]):
			continue
		var id: int = entry[&"id"]
		_id_to_path[id] = entry[&"path"]
		_slug_to_id[entry[&"slug"]] = id


func id_from_slug(slug: StringName) -> int:
	return _slug_to_id.get(slug, 0)


func path_from_id(id: int) -> StringName:
	return _id_to_path.get(id, &"")


func path_from_slug(slug: StringName) -> StringName:
	return path_from_id(id_from_slug(slug))


func has_id(id: int) -> bool:
	return _id_to_path.has(id)


func has_slug(slug: StringName) -> bool:
	return _slug_to_id.has(slug)
res://source/common/registry/content_registry.gd.uid
res://source/common/registry/content_registry_hub.gd

--- res://source/common/registry/content_registry_hub.gd ---
class_name ContentRegistryHub


static var _content_by_name: Dictionary = {}
static var _versions: Dictionary = {}


static func _static_init() -> void:
	if OS.has_feature("master-server") or OS.has_feature("gateway-server"):
		return
	const INDEXES_DIR: String = "res://source/common/registry/indexes/"
	for index_path: String in _safe_list_index_files(INDEXES_DIR):
		var content_index: ContentIndex = ResourceLoader.load(INDEXES_DIR + index_path)
		if not content_index:
			continue
		var name := index_path.trim_suffix("_index.tres")
		register_registry(name, content_index)


static func register_registry(content_name: StringName, content_index: ContentIndex) -> void:
	#var content_registry: ContentRegistry = ContentRegistry.new(content_index)
	_content_by_name[content_name] = ContentRegistry.new(content_index)
	_versions[content_name] = content_index.version


# Godot 4 doesn't expose ResourceLoader.list_directory; DirAccess works everywhere.
static func _safe_list_index_files(dir_path: String) -> PackedStringArray:
	var out: PackedStringArray = []
	var dir := DirAccess.open(dir_path)
	if dir == null:
		return out
	for file_name: String in dir.get_files():
		if file_name.ends_with("_index.tres"):
			out.append(file_name)
	return out


static func registry_of(content_name: StringName) -> ContentRegistry:
	return _content_by_name.get(content_name, null)


static func version_of(content_name: StringName) -> int:
	return _versions.get(content_name, 0)


static func id_from_slug(content_name: StringName, slug: StringName) -> int:
	return registry_of(content_name).id_from_slug(slug)


static func load_by_id(
	content_name: StringName,
	id: int,
	cache_mode: ResourceLoader.CacheMode = ResourceLoader.CACHE_MODE_REUSE
) -> Resource:
	var path: StringName = registry_of(content_name).path_from_id(id)
	if path.is_empty():
		return null
	return ResourceLoader.load(path, "", cache_mode)


static func load_by_slug(
	content_name: StringName,
	slug: StringName,
	cache_mode: ResourceLoader.CacheMode = ResourceLoader.CACHE_MODE_REUSE
) -> Resource:
	var path: StringName = registry_of(content_name).path_from_slug(slug)
	if path.is_empty():
		return null
	return ResourceLoader.load(path, "", cache_mode)


class CachedContent:
	pass
res://source/common/registry/content_registry_hub.gd.uid
res://source/common/registry/indexes/data_request_handlers_index.tres
res://source/common/registry/indexes/items_index.tres
res://source/common/registry/indexes/maps_index.tres
res://source/common/registry/indexes/sprites_index.tres
res://source/common/registry/path_registry.gd

--- res://source/common/registry/path_registry.gd ---
class_name PathRegistry
extends Node

static var _id_to_path: Dictionary
static var _path_to_id: Dictionary
static var _id_to_type: Dictionary
static var _id_to_nodepath: Dictionary

static var _next_id: int = 1
static var _version: int = 1
static var _initialized: bool = false

static func _static_init() -> void:
	if _initialized:
		return
	# ACTUALIZADO PARA 3D
	register_field(":position", Wire.Type.VEC3_F32)
	register_field(":rotation", Wire.Type.VEC3_F32) # Usaremos Euler angles (Vector3) para simplificar
	register_field(":scale", Wire.Type.VEC3_F32)
	# Campos explcitos para replicacin suave en cliente.
	register_field(":network_position", Wire.Type.VEC3_F32)
	register_field(":network_rotation", Wire.Type.VEC3_F32)
	# -------------------
	
	register_field(":flipped", Wire.Type.BOOL)
	register_field(":anim", Wire.Type.VARIANT)
	register_field(":pivot", Wire.Type.F32)
	register_field(":display_name", Wire.Type.VARIANT)
	register_field(":skin_id", Wire.Type.U16)
	register_field(":zone_flags", Wire.Type.U16)
	_initialized = true

static func ensure_initialized() -> void:
	_static_init()

static func reset() -> void:
	_id_to_path.clear()
	_path_to_id.clear()
	_id_to_type.clear()
	_id_to_nodepath.clear()
	_next_id = 1
	_version = 1

static func register_field(path: String, wire_type: Wire.Type = Wire.Type.VARIANT) -> int:
	var id: int = _path_to_id.get(path, 0)
	if id == 0:
		id = _next_id
		_next_id += 1
		_path_to_id[path] = id
		_id_to_path[id] = path
		_id_to_type[id] = wire_type
		_id_to_nodepath.erase(id)
		_version += 1
	else:
		if wire_type != Wire.Type.VARIANT and _id_to_type.get(id, Wire.Type.VARIANT) != wire_type:
			_id_to_type[id] = wire_type
			_version += 1
	return id

static func ensure_id(path: String) -> int:
	var existing: int = _path_to_id.get(path, 0)
	if existing != 0: return existing
	return register_field(path, _id_to_type.get(existing, Wire.Type.VARIANT))

static func id_of(path: String) -> int:
	return _path_to_id.get(path, 0)

static func path_of(id: int) -> String:
	return _id_to_path.get(id, "")

static func nodepath_of(id: int) -> NodePath:
	var np: NodePath = _id_to_nodepath.get(id, NodePath(""))
	if not np.is_empty(): return np
	var s: String = _id_to_path.get(id, "")
	if s == "": return NodePath("")
	np = NodePath(s)
	_id_to_nodepath[id] = np
	return np

static func type_of(id: int) -> int:
	return _id_to_type.get(id, Wire.Type.VARIANT)

static func version() -> int:
	return _version

static func get_full_map_updates() -> Array:
	var out: Array = []
	for id in _id_to_path.keys():
		out.append([int(id), _id_to_path[id], _id_to_type.get(id, Wire.Type.VARIANT)])
	return out

static func apply_map_updates(updates: Array) -> void:
	if updates.is_empty(): return
	for u in updates:
		var pid: int = int(u[0])
		var path: String = String(u[1])
		var wtype: int = int(u[2])
		_id_to_path[pid] = path
		_path_to_id[path] = pid
		_id_to_type[pid] = wtype
		_next_id = max(_next_id, pid + 1)
		_id_to_nodepath.erase(pid)
	_version += 1
res://source/common/registry/path_registry.gd.uid
res://source/common/utils/anim_utils.gd

--- res://source/common/utils/anim_utils.gd ---
#
#@onready var anim_player: AnimationPlayer = $AnimationPlayer
#@onready var anim_tree: AnimationTree = $AnimationTree
#
#const RIGHT_PREFIX := "HandOffset/HandPivot/RightHandSpot"
#const LEFT_PREFIX  := "HandOffset/HandPivot/LeftHandSpot"
#
#var _mirror_cache := {} # key: ObjectID or resource_path -> AnimationLibrary
#
#func equip_weapon(profile: WeaponAnimationProfile, hand: StringName):
	#var slot := "weapon_%s" % hand
	#if anim_player.has_animation_library(slot):
		#anim_player.remove_animation_library(slot)
#
	#var lib: AnimationLibrary = profile.library
	#if hand == &"left":
		#lib = _get_or_make_mirrored_library(profile.library)
#
	#anim_player.add_animation_library(slot, lib)
#
	#var side := (hand == &"right") ? "Right" : "Left"
	#anim_tree.set("parameters/OnFoot/%sIdle/animation"   % side, profile.idle_anim)   # e.g. "sword.idle"
	#anim_tree.set("parameters/OnFoot/%sAction/animation" % side, profile.attack_anim) # e.g. "sword.swing"
#
#func _get_or_make_mirrored_library(src: AnimationLibrary) -> AnimationLibrary:
	#var key := src.resource_path if src.resource_path != "" else str(src.get_instance_id())
	#if _mirror_cache.has(key):
		#return _mirror_cache[key]
#
	#var dst := AnimationLibrary.new()
	#for name in src.get_animation_list():
		#var anim := src.get_animation(name)
		#var mirrored := _mirror_animation(anim, RIGHT_PREFIX, LEFT_PREFIX)
		#dst.add_animation(name, mirrored) # same names on purpose
	#_mirror_cache[key] = dst
	#return dst
#
#func _mirror_animation(anim: Animation, from_prefix: String, to_prefix: String) -> Animation:
	#var out: Animation = anim.duplicate(true)
	#for i in range(out.get_track_count()):
		#var path: NodePath = out.track_get_path(i)
		#if str(path).begins_with(from_prefix):
			#var new_path := NodePath(str(path).replace(from_prefix, to_prefix))
			#out.track_set_path(i, new_path)
#
			#if out.track_get_type(i) == Animation.TYPE_VALUE:
				#var key_count := out.track_get_key_count(i)
				#var prop := str(path).get_slice(":", 1) if ":" in str(path) else ""
				#for k in range(key_count):
					#var v := out.track_get_key_value(i, k)
					#if prop == "rotation" and v is float:
						#v = -v
					#elif prop == "position" and v is Vector2:
						#v.x = -v.x
					#elif prop == "scale" and v is Vector2:
						#v.x = -v.x
					#out.track_set_key_value(i, k, v)
	#return out
res://source/common/utils/anim_utils.gd.uid
res://source/common/utils/cmdline_utils.gd

--- res://source/common/utils/cmdline_utils.gd ---
class_name CmdlineUtils


static func get_parsed_args() -> Dictionary:
	var arguments: Dictionary = {}
	for argument: String in OS.get_cmdline_args():
		if argument.contains("="):
			var key_value := argument.split("=")
			arguments[key_value[0].trim_prefix("--")] = key_value[1]
		else:
			# Options without an argument will be present in the dictionary,
			# with the value set to an empty string.
			arguments[argument.trim_prefix("--")] = ""
	return arguments
res://source/common/utils/cmdline_utils.gd.uid
res://source/common/utils/config_file_utils.gd

--- res://source/common/utils/config_file_utils.gd ---
class_name ConfigFileUtils


static func load_section(section: String, config_path: String) -> Dictionary:
	var config_file: ConfigFile = ConfigFile.new()
	var error: Error = config_file.load(config_path)
	if error != OK:
		printerr("Failed to load config at %s, error: %s" % [config_path, error_string(error)])
		return {"error": error, "config_path": config_path}
	
	var configuration: Dictionary
	for key: String in config_file.get_section_keys(section):
		configuration[key] = config_file.get_value(section, key)
	
	return configuration


static func load_section_safe(section: String, config_path: String, required: PackedStringArray) -> Dictionary:
	var config_file: ConfigFile = ConfigFile.new()
	var error: Error = config_file.load(config_path)
	if error != OK:
		printerr("Failed to load config at %s, error: %s" % [config_path, error_string(error)])
		return {"error": error, "config_path": config_path}
	
	assert(config_file.has_section(section))
	
	var configuration: Dictionary
	for key: String in config_file.get_section_keys(section):
		configuration[key] = config_file.get_value(section, key)
	
	
	for r: String in required:
		assert(configuration.has(r), "Missing required key '%s' in section [%s]" % [r, section])
	
	return configuration


static func load_section_with_defaults(section: String, config_path: String, defaults: Dictionary) -> Dictionary:
	var config_file: ConfigFile = ConfigFile.new()
	var error: Error = config_file.load(config_path)
	if error != OK:
		printerr("Failed to load config at %s, error: %s" % [config_path, error_string(error)])
		return {"error": error, "config_path": config_path}
	
	assert(config_file.has_section(section))
	
	var configuration: Dictionary = defaults.duplicate(true)
	
	for key: String in config_file.get_section_keys(section):
		configuration[key] = config_file.get_value(section, key, defaults.get(key))

	return configuration
res://source/common/utils/config_file_utils.gd.uid
res://source/common/utils/credentials_utils.gd

--- res://source/common/utils/credentials_utils.gd ---
extends RefCounted


const USERNAME_MIN_LEN: int = 3
const USERNAME_MAX_LEN: int = 20
const USERNAME_RESERVED: PackedStringArray = ["admin", "moderator", "guest"]

const PASSWORD_MIN_LEN: int = 6
const PASSWORD_MAX_LEN: int = 32

enum UsernameError {
	OK,
	EMPTY,
	TOO_SHORT,
	TOO_LONG,
	INVALID_CHARS,
	RESERVED,
	
}


static func is_valid_username(username: String) -> bool:
	if username.is_empty():
		return false
	return true


static func validate_username(username: String) -> Dictionary:
	if username.is_empty():
		return _fail(UsernameError.EMPTY, "Username required.")
	if username.length() < USERNAME_MIN_LEN:
		return _fail(UsernameError.TOO_SHORT, "Min %d characters." % USERNAME_MIN_LEN)
	if username.length() > USERNAME_MAX_LEN:
		return _fail(UsernameError.TOO_LONG, "Max %d characters." % USERNAME_MAX_LEN)
	if not username.is_valid_ascii_identifier():
		return _fail(UsernameError.INVALID_CHARS, "Use letters, digits, underscore.")
	if USERNAME_RESERVED.has(username.to_lower()):
		return _fail(UsernameError.RESERVED, "This name is reserved.")
	return {"code": UsernameError.OK, "message": ""}


static func validate_password(password: String) -> Dictionary:
	if password.is_empty():
		return _fail(UsernameError.EMPTY, "Password required.")
	if password.length() < PASSWORD_MIN_LEN:
		return _fail(UsernameError.TOO_SHORT, "Min %d characters." % PASSWORD_MIN_LEN)
	if password.length() > PASSWORD_MAX_LEN:
		return _fail(UsernameError.TOO_LONG, "Max %d characters." % PASSWORD_MAX_LEN)
	if not password.is_valid_ascii_identifier():
		return _fail(UsernameError.INVALID_CHARS, "Use letters, digits, underscore.")
	return {"code": UsernameError.OK, "message": ""}


static func _fail(code: UsernameError, message: String) -> Dictionary:
	return {"code": code, "message": message}
res://source/common/utils/credentials_utils.gd.uid
res://source/common/utils/debug_dump.gd

--- res://source/common/utils/debug_dump.gd ---
extends Node

# Optional runtime dump of files and the active scene tree.
# Enabled when the env var CLIFFWALD_DEBUG_DUMP is set to a non-empty value.
const ENV_ENABLE := "CLIFFWALD_DEBUG_DUMP"
const OUTPUT_PATH := "user://debug_dump.log"

func _ready() -> void:
	if not _enabled():
		return
	call_deferred("_dump_everything")


func _enabled() -> bool:
	if not OS.has_environment(ENV_ENABLE):
		return false
	return str(OS.get_environment(ENV_ENABLE)).strip_edges() != ""


func _dump_everything() -> void:
	var file := FileAccess.open(OUTPUT_PATH, FileAccess.WRITE)
	if file == null:
		printerr("DebugDump: cannot open %s" % OUTPUT_PATH)
		return

	file.store_line("== Debug dump ==")
	file.store_line("Time: %s" % Time.get_datetime_string_from_system())
	file.store_line("Version: %s" % Engine.get_version_info().get("string", "unknown"))
	var features: PackedStringArray = PackedStringArray()
	if OS.has_method("get_features"):
		features = OS.call("get_features")
	elif OS.has_method("get_feature_tags"):
		features = OS.call("get_feature_tags")
	file.store_line("Features: %s" % ", ".join(features))
	file.store_line("Args: %s" % " ".join(OS.get_cmdline_args()))
	file.store_line("Current scene: %s" % str(get_tree().current_scene))
	file.store_line("")

	file.store_line("=== Files (res://) ===")
	for path in _list_files("res://"):
		file.store_line(path)
	file.store_line("")

	file.store_line("=== Scene Tree ===")
	_dump_tree(get_tree().root, file, 0)
	file.close()
	print("DebugDump: wrote %s" % OUTPUT_PATH)


func _list_files(base: String) -> PackedStringArray:
	var result: PackedStringArray = PackedStringArray()
	var stack: Array[String] = []
	stack.append(base)
	while stack.size() > 0:
		var dir_path: String = stack.pop_back()
		var dir := DirAccess.open(dir_path)
		if dir == null:
			continue
		dir.list_dir_begin()
		var file_name := dir.get_next()
		while file_name != "":
			if file_name == "." or file_name == "..":
				file_name = dir.get_next()
				continue
			var full_path := dir.get_current_dir().path_join(file_name)
			if dir.current_is_dir():
				stack.append(full_path)
			else:
				result.append(full_path)
			file_name = dir.get_next()
		dir.list_dir_end()
	result.sort()
	return result


func _dump_tree(node: Node, file: FileAccess, depth: int) -> void:
	var line := "%s%s" % ["  ".repeat(depth), node.name]
	var script: Script = null
	if node is Node:
		script = node.get_script()
	if script and script.resource_path != "":
		line += " (%s)" % script.resource_path
	file.store_line(line)
	for child in node.get_children():
		_dump_tree(child, file, depth + 1)
res://source/common/utils/debug_dump.gd.uid
res://source/common/utils/editor_scripts/generate_crypto_key.gd

--- res://source/common/utils/editor_scripts/generate_crypto_key.gd ---
@tool
extends EditorScript


# Called when the script is executed (using File -> Run in Script Editor).
func _run() -> void:
	if not DirAccess.dir_exists_absolute("res://bin"):
		DirAccess.make_dir_absolute("res://bin")
	generate_crypto_key_and_certificate()
	EditorInterface.get_resource_filesystem().scan()

## Example of how to create a crypto key with its self signed certificate.
## The private key shouldn't be exported on the client machine.
## Files generated are stored at res://bin.
func generate_crypto_key_and_certificate() -> void:
	var crypto = Crypto.new()
	var key = CryptoKey.new()
	var cert = X509Certificate.new()
	key = crypto.generate_rsa(4096)
	cert = crypto.generate_self_signed_certificate(key, "CN=example.com,O=A Game Company,C=IT")
	key.save("res://bin/server_key.key")
	cert.save("res://bin/server_certificate.crt")
res://source/common/utils/editor_scripts/generate_crypto_key.gd.uid
res://source/common/utils/file_utils.gd

--- res://source/common/utils/file_utils.gd ---
class_name FileUtils


static func get_all_file_at(
	path: String,
	pattern: String = "*",
	recursive: bool = true
) -> PackedStringArray:
	var result_files: PackedStringArray = []
	var dir: DirAccess = DirAccess.open(path)
	
	if not dir:
		push_error("Failed to open directory at %s with error %s" % [
			path, error_string(DirAccess.get_open_error())
		])
		return result_files
	
	dir.list_dir_begin()
	var file_name: String = dir.get_next()

	while file_name:
		var full_path: String = path.path_join(file_name)
		if dir.current_is_dir() and recursive:
			result_files += get_all_file_at(full_path)
		elif file_name.match(pattern):
			result_files.append(full_path)
		file_name = dir.get_next()
	
	dir.list_dir_end()
	return result_files
res://source/common/utils/file_utils.gd.uid
res://source/common/utils/net_diagnostics.gd

--- res://source/common/utils/net_diagnostics.gd ---
class_name NetDiagnostics

# Opt-in network tracing for debugging replication.
static var enabled: bool = true # OS.has_environment("CLIFFWALD_NET_DEBUG")

static func log(msg: String) -> void:
	if enabled:
		print("[NET]", msg)

res://source/common/utils/net_diagnostics.gd.uid
res://source/common/utils/run_mmo.gd

--- res://source/common/utils/run_mmo.gd ---
@tool
extends Node

# Usage:
# godot --headless --script res://source/common/utils/run_mmo.gd
# or call RunMMO.launch_all() from the editor console.
#
# Launches master, gateway, world (headless) and two clients using the current Godot executable.

class_name RunMMO

const SERVER_FEATURES := [
	"master-server",
	"gateway-server",
	"world-server"
]

const CLIENT_COUNT := 2

static func _executable() -> String:
	return OS.get_executable_path()

static func _launch(name: String, args: PackedStringArray) -> void:
	var exe := _executable()
	var err := OS.create_process(exe, args, false)
	if err != OK:
		push_error("RunMMO: failed to launch %s (err=%d)" % [name, err])

static func launch_all() -> void:
	# Servers
	for feature in SERVER_FEATURES:
		_launch(feature, [
			"--path", ".",
			"--headless",
			"--feature", feature
		])
	# Clients
	for i in CLIENT_COUNT:
		_launch("client_%d" % i, [
			"--path", ".",
			"--feature", "client"
		])

func _ready() -> void:
	launch_all()
	# Exit the launcher instance.
	get_tree().quit()
res://source/common/utils/run_mmo.gd.uid
res://source/server/gateway/gateway_main.gd

--- res://source/server/gateway/gateway_main.gd ---
extends Node


func _ready() -> void:
	if DisplayServer.get_name() != "headless":
		DisplayServer.window_set_title("Gateway Server")
res://source/server/gateway/gateway_main.gd.uid
res://source/server/gateway/gateway_main.tscn

--- res://source/server/gateway/gateway_main.tscn ---
[gd_scene load_steps=4 format=3 uid="uid://bvnp50b85cxif"]

[ext_resource type="Script" uid="uid://3snlehf663qv" path="res://source/server/gateway/gateway_main.gd" id="1_v0yps"]
[ext_resource type="Script" uid="uid://l075wdufq4jr" path="res://source/server/gateway/master_gateway_client/gateway_manager_client.gd" id="3_m66nj"]
[ext_resource type="Script" uid="uid://bjxnn8cv1untw" path="res://source/server/gateway/http_server.gd" id="5_mufm1"]

[node name="GatewayMain" type="Node"]
script = ExtResource("1_v0yps")

[node name="GatewayManagerClient" type="Node" parent="."]
script = ExtResource("3_m66nj")

[node name="GatewayHTTPServer" type="Node" parent="."]
script = ExtResource("5_mufm1")
res://source/server/gateway/http_server.gd

--- res://source/server/gateway/http_server.gd ---
extends "res://addons/httpserver/http_server.gd"


const GatewayApi = preload("res://source/common/network/gateway_api.gd")
const CredentialsUtils = preload("res://source/common/utils/credentials_utils.gd")

var next_id: int

@onready var gateway_manager_client: GatewayManagerClient = $"../GatewayManagerClient"


func _ready() -> void:
	super._ready()
	router.register_route(
		HTTPClient.Method.METHOD_POST,
		&"/v1/login",
		handle_login
	)
	router.register_route(
		HTTPClient.Method.METHOD_POST,
		&"/v1/guest",
		handle_guest
	)
	router.register_route(
		HTTPClient.Method.METHOD_POST,
		
		&"/v1/world/character/create",
		handle_character_create
	)
	router.register_route(
		HTTPClient.Method.METHOD_POST,
		&"/v1/world/enter",
		handle_world_enter
	)
	router.register_route(
		HTTPClient.Method.METHOD_POST,
		&"/v1/world/characters",
		handle_world_characters
	)
	router.register_route(
		HTTPClient.Method.METHOD_POST,
		&"/v1/account/create",
		handle_account_creation
	)

func handle_login(payload: Dictionary) -> Dictionary:
	gateway_manager_client.login_request.rpc_id(
		1,
		payload["t-id"],
		payload["u"],
		payload["p"]
	)
	while true:
		var d: Dictionary = await gateway_manager_client.response_received
		if d.get("t-id", -1) == payload["t-id"]:
			return d
	return {"access_token":"abc","refresh_token":"r1","expires_in":900}


func handle_guest(payload: Dictionary) -> Dictionary:
	gateway_manager_client.create_account_request.rpc_id(1, payload["t-id"], "", "", true)
	while true:
		var d: Dictionary = await gateway_manager_client.response_received
		if d.get("t-id", -1) == payload["t-id"]:
			return d
	return {"error": 1}


func handle_character_create(payload: Dictionary) -> Dictionary:
	if not payload.has_all(
		[GatewayApi.KEY_TOKEN_ID, GatewayApi.KEY_ACCOUNT_USERNAME,
		"data", GatewayApi.KEY_WORLD_ID]
	):
		return {"error": 1}
	var character_data: Dictionary = payload.get("data", null) as Dictionary
	if character_data.is_empty():
		return {"error": 1}
	var result: Dictionary = CredentialsUtils.validate_username(character_data.get("name", ""))
	if result.get("code", CredentialsUtils.UsernameError.EMPTY) != CredentialsUtils.UsernameError.OK:
		return {"error": result}
	gateway_manager_client.create_player_character_request.rpc_id(
		1,
		payload[GatewayApi.KEY_TOKEN_ID],
		payload[GatewayApi.KEY_ACCOUNT_USERNAME],
		payload["data"],
		payload[GatewayApi.KEY_WORLD_ID]
	)
	while true:
		var d: Dictionary = await gateway_manager_client.response_received
		if d.get("t-id", -1) == payload["t-id"]:
			return d
	return {"error": 1}


func handle_world_characters(payload: Dictionary) -> Dictionary:
	gateway_manager_client.request_player_characters.rpc_id(
		1,
		payload["t-id"],
		payload["a-u"],
		payload["w-id"]
	)
	while true:
		var d: Dictionary = await gateway_manager_client.response_received
		if d.get("t-id", -1) == payload["t-id"]:
			return d
	return {"error": 1}


func handle_world_enter(payload: Dictionary) -> Dictionary:
	gateway_manager_client.request_login.rpc_id(
		1,
		payload["t-id"],
		payload["a-u"],
		payload["w-id"],
		payload["c-id"],
	)
	while true:
		var d: Dictionary = await gateway_manager_client.response_received
		if d.get("t-id", -1) == payload["t-id"]:
			return d
	return {"error": 1}


func handle_account_creation(payload: Dictionary) -> Dictionary:
	gateway_manager_client.create_account_request.rpc_id(
		1,
		payload["t-id"],
		payload["u"],
		payload["p"],
		false
	)
	while true:
		var d: Dictionary = await gateway_manager_client.response_received
		if d.get("t-id", -1) == payload["t-id"]:
			return d
	return {"error": 1}
res://source/server/gateway/http_server.gd.uid
res://source/server/gateway/master_gateway_client/gateway_manager_client.gd

--- res://source/server/gateway/master_gateway_client/gateway_manager_client.gd ---
class_name GatewayManagerClient
extends BaseMultiplayerEndpoint


signal account_creation_result_received(user_id: int, result_code: int, data: Dictionary)
signal login_succeeded(account_info: Dictionary, _worlds_info: Dictionary)
signal response_received(response: Dictionary)

var worlds_info: Dictionary


func _ready() -> void:
	var configuration: Dictionary = ConfigFileUtils.load_section(
		"gateway-manager-client",
		CmdlineUtils.get_parsed_args().get("config", "res://data/config/gateway_config.cfg")
	)
	
	var tls_options: TLSOptions = null
	if configuration.has("certificate_path") and not configuration.certificate_path.is_empty():
		var cert = load(configuration.certificate_path)
		if cert:
			tls_options = TLSOptions.client_unsafe(cert)

	create(Role.CLIENT, configuration.address, configuration.port, tls_options)


func _connect_multiplayer_api_signals(api: SceneMultiplayer) -> void:
	api.connected_to_server.connect(_on_connection_succeeded)
	api.connection_failed.connect(_on_connection_failed)
	api.server_disconnected.connect(_on_server_disconnected)


func _on_connection_succeeded() -> void:
	print("Successfully connected to the Gateway Manager as %d!" % multiplayer.get_unique_id())


func _on_connection_failed() -> void:
	print("Failed to connect to the Gateway Manager as Gateway.")
	# Try to reconnect.
	get_tree().create_timer(15.0).timeout.connect(_ready)


func _on_server_disconnected() -> void:
	print("Gateway Manager disconnected.")
	# Try to reconnect.
	get_tree().create_timer(15.0).timeout.connect(_ready)


@rpc("authority")
func update_worlds_info(_worlds_info: Dictionary) -> void:
	worlds_info = _worlds_info
	# Sanitizar puertos (evitar 0) por si algn world no envi correctamente.
	for w_id in worlds_info.keys():
		var w: Dictionary = worlds_info[w_id]
		if not (w is Dictionary):
			continue
		var p: int = int(w.get("port", 0))
		if p <= 0:
			w["port"] = 8087
		worlds_info[w_id] = w


@rpc("authority")
func fetch_auth_token(target_peer: int, auth_token: String, _address: String, _port: int) -> void:
	response_received.emit(
		{"t-id": target_peer, "token": auth_token, "address": _address, "port": _port}
	)
	#gateway.connected_peers[target_peer]["token_received"] = true
	#gateway.fetch_auth_token.rpc_id(target_peer, auth_token, _address, _port)


@rpc("any_peer")
func login_request(_peer_id: int, _username: String, _password: String) -> void:
	pass


@rpc("authority")
func login_result(peer_id: int, result: Dictionary) -> void:
	if result.has("error"):
		response_received.emit(
			{"t-id": peer_id, "a": result, "w": worlds_info, "error": result}
		)
		#gateway.login_result.rpc_id(peer_id, result["error"])
	else:
		#gateway.login_result.rpc_id(peer_id, 0)
		#login_succeeded.emit(peer_id, result, worlds_info)
		response_received.emit(
			{"t-id": peer_id, "a": result, "w": worlds_info}
		)


@rpc("any_peer")
func create_account_request(_peer_id: int, _username: String, _password: String, _is_guest: bool) -> void:
	pass


@rpc("authority")
func account_creation_result(peer_id: int, result_code: int, result: Dictionary) -> void:
	if result_code == OK:
		#login_succeeded.emit(peer_id, result, worlds_info)
		response_received.emit(
			{"t-id": peer_id, "a": result, "w": worlds_info}
		)
	#gateway.account_creation_result.rpc_id(peer_id, result_code)


@rpc("any_peer")
func create_player_character_request(_peer_id: int , _username: String, _character_data: Dictionary, _world_id: int) -> void:
	pass


@rpc("authority")
func player_character_creation_result(peer_id: int, result: Dictionary) -> void:
	response_received.emit(
		{"t-id": peer_id, "data": result}
	)
	#gateway.player_character_creation_result.rpc_id(
		#peer_id, result_code
	#)


@rpc("any_peer")
func request_player_characters(_peer_id: int, _username: String, _world_id: int) -> void:
	pass


@rpc("authority")
func receive_player_characters(peer_id: int, player_characters: Dictionary) -> void:
	response_received.emit(
		{"t-id": peer_id, "data": player_characters}
	)
	#gateway.receive_player_characters.rpc_id(peer_id, player_characters)


@rpc("any_peer")
func request_login(_peer_id: int, _username: String, _world_id: int, _character_id: int) -> void:
	pass


@rpc("any_peer")
func peer_disconnected_without_joining_world(_account_name: String) -> void:
	pass


#@rpc("any_peer")
#func request_world_info() -> void:
	#pass
#
#
#@rpc("authority")
#func receive_world_info(world_info: Dictionary) -> void:
	#response_received.emit(worlds_info)
res://source/server/gateway/master_gateway_client/gateway_manager_client.gd.uid
res://source/server/gateway/README.md
res://source/server/master/account_collection.tres
res://source/server/master/account_models/account.gd

--- res://source/server/master/account_models/account.gd ---
class_name AccountResource
extends Resource


@export var id: int
@export var username: String
@export var password: String

# peer_id = O if not connected
var peer_id: int = 0


func init(_id: int, _username: String, _password: String) -> void:
	id = _id
	username = _username
	password = _password
res://source/server/master/account_models/account.gd.uid
res://source/server/master/account_models/account_collection.gd

--- res://source/server/master/account_models/account_collection.gd ---
class_name AccountResourceCollection
extends Resource


@export var collection: Dictionary = {}

@export var next_account_id: int = 0
#@export var next_player_id: int = 0


func get_new_account_id() -> int:
	var new_account_id: int = next_account_id
	next_account_id += 1
	return new_account_id
res://source/server/master/account_models/account_collection.gd.uid
res://source/server/master/components/authentication_manager.gd

--- res://source/server/master/components/authentication_manager.gd ---
class_name AuthenticationManager
extends Node


@export var database: MasterDatabase


func _ready() -> void:
	pass


# TODO: Consider using a real authentication auth_token generator.
func generate_random_token() -> String:
	var characters :String = "abcdefghijklmnopqrstuvwxyz#$-+0123456789"
	var password :String = ""
	for i in range(12):
		password += characters[randi()% len(characters)]
	return password


func create_account(username: String, password: String, is_guest: bool) -> AccountResource:
	if not is_guest and database.username_exists(username):
		return null
	var account_id: int = database.account_collection.get_new_account_id()
	if is_guest:
		username = "guest%d" % account_id
		password = generate_random_token()
	var new_account: AccountResource = AccountResource.new()
	new_account.init(account_id, username, password)
	database.account_collection.collection[username] = new_account
	# Save on disk should only occur at specific times.
	# Temporary work around for debug purpose.
	database.save_account_collection()
	return new_account
res://source/server/master/components/authentication_manager.gd.uid
res://source/server/master/components/database.gd

--- res://source/server/master/components/database.gd ---
class_name MasterDatabase
extends Node


var account_collection: AccountResourceCollection
var account_collection_path: String = "res://source/server/master/account_collection.tres"


func _ready() -> void:
	tree_exiting.connect(save_account_collection)
	load_account_collection()


func load_account_collection() -> void:
	if ResourceLoader.exists(account_collection_path):
		account_collection = ResourceLoader.load(account_collection_path)
	else:
		account_collection = AccountResourceCollection.new()


func username_exists(username: String) -> bool:
	if account_collection.collection.has(username):
		return true
	return false


func validate_credentials(username: String, password: String) -> AccountResource:
	var account: AccountResource = null
	if account_collection.collection.has(username):
		account = account_collection.collection[username]
		if account.password == password:
			return account
	return null


func save_account_collection() -> void:
	ResourceSaver.save(account_collection, account_collection_path)
res://source/server/master/components/database.gd.uid
res://source/server/master/components/master_gateway_server/master_gateway_server.gd

--- res://source/server/master/components/master_gateway_server/master_gateway_server.gd ---
class_name GatewayManagerServer
extends BaseMultiplayerEndpoint


@export var world_manager: WorldManagerServer
@export var authentication_manager: AuthenticationManager
@export var database: MasterDatabase


func _ready() -> void:
	var configuration: Dictionary = ConfigFileUtils.load_section(
		"gateway-manager-server",
		CmdlineUtils.get_parsed_args().get("config", "res://data/config/master_config.cfg")
	)
	
	var tls_options: TLSOptions = null
	if configuration.has("certificate_path") and configuration.has("key_path"):
		var cert = load(configuration.certificate_path)
		var key = load(configuration.key_path)
		if cert and key:
			tls_options = TLSOptions.server(key, cert)

	create(Role.SERVER, configuration.bind_address, configuration.port, tls_options)


func _connect_multiplayer_api_signals(api: SceneMultiplayer) -> void:
	api.peer_connected.connect(_on_peer_connected)
	api.peer_disconnected.connect(_on_peer_disconnected)


func _on_peer_connected(peer_id: int) -> void:
	print("Gateway: %d is connected to GatewayManager." % peer_id)
	update_worlds_info.rpc_id(peer_id, world_manager.connected_worlds)


func _on_peer_disconnected(peer_id: int) -> void:
	print("Gateway: %d is disconnected to GatewayManager." % peer_id)


@rpc("authority")
func update_worlds_info(_worlds_info: Dictionary) -> void:
	pass


# Send an authentication auth_token to the gateway for a specific peer,
# used by the peer to connect to a game server.
@rpc("authority")
func fetch_auth_token(_target_peer: int, _auth_token: String, _address: String, _port: int) -> void:
	pass


@rpc("any_peer")
func login_request(peer_id: int, username: String, password: String) -> void:
	var gateway_id := multiplayer.get_remote_sender_id()
	var account: AccountResource = database.validate_credentials(
		username, password
	)
	if not account:
		login_result.rpc_id(gateway_id, peer_id, {"error": 50})
	elif account.peer_id:
		login_result.rpc_id(gateway_id, peer_id, {"error": 51})
	else:
		account.peer_id = peer_id
		login_result.rpc_id(
			gateway_id, peer_id,
			{"name": account.username, "id": account.id}
		)


@rpc("authority")
func login_result(_peer_id: int, _result: Dictionary) -> void:
	pass



@rpc("any_peer")
func create_account_request(peer_id: int, username: String, password: String, is_guest: bool) -> void:
	var gateway_id: int = multiplayer_api.get_remote_sender_id()
	var result_code: int = 0
	var return_data: Dictionary = {}
	var result: AccountResource = authentication_manager.create_account(username, password, is_guest)
	if result == null:
		result_code = 30
	else:
		return_data = {"name": result.username, "id": result.id}
		result.peer_id = peer_id
	account_creation_result.rpc_id(gateway_id, peer_id, result_code, return_data)



@rpc("authority")
func account_creation_result(_peer_id: int, _result_code: int, _data: Dictionary) -> void:
	pass


# Used to create the player's character.
@rpc("any_peer")
func create_player_character_request(peer_id: int, username: String, character_data: Dictionary, world_id: int) -> void:
	var gateway_id := multiplayer_api.get_remote_sender_id()
	if database.account_collection.collection.has(username):
		var account := database.account_collection.collection[username] as AccountResource
		if account.peer_id == peer_id and world_manager.connected_worlds.has(world_id):
			world_manager.create_player_character_request.rpc_id(
				world_id, gateway_id, peer_id, account.username, character_data
			)
		#else:
			#player_character_creation_result.rpc_id(gateway_id, peer_id, 80)


@rpc("authority")
func player_character_creation_result(_peer_id: int, result: Dictionary) -> void:
	pass


@rpc("any_peer")
func request_player_characters(peer_id: int, username: String, world_id: int) -> void:
	var gateway_id := multiplayer_api.get_remote_sender_id()
	if (
		world_manager.connected_worlds.has(world_id)
		and database.account_collection.collection.has(username)
	):
		var account := database.account_collection.collection[username] as AccountResource
		if account.peer_id == peer_id:
			world_manager.request_player_characters.rpc_id(
				world_id,
				gateway_id,
				peer_id,
				username,
			)


@rpc("authority")
func receive_player_characters(_player_characters: Dictionary) -> void:
	pass


@rpc("any_peer")
func request_login(peer_id: int, username: String, world_id: int, character_id: int) -> void:
	var gateway_id := multiplayer_api.get_remote_sender_id()
	if (
		world_manager.connected_worlds.has(world_id)
		and database.account_collection.collection.has(username)
		and database.account_collection.collection[username].peer_id == peer_id
	):
		world_manager.request_login.rpc_id(
			world_id,
			gateway_id,
			peer_id,
			username,
			character_id
		)


@rpc("any_peer")
func peer_disconnected_without_joining_world(account_name: String) -> void:
	if database.account_collection.collection.has(account_name):
		database.account_collection.collection[account_name].peer_id = 0
res://source/server/master/components/master_gateway_server/master_gateway_server.gd.uid
res://source/server/master/components/master_world_server/master_world_server.gd

--- res://source/server/master/components/master_world_server/master_world_server.gd ---
class_name WorldManagerServer
extends BaseMultiplayerEndpoint


@export var authentication_manager: AuthenticationManager
@export var gateway_manager: GatewayManagerServer
@export var database: MasterDatabase

# Active Connections
var next_world_id: int = 0
var connected_worlds: Dictionary = {}


func _ready() -> void:
	var configuration: Dictionary = ConfigFileUtils.load_section(
		"world-manager-server",
		CmdlineUtils.get_parsed_args().get("config", "res://data/config/master_config.cfg")
	)
	
	var tls_options: TLSOptions = null
	if configuration.has("certificate_path") and configuration.has("key_path"):
		var cert = load(configuration.certificate_path)
		var key = load(configuration.key_path)
		if cert and key:
			tls_options = TLSOptions.server(key, cert)

	create(Role.SERVER, configuration.bind_address, configuration.port, tls_options)


func _connect_multiplayer_api_signals(api: SceneMultiplayer) -> void:
	api.peer_connected.connect(_on_peer_connected)
	api.peer_disconnected.connect(_on_peer_disconnected)


func _on_peer_connected(peer_id: int) -> void:
	print("Gateway: %d is connected to GatewayManager." % peer_id)


func _on_peer_disconnected(peer_id: int) -> void:
	print("Gateway: %d is disconnected to GatewayManager." % peer_id)


@rpc("any_peer")
func fetch_server_info(info: Dictionary) -> void:
	var game_server_id := multiplayer_api.get_remote_sender_id()
	var port_val: int = int(info.get("port", 0))
	if port_val <= 0:
		port_val = 8087
	var addr_val: String = str(info.get("address", "127.0.0.1"))
	connected_worlds[game_server_id] = {
		"address": addr_val,
		"port": port_val,
		"info": info.get("info", info),
		"population": info.get("population", 0)
	}
	gateway_manager.update_worlds_info.rpc(connected_worlds)
	print(connected_worlds)


@rpc("authority")
func fetch_token(_auth_token: String, _username: String, _character_id: int) -> void:
	pass


@rpc("any_peer")
func player_disconnected(username: String) -> void:
	# In dev-direct or unexpected flows we might get usernames that are not in the DB.
	if not database or not database.account_collection:
		return
	if not database.account_collection.collection.has(username):
		print("WorldManagerServer.player_disconnected: username not found: %s" % username)
		return
	database.account_collection.collection[username].peer_id = 0


@rpc("authority")
func create_player_character_request(_gateway_id: int, _peer_id: int, _username: String, _character_data: Dictionary) -> void:
	pass


@rpc("any_peer")
func player_character_creation_result(gateway_id: int, peer_id: int, username: String, result_code: int) -> void:
	var world_id := multiplayer_api.get_remote_sender_id()
	if result_code:
		var auth_token := authentication_manager.generate_random_token()
		fetch_token.rpc_id(world_id, auth_token, username, result_code)
		gateway_manager.player_character_creation_result.rpc_id(
			gateway_id, peer_id, {
				"auth-token": auth_token,
				"address": connected_worlds[world_id]["address"],
				"port": connected_worlds[world_id]["port"]
			}
		)
		#await get_tree().create_timer(0.5).timeout
		#gateway_manager.fetch_auth_token.rpc_id(
			#gateway_id, peer_id, auth_token,
			#connected_worlds[world_id]["address"],
			#connected_worlds[world_id]["port"]
		#)
	else:
		gateway_manager.player_character_creation_result.rpc_id(
			gateway_id, peer_id, result_code
		)


@rpc("any_peer")
func request_player_characters(_gateway_id: int, _peer_id: int, _username: String) -> void:
	pass


@rpc("any_peer")
func request_login(_gateway_id: int, _peer_id: int, _username: String, _character_id: int) -> void:
	pass


@rpc("any_peer")
func result_login(result_code: int, gateway_id: int, peer_id: int, username: String, character_id: int) -> void:
	var world_id := multiplayer_api.get_remote_sender_id()
	if result_code == OK:
		var auth_token := authentication_manager.generate_random_token()
		fetch_token.rpc_id(world_id, auth_token, username, character_id)
		await get_tree().create_timer(0.5).timeout
		gateway_manager.fetch_auth_token.rpc_id(
			gateway_id, peer_id, auth_token,
			connected_worlds[world_id]["address"],
			connected_worlds[world_id]["port"]
		)


@rpc("any_peer")
func receive_player_characters(player_characters: Dictionary, gateway_id: int, peer_id: int) -> void:
	gateway_manager.receive_player_characters.rpc_id(
		gateway_id, peer_id, player_characters
	)
res://source/server/master/components/master_world_server/master_world_server.gd.uid
res://source/server/master/master_main.gd

--- res://source/server/master/master_main.gd ---
extends Node


func _ready() -> void:
	if DisplayServer.get_name() != "headless":
		DisplayServer.window_set_title("Master Server")
res://source/server/master/master_main.gd.uid
res://source/server/master/master_main.tscn

--- res://source/server/master/master_main.tscn ---
[gd_scene load_steps=6 format=3 uid="uid://bskg2xljsxctn"]

[ext_resource type="Script" uid="uid://bvryexdli570a" path="res://source/server/master/master_main.gd" id="1_6d3fm"]
[ext_resource type="Script" uid="uid://dx6y8xcifn6f8" path="res://source/server/master/components/master_gateway_server/master_gateway_server.gd" id="2_hsh87"]
[ext_resource type="Script" uid="uid://bcbl4b333f5l5" path="res://source/server/master/components/master_world_server/master_world_server.gd" id="3_qbesc"]
[ext_resource type="Script" uid="uid://d2cmewfb6gey3" path="res://source/server/master/components/authentication_manager.gd" id="4_1tf2k"]
[ext_resource type="Script" uid="uid://if1byogst5v3" path="res://source/server/master/components/database.gd" id="5_mync2"]

[node name="MasterMain" type="Node"]
script = ExtResource("1_6d3fm")

[node name="GatewayManagerServer" type="Node" parent="." node_paths=PackedStringArray("world_manager", "authentication_manager", "database")]
script = ExtResource("2_hsh87")
world_manager = NodePath("../WorldManagerServer")
authentication_manager = NodePath("../AuthenticationManager")
database = NodePath("../Database")

[node name="WorldManagerServer" type="Node" parent="." node_paths=PackedStringArray("authentication_manager", "gateway_manager", "database")]
script = ExtResource("3_qbesc")
authentication_manager = NodePath("../AuthenticationManager")
gateway_manager = NodePath("../GatewayManagerServer")
database = NodePath("../Database")

[node name="AuthenticationManager" type="Node" parent="." node_paths=PackedStringArray("database")]
script = ExtResource("4_1tf2k")
database = NodePath("../Database")

[node name="Database" type="Node" parent="."]
script = ExtResource("5_mync2")
res://source/server/master/README.md
res://source/server/player/player_server.gd.uid
res://source/server/world/components/chat_command/chat_command.gd

--- res://source/server/world/components/chat_command/chat_command.gd ---
class_name ChatCommand
extends RefCounted


var command_name: String = ""
var command_alias: PackedStringArray = []
var command_priority: int = 0


@warning_ignore("unused_parameter")
func execute(args: PackedStringArray, peer_id: int, server_instance: ServerInstance) -> String:
	return "Unknown command."
res://source/server/world/components/chat_command/chat_command.gd.uid
res://source/server/world/components/chat_command/global_commands/getid_command.gd

--- res://source/server/world/components/chat_command/global_commands/getid_command.gd ---
extends ChatCommand


func _init():
	command_name = 'getid'
	command_priority = 0


func execute(args: PackedStringArray, peer_id: int, server_instance: ServerInstance) -> String:
	if args.size() == 2:
		match args[1]:
			"network":
				return str(peer_id)
			"character":
				return str(server_instance.world_server.connected_players[peer_id].player_id)
			"instance":
				return server_instance.instance_resource.instance_name
	return "Invalid command format: /getid network/character/instance"
res://source/server/world/components/chat_command/global_commands/getid_command.gd.uid
res://source/server/world/components/chat_command/global_commands/heal_command.gd

--- res://source/server/world/components/chat_command/global_commands/heal_command.gd ---
extends ChatCommand


func _init():
	command_name = 'heal'
	command_priority = 2


func execute(args: PackedStringArray, peer_id: int, server_instance: ServerInstance) -> String:
	if args.size() != 3:
		return "Invalid command format: /heal <target> <amount>"
	
	var target: int = peer_id if args[1] == "self" else args[1].to_int()
	var amount: int = args[2].to_int()
	
	if server_instance.get_player(target) == null:
		return "Target not found."
	
	var error: bool = server_instance.set_player_attr_current(target, &"health", amount)
	return ("/heal %s %s" % [str(target), str(amount)]) + (" successful" if error else " failed")
res://source/server/world/components/chat_command/global_commands/heal_command.gd.uid
res://source/server/world/components/chat_command/global_commands/help_command.gd

--- res://source/server/world/components/chat_command/global_commands/help_command.gd ---
extends ChatCommand


func _init():
	command_name = 'help'
	command_priority = 0
	command_alias = ['h']


func execute(_args: PackedStringArray, peer_id: int, server_instance: ServerInstance) -> String:
	var player_roles: PackedStringArray
	var possible_commands: PackedStringArray

	player_roles = server_instance.local_role_assignments.get(peer_id, [])
	player_roles.append("default")
	for role: String in player_roles:
		var role_data: Dictionary = server_instance.local_role_definitions.get(role, {})
		if role_data:
			possible_commands.append_array(role_data.get("commands", []))
	
	player_roles = server_instance.world_server.connected_players[peer_id].server_roles.keys() as PackedStringArray
	player_roles.append("default")
	for role: String in player_roles:
		var role_data: Dictionary = server_instance.global_role_definitions.get(role)
		if role_data:
			possible_commands.append_array(role_data.get("commands", []))

	return "\n".join(possible_commands)
res://source/server/world/components/chat_command/global_commands/help_command.gd.uid
res://source/server/world/components/chat_command/global_commands/selfadmin_command.gd

--- res://source/server/world/components/chat_command/global_commands/selfadmin_command.gd ---
extends ChatCommand


func _init():
	command_name = 'selfadmin'
	command_priority = 2

	# For debugging
	if OS.has_feature("debug") or OS.has_feature("editor"):
		command_priority = 0

# Only running in debug mode for now.
func execute(_args: PackedStringArray, peer_id: int, server_instance: ServerInstance) -> String:
	server_instance.world_server.connected_players[peer_id].server_roles["senior_admin"] = {}
	return "Yes admin"
res://source/server/world/components/chat_command/global_commands/selfadmin_command.gd.uid
res://source/server/world/components/chat_command/global_commands/set_command.gd

--- res://source/server/world/components/chat_command/global_commands/set_command.gd ---
extends ChatCommand


func _init():
	command_name = 'set'
	command_priority = 100


func execute(args: PackedStringArray, peer_id: int, server_instance: ServerInstance) -> String:
	if args.size() != 4:
		return "Invalid command format: /set <target> <path> <value>"
	
	var target: int = peer_id if args[1] == "self" else args[1].to_int()
	var path: NodePath = args[2]
	var value: Variant = str_to_var(args[3])
	
	#print_debug(value)
	if path.is_empty() or not value:
		return "Invalid command format: /set <target> <path> <value>"
	
	var player: Node = server_instance.get_player(peer_id)
	if not player:
		return "Target not found."
	
	var error: bool = false
	var current_value: Variant = player.get_indexed(path)
	if current_value == null:
		error = true
	else:
		var typeof_value: int = typeof(current_value)
		value = type_convert(value, typeof_value)
		if value:
			player.syn.set_by_path(path, value)
		else:
			error = true
	print_debug(
		("/set %s %s" % [str(target), str(value)]) + (" successful" if not error else " failed")
	)
	return ("/set %s %s" % [str(target), str(value)]) + (" successful" if not error else " failed")
res://source/server/world/components/chat_command/global_commands/set_command.gd.uid
res://source/server/world/components/chat_command/global_commands/size_command.gd

--- res://source/server/world/components/chat_command/global_commands/size_command.gd ---
extends ChatCommand


func _init():
	command_name = 'size'
	command_priority = 2


func execute(args: PackedStringArray, peer_id: int, server_instance: ServerInstance) -> String:
	if args.size() != 3:
		return "Invalid command format: /size <target|self> <size>"
	
	var target: int = peer_id if args[1] == "self" else args[1].to_int()
	var amount: int = clampi(args[2].to_int(), 1, 4)
	
	if server_instance.get_player(target) == null:
		return "Target not found."
	
	var ok := server_instance.set_player_path_value(target, ^":scale", Vector2(amount, amount))
	return ("/size %s %s" % [str(target), str(amount)]) + (" successful" if ok else " failed")
res://source/server/world/components/chat_command/global_commands/size_command.gd.uid
res://source/server/world/components/chat_command/global_commands/toogle_role_command.gd

--- res://source/server/world/components/chat_command/global_commands/toogle_role_command.gd ---
extends ChatCommand


func _init():
	command_name = 'toggle'
	command_priority = 2


func execute(args: PackedStringArray, peer_id: int, server_instance: ServerInstance) -> String:
	if not args.size() == 3:
		return "Format <role> <active/desactivate>"
	var player: PlayerResource = server_instance.world_server.connected_players.get(peer_id, null)
	if not player:
		return "Unknown peer."
	if player.server_roles.has(args[1]):
		player.server_roles["active"] = true if args[2] == "active" else false 
		return "Your role state has been changed."
	return "You don't have this role."
res://source/server/world/components/chat_command/global_commands/toogle_role_command.gd.uid
res://source/server/world/components/console.gd

--- res://source/server/world/components/console.gd ---
extends Node

## ANSI color codes
const WHITE: String = "[1;0m"
const DARK_RED: String = "[31m"
const GREEN: String = "[32m"
const DARK_YELLOW: String = "[33m"
const MAGENTA: String = "[35m"

signal stdin_readed

@export var database: WorldDatabase
@export var world_server: WorldServer

var escape: String = PackedByteArray([0x1b]).get_string_from_ascii()

var define_commands: Dictionary = {
	clear_console: ["clear", "clear_console"],
	print_player_count: ["print_player_count", "player_count"],
	shutdown: ["q", "quit", "shutdown", "exit"],
	save: ["save"],
}
var commands: Dictionary = {}

var stdin_thread: Thread
var cmd_begin: String = str("\n" + escape + 
	DARK_YELLOW + "admin@tiny-mmo " + escape + MAGENTA + "EOS " + 
	escape + GREEN + "~" + escape + WHITE + "\n" + "$ ")


func _ready() -> void:
	if not OS.has_feature("console"):
		return
	for callable: Callable in define_commands:
		for keyword: String in define_commands[callable]:
			commands[keyword] = callable
	print_rich(escape + "[2J" + escape + "[;H" + "[color=purple]Tiny MMO's server console:[/color]")
	stdin_readed.connect(self._on_stdin_readed)
	start_read_stdin_thread()


func start_read_stdin_thread() -> bool:
	stdin_thread = Thread.new()
	var _error: Error = stdin_thread.start(read_stdin)
	return _error


func read_stdin() -> String:
	printraw(cmd_begin)
	var buffer: String = OS.read_string_from_stdin(80)
	stdin_readed.emit.call_deferred()
	return buffer


func _on_stdin_readed() -> void:
	var stdin: String
	if stdin_thread.is_started():
		if not stdin_thread.is_alive():
			stdin = stdin_thread.wait_to_finish() as String
			if not stdin.strip_edges(true).is_empty():
				if await execute_command(stdin):
					start_read_stdin_thread()
			else:
				start_read_stdin_thread()


func _exit_tree() -> void:
	if not stdin_thread:
		return
	if stdin_thread.is_started():
		if stdin_thread.is_alive():
			stdin_thread.wait_to_finish()


func execute_command(stdin: String) -> bool:
	var inputs: PackedStringArray
	var command: String
	var to_call: Callable
	
	stdin = stdin.strip_escapes()
	inputs = stdin.split(" ", false)
	command = inputs[0]
	if commands.has(command):
		to_call = commands[command]
	if to_call.is_valid():
		printraw(escape + GREEN)
		if inputs.size() == 2:
			await to_call.call(inputs[1])
		else:
			await to_call.call()
	else:
		print(escape + DARK_RED + "Command doesn't exist.")
	return false if to_call == shutdown else true


func print_player_count() -> void:
	print("Current player connected: %d" % world_server.connected_players.size())


func clear_console() -> void:
	printraw(escape + "[2J")


func save() -> void:
	database.save_world_database()
	print("Saved!")


func shutdown() -> void:
	print("Saving before shutdown.")
	save()
	print("Shutdown server in:")
	print("3")
	await get_tree().create_timer(1.0).timeout
	print("2")
	await get_tree().create_timer(1.0).timeout
	print("1")
	await get_tree().create_timer(1.0).timeout
	print("Server offline.")
	get_tree().quit.call_deferred()
res://source/server/world/components/console.gd.uid
res://source/server/world/components/data_request_handlers/action.perform.gd

--- res://source/server/world/components/data_request_handlers/action.perform.gd ---
extends DataRequestHandler


func data_request_handler(
	peer_id: int,
	instance: ServerInstance,
	args: Dictionary
) -> Dictionary:
	var player = instance.players_by_peer_id.get(peer_id, null)
	if not player:
		return {}
	
	# Armas y acciones legado deshabilitadas; GestureManager manejar hechizos.
	return {}
res://source/server/world/components/data_request_handlers/action.perform.gd.uid
res://source/server/world/components/data_request_handlers/attribute.get.gd

--- res://source/server/world/components/data_request_handlers/attribute.get.gd ---
extends DataRequestHandler


func data_request_handler(
	peer_id: int,
	instance: ServerInstance,
	args: Dictionary
) -> Dictionary:
	var player = instance.players_by_peer_id.get(peer_id, null)
	if not player:
		return {}
	return {
		"points": player.player_resource.available_attributes_points,
		"attr": player.player_resource.attributes
	}
res://source/server/world/components/data_request_handlers/attribute.get.gd.uid
res://source/server/world/components/data_request_handlers/attribute.spend.gd

--- res://source/server/world/components/data_request_handlers/attribute.spend.gd ---
extends DataRequestHandler


const AttributesMap = preload("res://source/common/gameplay/combat/attributes/attributes_map.gd")


func data_request_handler(
	peer_id: int,
	instance: ServerInstance,
	args: Dictionary
) -> Dictionary:
	# Sin progresin de atributos en este diseo.
	return {}
res://source/server/world/components/data_request_handlers/attribute.spend.gd.uid
res://source/server/world/components/data_request_handlers/chat.command.exec.gd

--- res://source/server/world/components/data_request_handlers/chat.command.exec.gd ---
extends DataRequestHandler


func data_request_handler(
	peer_id: int,
	instance: ServerInstance,
	args: Dictionary
) -> Dictionary:
	var command_name: String = args.get("cmd", "")
	if command_name.is_empty():
		return {}
	
	var result: String
	var chat_command: ChatCommand = find_command(command_name, instance)
	if chat_command and has_command_permission(chat_command, peer_id, instance):
		result = chat_command.execute(
			args.get("params", []),
			peer_id,
			instance
		)
	else:
		result = "Command not found."
	instance.data_push.rpc_id(
		peer_id,
		&"chat.message",
		{"text": result, "name": "Server", "id": 1}
	)
	return {command_name: args}


func find_command(command_name: String, instance: ServerInstance) -> ChatCommand:
	var command_list = instance.global_chat_commands
	if command_name in command_list:
		return command_list[command_name]

	# Alias checking
	for command: ChatCommand in command_list.values():
		if command.command_alias.has(command_name):
			return command

	return null


func has_command_permission(
	command: ChatCommand,
	peer_id: int,
	instance: ServerInstance
) -> bool:
	var player: PlayerResource = instance.world_server.connected_players.get(peer_id)
	if not player:
		return false

	# Check if command is possible by default.
	if command.command_priority <= 0:
		return true
	
	var player_roles: Dictionary = player.server_roles
	for role in player_roles:
		var role_data = instance.global_role_definitions[role]
		if command.command_priority <= role_data.get('priority', 0):
			return true

	return false
res://source/server/world/components/data_request_handlers/chat.command.exec.gd.uid
res://source/server/world/components/data_request_handlers/chat.message.send.gd

--- res://source/server/world/components/data_request_handlers/chat.message.send.gd ---
extends DataRequestHandler


func data_request_handler(
	peer_id: int,
	instance: ServerInstance,
	args: Dictionary
) -> Dictionary:
	var message: Dictionary = {
		"text": args.get("text", ""),
		"channel": args.get("channel", 0),
		"name": instance.players_by_peer_id[peer_id].player_resource.display_name,
		"id": peer_id
		#"time": Time.get_
	}
	instance.propagate_rpc(instance.data_push.bind(&"chat.message", message))
	return {} # ACK later #{"error": 0}
res://source/server/world/components/data_request_handlers/chat.message.send.gd.uid
res://source/server/world/components/data_request_handlers/data_request_handler.gd

--- res://source/server/world/components/data_request_handlers/data_request_handler.gd ---
class_name DataRequestHandler


func data_request_handler(
	peer_id: int,
	instance: ServerInstance,
	args: Dictionary
) -> Dictionary:
	return {}
res://source/server/world/components/data_request_handlers/data_request_handler.gd.uid
res://source/server/world/components/data_request_handlers/guild.create.gd

--- res://source/server/world/components/data_request_handlers/guild.create.gd ---
extends DataRequestHandler


func data_request_handler(
	peer_id: int,
	instance: ServerInstance,
	args: Dictionary
) -> Dictionary:
	var club_name: String = args.get("name", "")
	var player_resource: PlayerResource = instance.world_server.connected_players.get(peer_id, null)
	
	if club_name.is_empty() or not player_resource:
		return {}
	
	var club_created: bool = instance.world_server.database.player_data.create_club(
		club_name, player_resource.player_id
	)
	if not club_created:
		return {}
	
	var club: Club = instance.world_server.database.player_data.clubs.get(club_name)
	if not club:
		return {}
	
	club.add_member(player_resource.player_id, "Leader")
	club.leader_id = player_resource.player_id
	
	player_resource.club = club
	
	var club_info: Dictionary = {
		"name": club.club_name,
		"size": club.members.size(),
		"is_in_club": true,
	}
	return club_info
res://source/server/world/components/data_request_handlers/guild.create.gd.uid
res://source/server/world/components/data_request_handlers/guild.get.gd

--- res://source/server/world/components/data_request_handlers/guild.get.gd ---
extends DataRequestHandler


func data_request_handler(
	peer_id: int,
	instance: ServerInstance,
	args: Dictionary
) -> Dictionary:
	var to_get: String = args.get("q", "")
	if to_get.is_empty():
		return {}
	var club: Club = instance.world_server.database.player_data.clubs.get(to_get)
	var club_info: Dictionary
	if club:
		club_info = {"name": club.club_name, "size": club.members.size()}
	return club_info
res://source/server/world/components/data_request_handlers/guild.get.gd.uid
res://source/server/world/components/data_request_handlers/guild.quit.gd

--- res://source/server/world/components/data_request_handlers/guild.quit.gd ---
extends DataRequestHandler


func data_request_handler(
	peer_id: int,
	instance: ServerInstance,
	args: Dictionary
) -> Dictionary:
	var player_resource: PlayerResource = instance.world_server.connected_players.get(peer_id, null)
	if not player_resource or not player_resource.club:
		return {}
	
	player_resource.club.remove_member(player_resource.player_id)
	player_resource.club = null
	
	return {}
res://source/server/world/components/data_request_handlers/guild.quit.gd.uid
res://source/server/world/components/data_request_handlers/guild.search.gd

--- res://source/server/world/components/data_request_handlers/guild.search.gd ---
extends DataRequestHandler


func data_request_handler(
	peer_id: int,
	instance: ServerInstance,
	args: Dictionary
) -> Dictionary:
	const MAX_RESULT: int = 10
	var i: int = 0
	var result: Dictionary
	var club_names: PackedStringArray = instance.world_server.database.player_data.clubs.keys()
	var to_search: String = args.get("q", "")
	for club_name: String in club_names:
		if club_name.to_lower().contains(to_search):
			result[club_name] = 0
		if i >= MAX_RESULT:
			break
		i += 1
	return result
res://source/server/world/components/data_request_handlers/guild.search.gd.uid
res://source/server/world/components/data_request_handlers/guild.self.gd

--- res://source/server/world/components/data_request_handlers/guild.self.gd ---
extends DataRequestHandler


func data_request_handler(
	peer_id: int,
	instance: ServerInstance,
	args: Dictionary
) -> Dictionary:
	var player = instance.players_by_peer_id.get(peer_id)
	if not player:
		return {}
	
	var club: Club = player.player_resource.club
	var data: Dictionary
	if not club:
		return {}
	data = {"name": club.club_name}
	return data
res://source/server/world/components/data_request_handlers/guild.self.gd.uid
res://source/server/world/components/data_request_handlers/inventory.get.gd

--- res://source/server/world/components/data_request_handlers/inventory.get.gd ---
extends DataRequestHandler


func data_request_handler(
	peer_id: int,
	instance: ServerInstance,
	args: Dictionary
) -> Dictionary:
	return instance.players_by_peer_id[peer_id].player_resource.inventory
res://source/server/world/components/data_request_handlers/inventory.get.gd.uid
res://source/server/world/components/data_request_handlers/item.equip.gd

--- res://source/server/world/components/data_request_handlers/item.equip.gd ---
extends DataRequestHandler


func data_request_handler(
	peer_id: int,
	instance: ServerInstance,
	args: Dictionary
) -> Dictionary:
	# Sin sistema de equipamiento en Cliffwald HP; solo monedas/cromos.
	return {}
res://source/server/world/components/data_request_handlers/item.equip.gd.uid
res://source/server/world/components/data_request_handlers/profile.get.gd

--- res://source/server/world/components/data_request_handlers/profile.get.gd ---
extends DataRequestHandler


func data_request_handler(
	peer_id: int,
	instance: ServerInstance,
	args: Dictionary
) -> Dictionary:
	var to_get: int = args.get("q", 0)
	if not to_get:
		return {}
	var target_player = instance.players_by_peer_id.get(to_get, null)
	if not target_player:
		return {}
	var player_resource: PlayerResource = target_player.player_resource
	var profile: Dictionary = {
		"name": player_resource.display_name,
		"stats": {
			"money": player_resource.golds,
			"skin_id": player_resource.skin_id,
			"character_class": "???",
			"level": player_resource.level
		}
	}
	return profile
res://source/server/world/components/data_request_handlers/profile.get.gd.uid
res://source/server/world/components/instance_manager.gd

--- res://source/server/world/components/instance_manager.gd ---
class_name InstanceManagerServer
extends SubViewportContainer


const INSTANCE_COLLECTION_PATH: String = "res://source/common/gameplay/maps/instance/instance_collection/"
const GLOBAL_COMMANDS_PATH: String = "res://source/server/world/components/chat_command/global_commands/"

var loading_instances: Dictionary
var instance_collection: Array[InstanceResource]
var _default_instance: InstanceResource
var _pending_default_spawns: Array[int] = []
var _pending_attempts: Dictionary = {}
var _spawn_retry_timer: Timer

@export var world_server: WorldServer


func start_instance_manager() -> void:
	if world_server:
		ServerInstance.world_server = world_server
	else:
		printerr("InstanceManager: world_server is null!")
	
	setup_global_commands_and_roles()

	set_instance_collection.call_deferred()
	
	# Timer which will call unload_unused_instances
	var timer: Timer = Timer.new()
	timer.wait_time = 20.0 # 20.0 is for testing, consider increasing it
	
	timer.autostart = true
	timer.timeout.connect(unload_unused_instances)
	add_sibling(timer)

	# Timer to retry pending spawns without usar await
	_spawn_retry_timer = Timer.new()
	_spawn_retry_timer.wait_time = 0.2
	_spawn_retry_timer.one_shot = true
	_spawn_retry_timer.autostart = false
	_spawn_retry_timer.timeout.connect(_on_spawn_retry_timeout)
	add_child(_spawn_retry_timer)

func setup_global_commands_and_roles() -> void:
	var files: PackedStringArray = FileUtils.get_all_file_at(GLOBAL_COMMANDS_PATH, "*.gd")
	if files.is_empty():
		return
	
	var commands := ServerInstance.global_chat_commands
	for file_path: String in files:
		var command = load(file_path).new()
		commands.set(command.command_name, command)

	var roles := ServerInstance.global_role_definitions
	for role: String in roles:
		var role_data: Dictionary = roles[role]
		var role_commands: Array
		
		for command_name: String in commands:
			var command = commands[command_name]
			if command.command_priority <= role_data.get("priority", 0):
				role_commands.append(command_name)

		role_data['commands'] = role_commands


@rpc("authority", "call_remote", "reliable", 0)
func charge_new_instance(_map_path: String, _instance_id: String) -> void:
	pass

@rpc("any_peer", "call_remote", "reliable", 0)
func ready_to_enter_instance() -> void:
	var peer_id: int = multiplayer.get_remote_sender_id()
	print("InstanceManager: Player %d ready to enter. Spawning in Default Instance..." % peer_id)
	
	if _default_instance and not _default_instance.charged_instances.is_empty():
		var instance = _default_instance.charged_instances[0]
		if instance and instance.instance_map:
			var spawner = instance.instance_map.get_node_or_null("SimpleSpawner")
			if spawner and spawner.has_method("spawn_player"):
				var player_resource = ServerInstance.world_server.connected_players.get(peer_id)
				spawner.spawn_player(peer_id, player_resource)
				instance.connected_peers.append(peer_id)


func _on_player_entered_warper(player: Node, current_instance, warper) -> void:
	var instance_index: int = -1 # Will be useful later
	var target_instance
	var instance_resource = warper.target_instance
	if not instance_resource:
		return
	
	if instance_resource.can_join_instance(player, instance_index):
		target_instance = instance_resource.get_instance()
		if target_instance:
			player_switch_instance(target_instance, warper.target_id, player, current_instance)
		else:
			queue_charge_instance(
				instance_resource,
				player_switch_instance.bind(warper.target_id, player, current_instance)
			)
	else:
		return


func queue_charge_instance(instance_resource: InstanceResource, callback: Callable) -> void:
	if loading_instances.has(instance_resource):
		loading_instances[instance_resource].ready.connect(
			callback.bind(loading_instances[instance_resource])
		)
		return
	var new_instance: ServerInstance = prepare_instance(instance_resource)
	new_instance.ready.connect(callback.bind(new_instance), CONNECT_ONE_SHOT)
	add_child(new_instance, true)


func player_switch_instance(
	target_instance: ServerInstance,
	warper_target_id: int,
	player: Node,
	current_instance: ServerInstance,
) -> void:
	var peer_id: int = player.name.to_int()
	if current_instance.connected_peers.has(peer_id):
		current_instance.despawn_player(peer_id, false)
	else:
		return
	charge_new_instance.rpc_id(
		peer_id,
		target_instance.instance_resource.map_path,
		target_instance.name
	)
	target_instance.awaiting_peers[peer_id] = {
		"player": player,
		"target_id": warper_target_id
	}


func charge_instance(instance_resource: InstanceResource) -> void:
	if loading_instances.has(instance_resource):
		return
	var new_instance: ServerInstance = prepare_instance(instance_resource)
	add_child.call_deferred(new_instance, true)


func prepare_instance(instance_resource: InstanceResource) -> ServerInstance:
	# Force re-compile
	var instance: ServerInstance = ServerInstance.new()
	loading_instances[instance_resource] = instance
	instance.name = str(instance.get_instance_id())
	instance.instance_resource = instance_resource
	instance.player_entered_warper.connect(_on_player_entered_warper)
	instance.ready.connect(
		func():
			loading_instances.erase(instance_resource)
			instance_resource.charged_instances.append(instance),
		CONNECT_ONE_SHOT
	)
	instance.load_map(instance_resource.map_path)
	return instance


func set_instance_collection() -> void:
	_default_instance = null
	
	for file_path: String in FileUtils.get_all_file_at(INSTANCE_COLLECTION_PATH, "*.tres"):
		print(file_path)
		instance_collection.append(ResourceLoader.load(file_path, "InstanceResource"))
	
	for instance_resource: InstanceResource in instance_collection:
		if instance_resource.load_at_startup:
			charge_instance(instance_resource)
		if instance_resource.instance_name == "Overworld":
			_default_instance = instance_resource
	
	# Asegurar que la instancia por defecto est cargada
	if _default_instance and _default_instance.charged_instances.is_empty() and not loading_instances.has(_default_instance):
		charge_instance(_default_instance)

	# Spawn tras auth, con reintentos controlados
	world_server.player_authenticated.connect(
		func(peer_id: int):
			_schedule_default_spawn(peer_id)
	)

func _schedule_default_spawn(peer_id: int) -> void:
	if _pending_default_spawns.has(peer_id):
		return
	_pending_default_spawns.append(peer_id)
	_pending_attempts[peer_id] = 0
	_try_dispatch_default_spawns()

func _try_dispatch_default_spawns() -> void:
	if not world_server or not world_server.multiplayer_api:
		return
	var mp: MultiplayerPeer = world_server.multiplayer_api.multiplayer_peer
	var dispatched: Array[int] = []
	for pid in _pending_default_spawns:
		if _dispatch_default_spawn(pid, mp):
			dispatched.append(pid)
	for pid in dispatched:
		_pending_default_spawns.erase(pid)
		_pending_attempts.erase(pid)
	if not _pending_default_spawns.is_empty():
		_spawn_retry_timer.start()

func _dispatch_default_spawn(peer_id: int, mp: MultiplayerPeer) -> bool:
	if _default_instance == null:
		return false
	
	# CORRECCIN: Usar get_peers() de la API en lugar de mp.has_peer()
	# Si mp es nulo o el peer_id no est en la lista de peers conectados, fallamos.
	if mp == null or not peer_id in world_server.multiplayer_api.get_peers():
		return false
		
	if _default_instance.charged_instances.is_empty():
		return false
		
	print("InstanceManager: Player %d authenticated, sending to Overworld." % peer_id)
	charge_new_instance.rpc_id(
		peer_id,
		_default_instance.map_path,
		_default_instance.charged_instances[0].name
	)
	return true

func _on_spawn_retry_timeout() -> void:
	if not world_server or not world_server.multiplayer_api:
		return
	var mp: MultiplayerPeer = world_server.multiplayer_api.multiplayer_peer
	var to_remove: Array[int] = []
	for pid in _pending_default_spawns:
		_pending_attempts[pid] = _pending_attempts.get(pid, 0) + 1
		if _dispatch_default_spawn(pid, mp):
			to_remove.append(pid)
		elif _pending_attempts[pid] > 50: # ~10s de reintentos
			to_remove.append(pid)
	for pid in to_remove:
		_pending_default_spawns.erase(pid)
		_pending_attempts.erase(pid)
	if not _pending_default_spawns.is_empty():
		_spawn_retry_timer.start()


func unload_unused_instances() -> void:
	for child in get_children():
		if not child is ServerInstance:
			continue
		var instance: ServerInstance = child as ServerInstance
		if instance.instance_resource.load_at_startup:
			continue
		if instance.connected_peers:
			continue
		instance.instance_resource.charged_instances.erase(instance)
		instance.queue_free()
res://source/server/world/components/instance_manager.gd.uid
res://source/server/world/components/instance_server.gd

--- res://source/server/world/components/instance_server.gd ---
class_name ServerInstance
extends SubViewport

signal player_entered_warper(player: Node, current_instance, warper)

static var world_server: WorldServer
static var global_chat_commands: Dictionary = {}
static var global_role_definitions: Dictionary = preload("res://source/server/world/data/server_roles.tres").get_roles()

var connected_peers: PackedInt64Array = PackedInt64Array()
var instance_map: Map
var instance_resource: InstanceResource
var request_handlers: Dictionary

func _ready() -> void:
	world_server.multiplayer_api.peer_disconnected.connect(_on_peer_disconnected)

# --- RPC Syncing with InstanceClient ---

@rpc("any_peer", "call_remote", "reliable", 0)
func ready_to_enter_instance() -> void:
	var peer_id: int = multiplayer.get_remote_sender_id()
	print("ServerInstance: Player %d ready to enter instance %s" % [peer_id, name])
	
	if instance_map:
		var spawner = instance_map.get_node_or_null("SimpleSpawner")
		if spawner and spawner.has_method("spawn_player"):
			var player_resource = null
			if world_server and world_server.connected_players.has(peer_id):
				player_resource = world_server.connected_players[peer_id]
			
			spawner.spawn_player(peer_id, player_resource)
			
			if not connected_peers.has(peer_id):
				connected_peers.append(peer_id)
		else:
			printerr("ServerInstance: SimpleSpawner not found in map!")
	else:
		printerr("ServerInstance: Map not loaded yet!")

@rpc("authority", "call_remote", "reliable", 0)
func charge_new_instance(_map_path: String, _instance_name: String) -> void:
	pass

@rpc("any_peer", "call_remote", "reliable", 1)
func data_request(_request_id: int, _type: StringName, _args: Dictionary) -> void:
	pass # Logic should be implemented here or delegated

@rpc("authority", "call_remote", "reliable", 1)
func data_response(_request_id: int, _type: StringName, _data: Dictionary) -> void:
	pass

@rpc("authority", "call_remote", "reliable", 1)
func data_push(_type: StringName, _data: Dictionary) -> void:
	pass

func load_map(map_path: String) -> void:
	if instance_map:
		instance_map.queue_free()
	
	var packed_scene: PackedScene = ResourceLoader.load(map_path, "PackedScene")
	if packed_scene == null:
		print("ERROR: Could not load map ", map_path)
		return

	var scene_node = packed_scene.instantiate()
	instance_map = scene_node as Map
	add_child(instance_map)
	print("Map loaded: ", map_path)

func _on_peer_disconnected(peer_id: int) -> void:
	var idx := connected_peers.find(peer_id)
	if idx != -1:
		connected_peers.remove_at(idx)
	
	# MultiplayerSpawner handles despawn automatically if using spawn_function?
	# If using scene list, we might need to manually free.
	# Our SimpleSpawner handles queue_free on disconnect too.

# Stub functions to prevent crashes from other scripts calling them
func get_motd() -> String: return "Welcome to Cliffwald!"
func propagate_rpc(callable: Callable) -> void: pass
func get_player(peer_id: int) -> Node: return null

func set_player_path_value(peer_id: int, rel_path: NodePath, value: Variant) -> bool:
	print("set_player_path_value stub called for %d path %s" % [peer_id, str(rel_path)])
	return falseres://source/server/world/components/instance_server.gd.uid
res://source/server/world/components/schedule_manager.gd

--- res://source/server/world/components/schedule_manager.gd ---
class_name ScheduleManager
extends Node

# The current game time in "HH:MM" format
var current_time_str: String = "08:00"
var timer: float = 0.0
var time_scale: float = 60.0

# DEBUG MODE: 0.1s per minute (1 hour = 6 seconds)
const SECONDS_PER_GAME_MINUTE = 0.1

var _hour: int = 8
var _minute: int = 0

signal time_changed(new_time: String)
signal schedule_event(event_data: Dictionary)

var schedule_res: ScheduleResource
var npc_scene = preload("res://source/common/gameplay/characters/npc/npc_simple.tscn")

func _ready() -> void:
	add_to_group("ScheduleManager")
	schedule_res = ScheduleResource.new()
	print("ScheduleManager initialized. Start time: ", current_time_str)
	
	if multiplayer.is_server():
		_spawn_student_population()

func _spawn_student_population() -> void:
	print("Spawning 84 Students...")
	var houses = ["Ignis", "Axiom", "Vesper"]
	var parent = get_parent()
	
	for house in houses:
		for year in range(1, 5): # 1 to 4
			for idx in range(1, 8): # 1 to 7
				var npc = npc_scene.instantiate()
				npc.name = "Student_%s_Y%d_%02d" % [house, year, idx]
				npc.doctrine = house
				npc.year = year
				npc.student_index = idx
				npc.position = Vector3(randf_range(-15, 15), 0.5, randf_range(-20, 20))
				parent.call_deferred("add_child", npc)
	print("Students spawned.")

func _process(delta: float) -> void:
	if not multiplayer.is_server():
		return

	timer += delta
	if timer >= SECONDS_PER_GAME_MINUTE:
		timer -= SECONDS_PER_GAME_MINUTE
		_advance_minute()

func _advance_minute() -> void:
	_minute += 1
	if _minute >= 60:
		_minute = 0
		_hour += 1
		if _hour >= 24:
			_hour = 0
	
	var time_str = "%02d:%02d" % [_hour, _minute]
	if time_str != current_time_str:
		current_time_str = time_str
		time_changed.emit(current_time_str)
		_check_schedule()

func _check_schedule() -> void:
	var events = schedule_res.get_events_at_time(current_time_str)
	for ev in events:
		print("Executing Schedule Event: ", ev)
		schedule_event.emit(ev)res://source/server/world/components/schedule_manager.gd.uid
res://source/server/world/components/simple_spawner.gd

--- res://source/server/world/components/simple_spawner.gd ---
extends Node

var player_scene = preload("res://source/common/gameplay/characters/player/net_player.tscn")

func _ready():
	if multiplayer.is_server():
		multiplayer.peer_disconnected.connect(_on_peer_disconnected)

# Called explicitly by InstanceServer when client says "I'm ready"
# OR called by client via RPC once map is loaded
@rpc("any_peer", "call_remote", "reliable", 0)
func request_spawn_server() -> void:
	var id = multiplayer.get_remote_sender_id()
	spawn_player(id)

func spawn_player(id: int, data: PlayerResource = null):
	if get_parent().has_node(str(id)):
		return # Already spawned
		
	print("Spawning NetPlayer for: %d" % id)
	var player = player_scene.instantiate()
	player.name = str(id)
	player.position = Vector3(0, 2.5, 0)
	
	if data:
		player.skin_id = data.skin_id
	
	# Check for spawn points
	var spawn_point = get_parent().get_node_or_null("SpawnPoint")
	if spawn_point:
		player.position = spawn_point.position
		
	get_parent().add_child(player)

func _on_peer_disconnected(id: int):
	var player = get_parent().get_node_or_null(str(id))
	if player:
		player.queue_free()res://source/server/world/components/simple_spawner.gd.uid
res://source/server/world/components/world_database.gd

--- res://source/server/world/components/world_database.gd ---
class_name WorldDatabase
extends Node


var database_path: String

var player_data: WorldPlayerData


func start_database(world_info: Dictionary) -> void:
	configure_database(world_info)
	load_world_database()


func configure_database(world_info: Dictionary) -> void:
	# Force using the res:// path to ensure consistency
	# In a real deployment, you might want this to be "user://"
	var name_val: Variant = world_info.get("name", "world")
	if typeof(name_val) != TYPE_STRING:
		name_val = str(name_val)
	database_path = "res://source/server/world/data/" + name_val.to_lower() + ".tres"


func load_world_database() -> void:
	if ResourceLoader.exists(database_path, "WorldPlayerData"):
		player_data = ResourceLoader.load(database_path, "WorldPlayerData")
	else:
		player_data = WorldPlayerData.new()


func save_world_database() -> void:
	var error: Error = ResourceSaver.save(player_data, database_path)
	if error:
		printerr("Error while saving player_data %s." % error_string(error))


func _notification(what: int) -> void:
	if what == NOTIFICATION_WM_CLOSE_REQUEST:
		save_world_database()
res://source/server/world/components/world_database.gd.uid
res://source/server/world/components/world_manager_client.gd

--- res://source/server/world/components/world_manager_client.gd ---
class_name WorldManagerClient
extends BaseMultiplayerEndpoint


signal token_received(auth_token: String, username: String, character_id: int)

@export var database: WorldDatabase
@export var world_server: WorldServer

var world_info: Dictionary


func start_client_to_master_server(_world_info: Dictionary) -> void:
	
	world_info = _world_info
	var configuration: Dictionary = ConfigFileUtils.load_section(
		"world-manager-client",
		CmdlineUtils.get_parsed_args().get("config", "res://data/config/world_config.cfg")
	)
	
	var tls_options: TLSOptions = null
	if configuration.has("certificate_path") and not configuration.certificate_path.is_empty():
		var cert = load(configuration.certificate_path)
		if cert:
			tls_options = TLSOptions.client_unsafe(cert)

	create(Role.CLIENT, configuration.address, configuration.port, tls_options)


func _connect_multiplayer_api_signals(api: SceneMultiplayer) -> void:
	api.connected_to_server.connect(_on_connection_succeeded)
	api.connection_failed.connect(_on_connection_failed)
	api.server_disconnected.connect(_on_server_disconnected)


func _on_connection_succeeded() -> void:
	print("Successfully connected to the Gateway as %d!" % multiplayer.get_unique_id())
	var port_val: int = int(world_info.get("port", 0))
	if port_val <= 0:
		port_val = 8087
	var addr_val: String = str(world_info.get("bind_address", "127.0.0.1"))
	var info_payload: Dictionary = {
		"name": world_info.get("name", "NoName"),
		"max_players": world_info.get("max_players", 200),
		"hardcore": world_info.get("hardcore", false),
		"motd": world_info.get("motd", "Welcome!"),
		"bonus_xp": world_info.get("bonus_xp", 0.0),
		"max_character": world_info.get("max_character", 5),
		"pvp": world_info.get("pvp", true)
	}
	fetch_server_info.rpc_id(
		1,
		{
			"port": port_val,
			"address": addr_val,
			"info": info_payload,
			"population": world_server.connected_players.size()
		}
	)


func _on_connection_failed() -> void:
	print("Failed to connect to the MasterServer as WorldServer.")


func _on_server_disconnected() -> void:
	print("Game Server disconnected.")


@rpc("any_peer")
func fetch_server_info(_info: Dictionary) -> void:
	pass


@rpc("authority")
func fetch_token(auth_token: String, username: String, character_id: int) -> void:
	token_received.emit(auth_token, username, character_id)


@rpc("any_peer")
func player_disconnected(_username: String) -> void:
	pass


@rpc("authority")
func create_player_character_request(gateway_id: int, peer_id: int, username: String, character_data: Dictionary) -> void:
	player_character_creation_result.rpc_id(
		1,
		gateway_id,
		peer_id,
		username,
		database.player_data.create_player_character(username, character_data)
	)


@rpc("any_peer")
func player_character_creation_result(_gateway_id: int, _peer_id: int, _username: String, _result_code: int) -> void:
	pass


@rpc("authority")
func request_player_characters(gateway_id: int, peer_id: int, username: String) -> void:
	receive_player_characters.rpc_id(
		1,
		database.player_data.get_account_characters(username),
		gateway_id,
		peer_id
	)


@rpc("any_peer")
func receive_player_characters(_gateway_id: int, _peer_id: int, _player_characters: Dictionary) -> void:
	pass


@rpc("authority")
func request_login(
	gateway_id: int,
	peer_id: int,
	username: String,
	character_id: int
) -> void:
	if (
		database.player_data.players.has(character_id)
		and database.player_data.players[character_id].account_name == username
	):
		result_login.rpc_id(
			1,
			OK,
			gateway_id,
			peer_id,
			username,
			character_id,
		)


@rpc("any_peer")
func result_login(
	_result_code: int,
	_gateway_id: int,
	_peer_id: int,
	_username: String,
	_character_id: int
) -> void:
	pass
res://source/server/world/components/world_manager_client.gd.uid
res://source/server/world/components/world_server.gd

--- res://source/server/world/components/world_server.gd ---
class_name WorldServer
extends BaseMultiplayerEndpoint
## Server autoload. Keep it clean and minimal.
## Should only care about connection and authentication stuff.

@export var database: WorldDatabase
@export var world_manager: WorldManagerClient

# Notifica cuando un peer complet auth y tiene PlayerResource asignado
signal player_authenticated(peer_id: int)

var token_list: Dictionary = {}
var connected_players: Dictionary = {}

func start_world_server() -> void:
	print("WorldServer.start_world_server")
	var configuration: Dictionary = ConfigFileUtils.load_section(
		"world-server",
		CmdlineUtils.get_parsed_args().get("config", "res://data/config/world_config.cfg")
	)

	if world_manager:
		world_manager.token_received.connect(
			func(auth_token: String, _username: String, character_id: int) -> void:
				var player: PlayerResource = database.player_data.get_player_resource(character_id)
				token_list[auth_token] = player
		)
	if not configuration.has("error"):
		var tls_options: TLSOptions = null
		if configuration.has("certificate_path") and configuration.has("key_path"):
			var cert = load(configuration.certificate_path)
			var key = load(configuration.key_path)
			if cert and key:
				tls_options = TLSOptions.server(key, cert)

		var err := create(Role.SERVER, configuration.bind_address, configuration.port, tls_options)
		if err != OK:
			printerr("WorldServer: no se pudo crear el peer en %s:%d (err=%s)" % [configuration.bind_address, configuration.port, error_string(err)])
		else:
			print("WorldServer escuchando en %s:%d" % [configuration.bind_address, configuration.port])

	$InstanceManager.start_instance_manager()


func _connect_multiplayer_api_signals(api: SceneMultiplayer) -> void:
	api.peer_connected.connect(_on_peer_connected)
	api.peer_disconnected.connect(_on_peer_disconnected)
	api.peer_authenticating.connect(_on_peer_authenticating)
	api.peer_authentication_failed.connect(_on_peer_authentication_failed)
	api.set_auth_callback(_authentication_callback)


func _on_peer_connected(peer_id: int) -> void:
	print("Peer: %d is connected." % peer_id)


func _on_peer_disconnected(peer_id: int) -> void:
	print("Peer: %d is disconnected." % peer_id)
	if world_manager and connected_players.has(peer_id):
		world_manager.player_disconnected.rpc_id(
			1,
			connected_players[peer_id].account_name
		)
	# IMPORTANT: Remove from connected_players to avoid stale lookups in instance_server
	connected_players.erase(peer_id)


func _on_peer_authenticating(peer_id: int) -> void:
	print("Peer: %d is trying to authenticate." % peer_id)
	multiplayer.send_auth(peer_id, "data_from_server".to_ascii_buffer())


func _on_peer_authentication_failed(peer_id: int) -> void:
	print("Peer: %d failed to authenticate." % peer_id)


func _authentication_callback(peer_id: int, data: PackedByteArray) -> void:
	var auth_token := bytes_to_var(data) as String
	print('Peer: %d is trying to connect with data: "%s".' % [peer_id, auth_token])
	if is_valid_authentication_token(auth_token):
		multiplayer.complete_auth(peer_id)
		connected_players[peer_id] = token_list[auth_token]
		token_list.erase(auth_token)
		player_authenticated.emit(peer_id)
	else:
		peer.disconnect_peer(peer_id)


func is_valid_authentication_token(auth_token: String) -> bool:
	if token_list.has(auth_token):
		return true
	return false
res://source/server/world/components/world_server.gd.uid
res://source/server/world/data/classic.tres
res://source/server/world/data/guild.gd

--- res://source/server/world/data/guild.gd ---
class_name Club
extends Resource


@export var club_name: String
@export var leader_id: int
## player_id: rank_name
@export var members: Dictionary


func add_member(player_id: int, rank: String) -> void:
	members[player_id] = rank


func remove_member(player_id: int) -> void:
	members.erase(player_id)
res://source/server/world/data/guild.gd.uid
res://source/server/world/data/server_roles.gd

--- res://source/server/world/data/server_roles.gd ---
class_name ServerRoles
extends Resource

# Lower the priority, less access to commands it has. 
# Make sure to leave the highest priority (100) to the developer/higher role 
# as it will have access to every command.

@export var roles: Dictionary = {
	"default": {
		"priority": 0,
		"commands": []
	},
	"moderator": {
		"priority": 1,
		"commands": []
	},
	"admin": {
		"priority": 2,
		"commands": []
	},
	"senior_admin": {
		"priority": 100,
		"commands": []
	}
}


func get_roles() -> Dictionary:
	return roles


func create_role() -> void:
	pass


func delete_role() -> void:
	pass
res://source/server/world/data/server_roles.gd.uid
res://source/server/world/data/server_roles.tres
res://source/server/world/data/world_player_data.gd

--- res://source/server/world/data/world_player_data.gd ---
class_name WorldPlayerData
extends Resource
# I can't recommend using Resources as a whole database, but for the demonstration,
# I found it interesting to use Godot exclusively to have a minimal setup.

## Used to store the different character IDs of registered accounts.[br][br]
## So if player with name ID "horizon" logs in to this world,
## we can retrieve its different character IDs thanks to this.[br][br]
## Here is how it should look like:
## [codeblock]
## print(accounts) # {"horizon": [6, 14], "another_guy": [2]}
## [/codeblock]
@export var accounts: Dictionary
@export var max_character_per_account: int = 3

@export var players: Dictionary
@export var next_player_id: int = 0

@export var admin_ids: PackedInt32Array
@export var user_roles: Dictionary
@export var clubs: Dictionary


func get_player_resource(player_id: int) -> PlayerResource:
	if players.has(player_id):
		return players[player_id]
	return null


func create_player_character(username: String, character_data: Dictionary) -> int:
	if (
		accounts.has(username)
		and accounts[username].size() > max_character_per_account
	):
		return -1
	
	next_player_id += 1
	var player_id: int = next_player_id
	var player_character := PlayerResource.new()
	
	# Temporary for fast test
	# No hay armas ni consumibles preasignados; los alumnos ya llevan su varita esttica.
	player_character.inventory = {}
	
	player_character.available_attributes_points = 0
	
	player_character.init(
		player_id, username,
		character_data.get("name", player_character.display_name),
		character_data.get("skin", 1)
	)
	player_character.house = character_data.get("house", &"Ignis")
	players[player_id] = player_character
	if accounts.has(username):
		accounts[username].append(player_id)
	else:
		accounts[username] = [player_id] as PackedInt32Array
	return player_id


func get_account_characters(account_name: String) -> Dictionary:
	var data: Dictionary#[int, Dictionary]
	
	if accounts.has(account_name):
		for player_id: int in accounts[account_name]:
			var player_character: PlayerResource = get_player_resource(player_id)
			if player_character:
				data[player_id] = {
					"name": player_character.display_name,
					"skin": player_character.skin_id,
					"class": "Student",
				}
	return data


func create_club(club_name: String, player_id: int) -> bool:
	var player: PlayerResource = players.get(player_id)
	if not player or clubs.has(club_name):
		return false
	var new_club: Club = Club.new()
	new_club.leader_id = player_id
	new_club.club_name = club_name
	new_club.add_member(player_id, "Leader")
	clubs[club_name] = new_club
	return true
res://source/server/world/data/world_player_data.gd.uid
res://source/server/world/world_main.gd

--- res://source/server/world/world_main.gd ---
class_name WorldMain
extends Node


var world_info: Dictionary


func _ready() -> void:
	print("WorldMain: _ready start")
	# Server tick rate
	# For comparaison:
	# Eve Online - 1 tick par second.
	# Fortnite (Battle royale 100 players) - 30 ticks per second.
	# Albion Online - 2 ticks per second (to verify).
	# Valorant (5v5 FPS game) - 128 ticks per second.
	# I believe it depends of your game and architecture, it's a large topic.
	Engine.set_physics_ticks_per_second(10) # 60 by default
	
	if DisplayServer.get_name() != "headless":
		DisplayServer.window_set_title("World Server")
		
	# Default config path. to use another one, override this;
	# or write --config=config_file_path.cfg as a launch argument.
		world_info = ConfigFileUtils.load_section_with_defaults(
			"world-server",
			CmdlineUtils.get_parsed_args().get("config", "res://data/config/world_config.cfg"),
			{
				"name": "NoName",
				"bind_address": "127.0.0.1",
				"port": 8087,
				"max_players": 200,
				"hardcore": false,
				"motd": "Welcome!",
				"bonus_xp": 0.0,
				"max_character": 5,
				"pvp": true
			}
			
		)
	if world_info.has("error"):
		printerr("World server loading configuration failed.")
	else:
		$Database.start_database(world_info)
		$WorldManagerClient.start_client_to_master_server(world_info)
		$WorldServer.start_world_server()
res://source/server/world/world_main.gd.uid
res://source/server/world/world_main.tscn

--- res://source/server/world/world_main.tscn ---
[gd_scene load_steps=7 format=3 uid="uid://deslq4wqsgjbk"]

[ext_resource type="Script" uid="uid://bml22pkupxow5" path="res://source/server/world/world_main.gd" id="1_nvmf0"]
[ext_resource type="Script" uid="uid://cf4xahse7mg4d" path="res://source/server/world/components/world_manager_client.gd" id="2_bxid2"]
[ext_resource type="Script" uid="uid://dt8py6evrtkvk" path="res://source/server/world/components/world_server.gd" id="3_u7bqt"]
[ext_resource type="Script" uid="uid://d1fja2um2iixv" path="res://source/server/world/components/instance_manager.gd" id="4_6abmg"]
[ext_resource type="Script" uid="uid://d2driy4n25j0s" path="res://source/server/world/components/world_database.gd" id="5_at7ov"]
[ext_resource type="Script" uid="uid://32l8t618k7dp" path="res://source/server/world/components/console.gd" id="6_klp0y"]

[node name="WorldMain" type="Node"]
script = ExtResource("1_nvmf0")

[node name="WorldManagerClient" type="Node" parent="." node_paths=PackedStringArray("database", "world_server")]
script = ExtResource("2_bxid2")
database = NodePath("../Database")
world_server = NodePath("../WorldServer")

[node name="WorldServer" type="Node" parent="." node_paths=PackedStringArray("database", "world_manager")]
script = ExtResource("3_u7bqt")
database = NodePath("../Database")
world_manager = NodePath("../WorldManagerClient")

[node name="InstanceManager" type="SubViewportContainer" parent="WorldServer" node_paths=PackedStringArray("world_server")]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
stretch = true
script = ExtResource("4_6abmg")
world_server = NodePath("..")

[node name="Database" type="Node" parent="."]
script = ExtResource("5_at7ov")

[node name="Console" type="Node" parent="." node_paths=PackedStringArray("database", "world_server")]
script = ExtResource("6_klp0y")
database = NodePath("../Database")
world_server = NodePath("../WorldServer")
